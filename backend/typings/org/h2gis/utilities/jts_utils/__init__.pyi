
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.util
import jpype
import org.locationtech.jts.algorithm
import org.locationtech.jts.geom
import org.locationtech.jts.math
import typing



class Contouring:
    def __init__(self): ...
    @staticmethod
    def processTriangle(triMarkers: 'TriMarkers', list: java.util.List[float]) -> java.util.Map[int, java.util.Deque['TriMarkers']]: ...
    @staticmethod
    def splitInterval(double: float, double2: float, triMarkers: 'TriMarkers', deque: java.util.Deque['TriMarkers'], deque2: java.util.Deque['TriMarkers']) -> bool: ...

class CoordinateSequenceDimensionFilter(org.locationtech.jts.geom.CoordinateSequenceFilter):
    XY: typing.ClassVar[int] = ...
    XYZ: typing.ClassVar[int] = ...
    XYZM: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def apply(geometry: org.locationtech.jts.geom.Geometry) -> 'CoordinateSequenceDimensionFilter': ...
    def filter(self, coordinateSequence: org.locationtech.jts.geom.CoordinateSequence, int: int) -> None: ...
    def getDimension(self) -> int: ...
    def is2D(self) -> bool: ...
    def isDone(self) -> bool: ...
    def isGeometryChanged(self) -> bool: ...
    def isMixed(self) -> bool: ...
    def setMAXDim(self, int: int) -> None: ...

class CoordinateUtils:
    @staticmethod
    def contains2D(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray], coordinate2: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def interpolate(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def removeDuplicatedCoordinates(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray], boolean: bool) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    @staticmethod
    def removeRepeatedCoordinates(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray], double: float, boolean: bool) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    @staticmethod
    def round(double: float, int: int) -> float: ...
    @staticmethod
    def vectorIntersection(coordinate: org.locationtech.jts.geom.Coordinate, vector3D: org.locationtech.jts.math.Vector3D, coordinate2: org.locationtech.jts.geom.Coordinate, vector3D2: org.locationtech.jts.math.Vector3D) -> org.locationtech.jts.geom.Coordinate: ...
    @staticmethod
    def zMinMax(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> typing.MutableSequence[float]: ...

class RobustLineIntersector3D(org.locationtech.jts.algorithm.RobustLineIntersector):
    def __init__(self): ...

class TriMarkers(org.locationtech.jts.geom.Triangle):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, double: float, double2: float, double3: float): ...
    @staticmethod
    def getNormalVector(triangle: org.locationtech.jts.geom.Triangle) -> org.locationtech.jts.math.Vector3D: ...
    @staticmethod
    def getSlopeInPercent(vector3D: org.locationtech.jts.math.Vector3D, double: float) -> float: ...
    @staticmethod
    def getSteepestVector(vector3D: org.locationtech.jts.math.Vector3D, double: float) -> org.locationtech.jts.math.Vector3D: ...
    @typing.overload
    @staticmethod
    def intersects(coordinate: org.locationtech.jts.geom.Coordinate, triangle: org.locationtech.jts.geom.Triangle) -> bool: ...
    @typing.overload
    @staticmethod
    def intersects(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> bool: ...
    def toString(self) -> str: ...

class VisibilityAlgorithm:
    def __init__(self, double: float): ...
    def addGeometry(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    def addLineString(self, lineString: org.locationtech.jts.geom.LineString) -> None: ...
    def addSegment(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> None: ...
    def fixSegments(self) -> None: ...
    def getEpsilon(self) -> float: ...
    def getIsoVist(self, coordinate: org.locationtech.jts.geom.Coordinate, boolean: bool) -> org.locationtech.jts.geom.Polygon: ...
    def setEpsilon(self, double: float) -> None: ...
    def setNumPoints(self, int: int) -> None: ...

class Voronoi:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    def generateTriangleNeighbors(self, geometry: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence['Voronoi.Triple']: ...
    def generateVoronoi(self, int: int) -> org.locationtech.jts.geom.GeometryCollection: ...
    def setEnvelope(self, envelope: org.locationtech.jts.geom.Envelope) -> None: ...
    class ReplaceZ(org.locationtech.jts.geom.CoordinateSequenceFilter):
        def __init__(self): ...
        def filter(self, coordinateSequence: org.locationtech.jts.geom.CoordinateSequence, int: int) -> None: ...
        def isDone(self) -> bool: ...
        def isGeometryChanged(self) -> bool: ...
    class Triple:
        @typing.overload
        def __init__(self): ...
        @typing.overload
        def __init__(self, int: int, int2: int, int3: int): ...
        def contains(self, int: int) -> bool: ...
        def get(self, int: int) -> int: ...
        def getA(self) -> int: ...
        def getB(self) -> int: ...
        def getC(self) -> int: ...
        def toArray(self) -> typing.MutableSequence[int]: ...
        def toString(self) -> str: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.h2gis.utilities.jts_utils")``.

    Contouring: typing.Type[Contouring]
    CoordinateSequenceDimensionFilter: typing.Type[CoordinateSequenceDimensionFilter]
    CoordinateUtils: typing.Type[CoordinateUtils]
    RobustLineIntersector3D: typing.Type[RobustLineIntersector3D]
    TriMarkers: typing.Type[TriMarkers]
    VisibilityAlgorithm: typing.Type[VisibilityAlgorithm]
    Voronoi: typing.Type[Voronoi]
