
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import decimal
import java.lang
import java.math
import javax.xml.namespace
import javax.xml.stream
import jpype
import typing



class Base64Variant:
    BASE64_VALUE_INVALID: typing.ClassVar[int] = ...
    BASE64_VALUE_PADDING: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, string: str, string2: str, boolean: bool, char: str, int: int): ...
    @typing.overload
    def __init__(self, base64Variant: 'Base64Variant', string: str, boolean: bool, char: str, int: int): ...
    @typing.overload
    def __init__(self, base64Variant: 'Base64Variant', string: str, int: int): ...
    def decodeBase64Byte(self, byte: int) -> int: ...
    def decodeBase64Char(self, char: str) -> int: ...
    def encodeBase64BitsAsByte(self, int: int) -> int: ...
    def encodeBase64BitsAsChar(self, int: int) -> str: ...
    @typing.overload
    def encodeBase64Chunk(self, int: int, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int2: int) -> int: ...
    @typing.overload
    def encodeBase64Chunk(self, int: int, charArray: typing.Union[typing.List[str], jpype.JArray], int2: int) -> int: ...
    @typing.overload
    def encodeBase64Partial(self, int: int, int2: int, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int3: int) -> int: ...
    @typing.overload
    def encodeBase64Partial(self, int: int, int2: int, charArray: typing.Union[typing.List[str], jpype.JArray], int3: int) -> int: ...
    def getMaxLineLength(self) -> int: ...
    def getName(self) -> str: ...
    def getPaddingByte(self) -> int: ...
    def getPaddingChar(self) -> str: ...
    def toString(self) -> str: ...
    def usesPadding(self) -> bool: ...
    def usesPaddingChar(self, char: str) -> bool: ...

class Base64Variants:
    MIME: typing.ClassVar[Base64Variant] = ...
    MIME_NO_LINEFEEDS: typing.ClassVar[Base64Variant] = ...
    PEM: typing.ClassVar[Base64Variant] = ...
    MODIFIED_FOR_URL: typing.ClassVar[Base64Variant] = ...
    def __init__(self): ...
    @staticmethod
    def getDefaultVariant() -> Base64Variant: ...

class TypedArrayDecoder:
    def __init__(self): ...
    @typing.overload
    def decodeValue(self, charArray: typing.Union[typing.List[str], jpype.JArray], int: int, int2: int) -> bool: ...
    @typing.overload
    def decodeValue(self, string: str) -> bool: ...
    def getCount(self) -> int: ...
    def hasRoom(self) -> bool: ...

class TypedValueDecoder:
    def __init__(self): ...
    @typing.overload
    def decode(self, charArray: typing.Union[typing.List[str], jpype.JArray], int: int, int2: int) -> None: ...
    @typing.overload
    def decode(self, string: str) -> None: ...
    def handleEmptyValue(self) -> None: ...

class TypedXMLStreamException(javax.xml.stream.XMLStreamException):
    @typing.overload
    def __init__(self, string: str, illegalArgumentException: java.lang.IllegalArgumentException): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, illegalArgumentException: java.lang.IllegalArgumentException): ...
    @typing.overload
    def __init__(self, string: str, string2: str, location: javax.xml.stream.Location): ...
    @typing.overload
    def __init__(self, string: str, string2: str, location: javax.xml.stream.Location, illegalArgumentException: java.lang.IllegalArgumentException): ...
    def getLexical(self) -> str: ...

class TypedXMLStreamReader(javax.xml.stream.XMLStreamReader):
    def getAttributeAs(self, int: int, typedValueDecoder: TypedValueDecoder) -> None: ...
    def getAttributeAsArray(self, int: int, typedArrayDecoder: TypedArrayDecoder) -> int: ...
    @typing.overload
    def getAttributeAsBinary(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def getAttributeAsBinary(self, int: int, base64Variant: Base64Variant) -> typing.MutableSequence[int]: ...
    def getAttributeAsBoolean(self, int: int) -> bool: ...
    def getAttributeAsDecimal(self, int: int) -> java.math.BigDecimal: ...
    def getAttributeAsDouble(self, int: int) -> float: ...
    def getAttributeAsDoubleArray(self, int: int) -> typing.MutableSequence[float]: ...
    def getAttributeAsFloat(self, int: int) -> float: ...
    def getAttributeAsFloatArray(self, int: int) -> typing.MutableSequence[float]: ...
    def getAttributeAsInt(self, int: int) -> int: ...
    def getAttributeAsIntArray(self, int: int) -> typing.MutableSequence[int]: ...
    def getAttributeAsInteger(self, int: int) -> java.math.BigInteger: ...
    def getAttributeAsLong(self, int: int) -> int: ...
    def getAttributeAsLongArray(self, int: int) -> typing.MutableSequence[int]: ...
    def getAttributeAsQName(self, int: int) -> javax.xml.namespace.QName: ...
    def getAttributeIndex(self, string: str, string2: str) -> int: ...
    def getElementAs(self, typedValueDecoder: TypedValueDecoder) -> None: ...
    @typing.overload
    def getElementAsBinary(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    def getElementAsBinary(self, base64Variant: Base64Variant) -> typing.MutableSequence[int]: ...
    def getElementAsBoolean(self) -> bool: ...
    def getElementAsDecimal(self) -> java.math.BigDecimal: ...
    def getElementAsDouble(self) -> float: ...
    def getElementAsFloat(self) -> float: ...
    def getElementAsInt(self) -> int: ...
    def getElementAsInteger(self) -> java.math.BigInteger: ...
    def getElementAsLong(self) -> int: ...
    def getElementAsQName(self) -> javax.xml.namespace.QName: ...
    def readElementAsArray(self, typedArrayDecoder: TypedArrayDecoder) -> int: ...
    @typing.overload
    def readElementAsBinary(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int) -> int: ...
    @typing.overload
    def readElementAsBinary(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int, base64Variant: Base64Variant) -> int: ...
    def readElementAsDoubleArray(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, int2: int) -> int: ...
    def readElementAsFloatArray(self, floatArray: typing.Union[typing.List[float], jpype.JArray], int: int, int2: int) -> int: ...
    def readElementAsIntArray(self, intArray: typing.Union[typing.List[int], jpype.JArray], int2: int, int3: int) -> int: ...
    def readElementAsLongArray(self, longArray: typing.Union[typing.List[int], jpype.JArray], int: int, int2: int) -> int: ...

class TypedXMLStreamWriter(javax.xml.stream.XMLStreamWriter):
    @typing.overload
    def writeBinary(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int) -> None: ...
    @typing.overload
    def writeBinary(self, base64Variant: Base64Variant, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int) -> None: ...
    @typing.overload
    def writeBinaryAttribute(self, string: str, string2: str, string3: str, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...
    @typing.overload
    def writeBinaryAttribute(self, base64Variant: Base64Variant, string: str, string2: str, string3: str, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeBooleanAttribute(self, string: str, string2: str, string3: str, boolean: bool) -> None: ...
    def writeDecimal(self, bigDecimal: typing.Union[java.math.BigDecimal, decimal.Decimal]) -> None: ...
    def writeDecimalAttribute(self, string: str, string2: str, string3: str, bigDecimal: typing.Union[java.math.BigDecimal, decimal.Decimal]) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeDoubleArray(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, int2: int) -> None: ...
    def writeDoubleArrayAttribute(self, string: str, string2: str, string3: str, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def writeDoubleAttribute(self, string: str, string2: str, string3: str, double: float) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeFloatArray(self, floatArray: typing.Union[typing.List[float], jpype.JArray], int: int, int2: int) -> None: ...
    def writeFloatArrayAttribute(self, string: str, string2: str, string3: str, floatArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def writeFloatAttribute(self, string: str, string2: str, string3: str, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeIntArray(self, intArray: typing.Union[typing.List[int], jpype.JArray], int2: int, int3: int) -> None: ...
    def writeIntArrayAttribute(self, string: str, string2: str, string3: str, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def writeIntAttribute(self, string: str, string2: str, string3: str, int: int) -> None: ...
    def writeInteger(self, bigInteger: java.math.BigInteger) -> None: ...
    def writeIntegerAttribute(self, string: str, string2: str, string3: str, bigInteger: java.math.BigInteger) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeLongArray(self, longArray: typing.Union[typing.List[int], jpype.JArray], int: int, int2: int) -> None: ...
    def writeLongArrayAttribute(self, string: str, string2: str, string3: str, longArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def writeLongAttribute(self, string: str, string2: str, string3: str, long: int) -> None: ...
    def writeQName(self, qName: javax.xml.namespace.QName) -> None: ...
    def writeQNameAttribute(self, string: str, string2: str, string3: str, qName: javax.xml.namespace.QName) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.stax2.typed")``.

    Base64Variant: typing.Type[Base64Variant]
    Base64Variants: typing.Type[Base64Variants]
    TypedArrayDecoder: typing.Type[TypedArrayDecoder]
    TypedValueDecoder: typing.Type[TypedValueDecoder]
    TypedXMLStreamException: typing.Type[TypedXMLStreamException]
    TypedXMLStreamReader: typing.Type[TypedXMLStreamReader]
    TypedXMLStreamWriter: typing.Type[TypedXMLStreamWriter]
