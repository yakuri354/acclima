
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import typing



class GroovyAnnotationRef:
    def description(self) -> str: ...
    def name(self) -> str: ...
    def type(self) -> 'GroovyClassDoc': ...

class GroovyDoc(java.lang.Comparable):
    def commentText(self) -> str: ...
    def firstSentenceCommentText(self) -> str: ...
    def getRawCommentText(self) -> str: ...
    def isAnnotationType(self) -> bool: ...
    def isAnnotationTypeElement(self) -> bool: ...
    def isClass(self) -> bool: ...
    def isConstructor(self) -> bool: ...
    def isDeprecated(self) -> bool: ...
    def isEnum(self) -> bool: ...
    def isEnumConstant(self) -> bool: ...
    def isError(self) -> bool: ...
    def isException(self) -> bool: ...
    def isField(self) -> bool: ...
    def isIncluded(self) -> bool: ...
    def isInterface(self) -> bool: ...
    def isMethod(self) -> bool: ...
    def isOrdinaryClass(self) -> bool: ...
    def name(self) -> str: ...
    def setRawCommentText(self, string: str) -> None: ...

class GroovyDocErrorReporter:
    def printError(self, string: str) -> None: ...
    def printNotice(self, string: str) -> None: ...
    def printWarning(self, string: str) -> None: ...

class GroovyParameter:
    def annotations(self) -> typing.MutableSequence[GroovyAnnotationRef]: ...
    def defaultValue(self) -> str: ...
    def name(self) -> str: ...
    def type(self) -> 'GroovyType': ...
    def typeName(self) -> str: ...

class GroovyTag:
    def name(self) -> str: ...
    def param(self) -> str: ...
    def text(self) -> str: ...

class GroovyType:
    def isPrimitive(self) -> bool: ...
    def qualifiedTypeName(self) -> str: ...
    def simpleTypeName(self) -> str: ...
    def toString(self) -> str: ...
    def typeName(self) -> str: ...

class GroovyPackageDoc(GroovyDoc):
    @typing.overload
    def allClasses(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    @typing.overload
    def allClasses(self, boolean: bool) -> typing.MutableSequence['GroovyClassDoc']: ...
    def description(self) -> str: ...
    def enums(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    def errors(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    def exceptions(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    def findClass(self, string: str) -> 'GroovyClassDoc': ...
    def getRelativeRootPath(self) -> str: ...
    def interfaces(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    def nameWithDots(self) -> str: ...
    def ordinaryClasses(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    def summary(self) -> str: ...

class GroovyProgramElementDoc(GroovyDoc):
    def annotations(self) -> typing.MutableSequence[GroovyAnnotationRef]: ...
    def containingClass(self) -> 'GroovyClassDoc': ...
    def containingPackage(self) -> GroovyPackageDoc: ...
    def isFinal(self) -> bool: ...
    def isPackagePrivate(self) -> bool: ...
    def isPrivate(self) -> bool: ...
    def isProtected(self) -> bool: ...
    def isPublic(self) -> bool: ...
    def isStatic(self) -> bool: ...
    def modifierSpecifier(self) -> int: ...
    def modifiers(self) -> str: ...
    def qualifiedName(self) -> str: ...

class GroovyRootDoc(GroovyDoc, GroovyDocErrorReporter):
    def classNamed(self, groovyClassDoc: 'GroovyClassDoc', string: str) -> 'GroovyClassDoc': ...
    def classes(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    def getResolvedClasses(self) -> java.util.Map[str, 'GroovyClassDoc']: ...
    def getVisibleClasses(self, list: java.util.List) -> java.util.Map[str, 'GroovyClassDoc']: ...
    def options(self) -> typing.MutableSequence[typing.MutableSequence[str]]: ...
    def packageNamed(self, string: str) -> GroovyPackageDoc: ...
    def specifiedClasses(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    def specifiedPackages(self) -> typing.MutableSequence[GroovyPackageDoc]: ...

class GroovyClassDoc(GroovyType, GroovyProgramElementDoc):
    @typing.overload
    def constructors(self) -> typing.MutableSequence['GroovyConstructorDoc']: ...
    @typing.overload
    def constructors(self, boolean: bool) -> typing.MutableSequence['GroovyConstructorDoc']: ...
    def definesSerializableFields(self) -> bool: ...
    def enumConstants(self) -> typing.MutableSequence['GroovyFieldDoc']: ...
    @typing.overload
    def fields(self) -> typing.MutableSequence['GroovyFieldDoc']: ...
    @typing.overload
    def fields(self, boolean: bool) -> typing.MutableSequence['GroovyFieldDoc']: ...
    def findClass(self, string: str) -> 'GroovyClassDoc': ...
    def getFullPathName(self) -> str: ...
    def getRelativeRootPath(self) -> str: ...
    def importedClasses(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    def importedPackages(self) -> typing.MutableSequence[GroovyPackageDoc]: ...
    @typing.overload
    def innerClasses(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    @typing.overload
    def innerClasses(self, boolean: bool) -> typing.MutableSequence['GroovyClassDoc']: ...
    def interfaceTypes(self) -> typing.MutableSequence[GroovyType]: ...
    def interfaces(self) -> typing.MutableSequence['GroovyClassDoc']: ...
    def isAbstract(self) -> bool: ...
    def isExternalizable(self) -> bool: ...
    def isSerializable(self) -> bool: ...
    @typing.overload
    def methods(self) -> typing.MutableSequence['GroovyMethodDoc']: ...
    @typing.overload
    def methods(self, boolean: bool) -> typing.MutableSequence['GroovyMethodDoc']: ...
    def properties(self) -> typing.MutableSequence['GroovyFieldDoc']: ...
    def serializableFields(self) -> typing.MutableSequence['GroovyFieldDoc']: ...
    def serializationMethods(self) -> typing.MutableSequence['GroovyMethodDoc']: ...
    def subclassOf(self, groovyClassDoc: 'GroovyClassDoc') -> bool: ...
    def superclass(self) -> 'GroovyClassDoc': ...
    def superclassType(self) -> GroovyType: ...
    def toString(self) -> str: ...

class GroovyMemberDoc(GroovyProgramElementDoc):
    def isSynthetic(self) -> bool: ...

class GroovyExecutableMemberDoc(GroovyMemberDoc):
    def flatSignature(self) -> str: ...
    def isNative(self) -> bool: ...
    def isSynchronized(self) -> bool: ...
    def isVarArgs(self) -> bool: ...
    def parameters(self) -> typing.MutableSequence[GroovyParameter]: ...
    def signature(self) -> str: ...
    def thrownExceptionTypes(self) -> typing.MutableSequence[GroovyType]: ...
    def thrownExceptions(self) -> typing.MutableSequence[GroovyClassDoc]: ...

class GroovyFieldDoc(GroovyMemberDoc):
    def constantValue(self) -> typing.Any: ...
    def constantValueExpression(self) -> str: ...
    def isTransient(self) -> bool: ...
    def isVolatile(self) -> bool: ...
    def type(self) -> GroovyType: ...

class GroovyConstructorDoc(GroovyExecutableMemberDoc): ...

class GroovyMethodDoc(GroovyExecutableMemberDoc):
    def isAbstract(self) -> bool: ...
    def overriddenClass(self) -> GroovyClassDoc: ...
    def overriddenMethod(self) -> 'GroovyMethodDoc': ...
    def overriddenType(self) -> GroovyType: ...
    def overrides(self, groovyMethodDoc: 'GroovyMethodDoc') -> bool: ...
    def returnType(self) -> GroovyType: ...
    def setReturnType(self, groovyType: GroovyType) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.groovydoc")``.

    GroovyAnnotationRef: typing.Type[GroovyAnnotationRef]
    GroovyClassDoc: typing.Type[GroovyClassDoc]
    GroovyConstructorDoc: typing.Type[GroovyConstructorDoc]
    GroovyDoc: typing.Type[GroovyDoc]
    GroovyDocErrorReporter: typing.Type[GroovyDocErrorReporter]
    GroovyExecutableMemberDoc: typing.Type[GroovyExecutableMemberDoc]
    GroovyFieldDoc: typing.Type[GroovyFieldDoc]
    GroovyMemberDoc: typing.Type[GroovyMemberDoc]
    GroovyMethodDoc: typing.Type[GroovyMethodDoc]
    GroovyPackageDoc: typing.Type[GroovyPackageDoc]
    GroovyParameter: typing.Type[GroovyParameter]
    GroovyProgramElementDoc: typing.Type[GroovyProgramElementDoc]
    GroovyRootDoc: typing.Type[GroovyRootDoc]
    GroovyTag: typing.Type[GroovyTag]
    GroovyType: typing.Type[GroovyType]
