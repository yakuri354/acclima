
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import java.io
import java.lang
import java.lang.ref
import java.util
import org
import typing



class Memoize:
    def __init__(self): ...
    _buildMemoizeFunction__V = typing.TypeVar('_buildMemoizeFunction__V')  # <V>
    @staticmethod
    def buildMemoizeFunction(memoizeCache: 'MemoizeCache'[typing.Any, typing.Any], closure: groovy.lang.Closure[_buildMemoizeFunction__V]) -> groovy.lang.Closure[_buildMemoizeFunction__V]: ...
    _buildSoftReferenceMemoizeFunction__V = typing.TypeVar('_buildSoftReferenceMemoizeFunction__V')  # <V>
    @staticmethod
    def buildSoftReferenceMemoizeFunction(int: int, memoizeCache: 'MemoizeCache'[typing.Any, java.lang.ref.SoftReference[typing.Any]], closure: groovy.lang.Closure[_buildSoftReferenceMemoizeFunction__V]) -> groovy.lang.Closure[_buildSoftReferenceMemoizeFunction__V]: ...

_MemoizeCache__ValueProvider__K = typing.TypeVar('_MemoizeCache__ValueProvider__K')  # <K>
_MemoizeCache__ValueProvider__V = typing.TypeVar('_MemoizeCache__ValueProvider__V')  # <V>
_MemoizeCache__K = typing.TypeVar('_MemoizeCache__K')  # <K>
_MemoizeCache__V = typing.TypeVar('_MemoizeCache__V')  # <V>
class MemoizeCache(typing.Generic[_MemoizeCache__K, _MemoizeCache__V]):
    def cleanUpNullReferences(self) -> None: ...
    def get(self, k: _MemoizeCache__K) -> _MemoizeCache__V: ...
    def getAndPut(self, k: _MemoizeCache__K, valueProvider: 'MemoizeCache.ValueProvider'[_MemoizeCache__K, _MemoizeCache__V]) -> _MemoizeCache__V: ...
    def put(self, k: _MemoizeCache__K, v: _MemoizeCache__V) -> _MemoizeCache__V: ...
    class ValueProvider(typing.Generic[_MemoizeCache__ValueProvider__K, _MemoizeCache__ValueProvider__V]):
        def provide(self, k: _MemoizeCache__ValueProvider__K) -> _MemoizeCache__ValueProvider__V: ...

_ValueConvertable__V1 = typing.TypeVar('_ValueConvertable__V1')  # <V1>
_ValueConvertable__V2 = typing.TypeVar('_ValueConvertable__V2')  # <V2>
class ValueConvertable(typing.Generic[_ValueConvertable__V1, _ValueConvertable__V2]):
    def convertValue(self, v1: _ValueConvertable__V1) -> _ValueConvertable__V2: ...

_EvictableCache__K = typing.TypeVar('_EvictableCache__K')  # <K>
_EvictableCache__V = typing.TypeVar('_EvictableCache__V')  # <V>
class EvictableCache(MemoizeCache[_EvictableCache__K, _EvictableCache__V], java.util.Map[_EvictableCache__K, _EvictableCache__V], typing.Generic[_EvictableCache__K, _EvictableCache__V]):
    def clearAll(self) -> java.util.Map[_EvictableCache__K, _EvictableCache__V]: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def keys(self) -> java.util.Set[_EvictableCache__K]: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _EvictableCache__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[_EvictableCache__V]: ...
    class EvictionStrategy(java.lang.Enum['EvictableCache.EvictionStrategy']):
        LRU: typing.ClassVar['EvictableCache.EvictionStrategy'] = ...
        FIFO: typing.ClassVar['EvictableCache.EvictionStrategy'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'EvictableCache.EvictionStrategy': ...
        @staticmethod
        def values() -> typing.MutableSequence['EvictableCache.EvictionStrategy']: ...

_LRUCache__K = typing.TypeVar('_LRUCache__K')  # <K>
_LRUCache__V = typing.TypeVar('_LRUCache__V')  # <V>
class LRUCache(MemoizeCache[_LRUCache__K, _LRUCache__V], typing.Generic[_LRUCache__K, _LRUCache__V]):
    def __init__(self, int: int): ...
    def cleanUpNullReferences(self) -> None: ...
    def get(self, k: _LRUCache__K) -> _LRUCache__V: ...
    def getAndPut(self, k: _LRUCache__K, valueProvider: MemoizeCache.ValueProvider[_LRUCache__K, _LRUCache__V]) -> _LRUCache__V: ...
    def put(self, k: _LRUCache__K, v: _LRUCache__V) -> _LRUCache__V: ...

_CommonCache__K = typing.TypeVar('_CommonCache__K')  # <K>
_CommonCache__V = typing.TypeVar('_CommonCache__V')  # <V>
class CommonCache(EvictableCache[_CommonCache__K, _CommonCache__V], ValueConvertable[_CommonCache__V, typing.Any], java.io.Serializable, typing.Generic[_CommonCache__K, _CommonCache__V]):
    DEFAULT_LOAD_FACTOR: typing.ClassVar[float] = ...
    DEFAULT_INITIAL_CAPACITY: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, evictionStrategy: EvictableCache.EvictionStrategy): ...
    @typing.overload
    def __init__(self, map: typing.Union[java.util.Map[_CommonCache__K, _CommonCache__V], typing.Mapping[_CommonCache__K, _CommonCache__V]]): ...
    def cleanUpNullReferences(self) -> None: ...
    def clear(self) -> None: ...
    def clearAll(self) -> java.util.Map[_CommonCache__K, _CommonCache__V]: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def convertValue(self, v: _CommonCache__V) -> typing.Any: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_CommonCache__K, _CommonCache__V]]: ...
    def get(self, object: typing.Any) -> _CommonCache__V: ...
    @typing.overload
    def getAndPut(self, k: _CommonCache__K, valueProvider: MemoizeCache.ValueProvider[_CommonCache__K, _CommonCache__V]) -> _CommonCache__V: ...
    @typing.overload
    def getAndPut(self, k: _CommonCache__K, valueProvider: MemoizeCache.ValueProvider[_CommonCache__K, _CommonCache__V], boolean: bool) -> _CommonCache__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[_CommonCache__K]: ...
    def keys(self) -> java.util.Set[_CommonCache__K]: ...
    def put(self, k: _CommonCache__K, v: _CommonCache__V) -> _CommonCache__V: ...
    def putAll(self, map: typing.Union[java.util.Map[_CommonCache__K, _CommonCache__V], typing.Mapping[_CommonCache__K, _CommonCache__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _CommonCache__V: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> java.util.Collection[_CommonCache__V]: ...

_ConcurrentCommonCache__Action__K = typing.TypeVar('_ConcurrentCommonCache__Action__K')  # <K>
_ConcurrentCommonCache__Action__V = typing.TypeVar('_ConcurrentCommonCache__Action__V')  # <V>
_ConcurrentCommonCache__Action__R = typing.TypeVar('_ConcurrentCommonCache__Action__R')  # <R>
_ConcurrentCommonCache__K = typing.TypeVar('_ConcurrentCommonCache__K')  # <K>
_ConcurrentCommonCache__V = typing.TypeVar('_ConcurrentCommonCache__V')  # <V>
class ConcurrentCommonCache(EvictableCache[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V], ValueConvertable[_ConcurrentCommonCache__V, typing.Any], java.io.Serializable, typing.Generic[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, evictionStrategy: EvictableCache.EvictionStrategy): ...
    @typing.overload
    def __init__(self, map: typing.Union[java.util.Map[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V], typing.Mapping[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V]]): ...
    def cleanUpNullReferences(self) -> None: ...
    def clear(self) -> None: ...
    def clearAll(self) -> java.util.Map[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V]: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def convertValue(self, v: _ConcurrentCommonCache__V) -> typing.Any: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V]]: ...
    def get(self, object: typing.Any) -> _ConcurrentCommonCache__V: ...
    @typing.overload
    def getAndPut(self, k: _ConcurrentCommonCache__K, valueProvider: MemoizeCache.ValueProvider[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V]) -> _ConcurrentCommonCache__V: ...
    @typing.overload
    def getAndPut(self, k: _ConcurrentCommonCache__K, valueProvider: MemoizeCache.ValueProvider[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V], boolean: bool) -> _ConcurrentCommonCache__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[_ConcurrentCommonCache__K]: ...
    def keys(self) -> java.util.Set[_ConcurrentCommonCache__K]: ...
    def put(self, k: _ConcurrentCommonCache__K, v: _ConcurrentCommonCache__V) -> _ConcurrentCommonCache__V: ...
    def putAll(self, map: typing.Union[java.util.Map[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V], typing.Mapping[_ConcurrentCommonCache__K, _ConcurrentCommonCache__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _ConcurrentCommonCache__V: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[_ConcurrentCommonCache__V]: ...
    class Action(typing.Generic[_ConcurrentCommonCache__Action__K, _ConcurrentCommonCache__Action__V, _ConcurrentCommonCache__Action__R]):
        def doWith(self, commonCache: CommonCache[_ConcurrentCommonCache__Action__K, _ConcurrentCommonCache__Action__V]) -> _ConcurrentCommonCache__Action__R: ...

_UnlimitedConcurrentCache__K = typing.TypeVar('_UnlimitedConcurrentCache__K')  # <K>
_UnlimitedConcurrentCache__V = typing.TypeVar('_UnlimitedConcurrentCache__V')  # <V>
class UnlimitedConcurrentCache(EvictableCache[_UnlimitedConcurrentCache__K, _UnlimitedConcurrentCache__V], java.io.Serializable, typing.Generic[_UnlimitedConcurrentCache__K, _UnlimitedConcurrentCache__V]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, map: typing.Union[java.util.Map[_UnlimitedConcurrentCache__K, _UnlimitedConcurrentCache__V], typing.Mapping[_UnlimitedConcurrentCache__K, _UnlimitedConcurrentCache__V]]): ...
    def cleanUpNullReferences(self) -> None: ...
    def clear(self) -> None: ...
    def clearAll(self) -> java.util.Map[_UnlimitedConcurrentCache__K, _UnlimitedConcurrentCache__V]: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_UnlimitedConcurrentCache__K, _UnlimitedConcurrentCache__V]]: ...
    def get(self, object: typing.Any) -> _UnlimitedConcurrentCache__V: ...
    def getAndPut(self, k: _UnlimitedConcurrentCache__K, valueProvider: MemoizeCache.ValueProvider[_UnlimitedConcurrentCache__K, _UnlimitedConcurrentCache__V]) -> _UnlimitedConcurrentCache__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[_UnlimitedConcurrentCache__K]: ...
    def keys(self) -> java.util.Set[_UnlimitedConcurrentCache__K]: ...
    def put(self, k: _UnlimitedConcurrentCache__K, v: _UnlimitedConcurrentCache__V) -> _UnlimitedConcurrentCache__V: ...
    def putAll(self, map: typing.Union[java.util.Map[_UnlimitedConcurrentCache__K, _UnlimitedConcurrentCache__V], typing.Mapping[_UnlimitedConcurrentCache__K, _UnlimitedConcurrentCache__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _UnlimitedConcurrentCache__V: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[_UnlimitedConcurrentCache__V]: ...

_ConcurrentSoftCache__K = typing.TypeVar('_ConcurrentSoftCache__K')  # <K>
_ConcurrentSoftCache__V = typing.TypeVar('_ConcurrentSoftCache__V')  # <V>
class ConcurrentSoftCache(ConcurrentCommonCache[_ConcurrentSoftCache__K, java.lang.ref.SoftReference[_ConcurrentSoftCache__V]], typing.Generic[_ConcurrentSoftCache__K, _ConcurrentSoftCache__V]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, evictionStrategy: EvictableCache.EvictionStrategy): ...
    @typing.overload
    def __init__(self, map: typing.Union[java.util.Map[_ConcurrentSoftCache__K, java.lang.ref.SoftReference[_ConcurrentSoftCache__V]], typing.Mapping[_ConcurrentSoftCache__K, java.lang.ref.SoftReference[_ConcurrentSoftCache__V]]]): ...
    def convertValue(self, softReference: java.lang.ref.SoftReference[_ConcurrentSoftCache__V]) -> typing.Any: ...

class NullProtectionStorage(org.codehaus.groovy.runtime.memoize.ProtectionStorage):
    def __init__(self): ...
    def touch(self, object: typing.Any, object2: typing.Any) -> None: ...

class ProtectionStorage: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.runtime.memoize")``.

    CommonCache: typing.Type[CommonCache]
    ConcurrentCommonCache: typing.Type[ConcurrentCommonCache]
    ConcurrentSoftCache: typing.Type[ConcurrentSoftCache]
    EvictableCache: typing.Type[EvictableCache]
    LRUCache: typing.Type[LRUCache]
    Memoize: typing.Type[Memoize]
    MemoizeCache: typing.Type[MemoizeCache]
    NullProtectionStorage: typing.Type[NullProtectionStorage]
    ProtectionStorage: typing.Type[ProtectionStorage]
    UnlimitedConcurrentCache: typing.Type[UnlimitedConcurrentCache]
    ValueConvertable: typing.Type[ValueConvertable]
