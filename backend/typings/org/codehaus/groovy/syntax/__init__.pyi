
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import groovyjarjarantlr.collections
import java.io
import java.lang
import java.util
import jpype
import org.codehaus.groovy
import org.codehaus.groovy.ast
import org.codehaus.groovy.control
import typing



class ASTHelper:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, sourceUnit: org.codehaus.groovy.control.SourceUnit, classLoader: java.lang.ClassLoader): ...
    @staticmethod
    def dot(string: str, string2: str) -> str: ...
    def getClassLoader(self) -> java.lang.ClassLoader: ...
    def getController(self) -> org.codehaus.groovy.control.SourceUnit: ...
    def getPackageName(self) -> str: ...
    def setClassLoader(self, classLoader: java.lang.ClassLoader) -> None: ...
    def setController(self, sourceUnit: org.codehaus.groovy.control.SourceUnit) -> None: ...
    def setPackage(self, string: str, list: java.util.List[org.codehaus.groovy.ast.AnnotationNode]) -> org.codehaus.groovy.ast.PackageNode: ...
    def setPackageName(self, string: str) -> None: ...

class CSTNode:
    def __init__(self): ...
    def add(self, cSTNode: 'CSTNode') -> 'CSTNode': ...
    def addChildrenOf(self, cSTNode: 'CSTNode') -> None: ...
    def asReduction(self) -> 'Reduction': ...
    def canMean(self, int: int) -> bool: ...
    def children(self) -> int: ...
    @typing.overload
    def get(self, int: int) -> 'CSTNode': ...
    @typing.overload
    def get(self, int: int, boolean: bool) -> 'CSTNode': ...
    def getDescription(self) -> str: ...
    def getMeaning(self) -> int: ...
    def getMeaningAs(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> int: ...
    @typing.overload
    def getRoot(self) -> 'Token': ...
    @typing.overload
    def getRoot(self, boolean: bool) -> 'Token': ...
    def getRootText(self) -> str: ...
    def getStartColumn(self) -> int: ...
    def getStartLine(self) -> int: ...
    def getType(self) -> int: ...
    def hasChildren(self) -> bool: ...
    def isA(self, int: int) -> bool: ...
    def isAllOf(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> bool: ...
    def isAnExpression(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isOneOf(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> bool: ...
    def markAsExpression(self) -> None: ...
    def set(self, int: int, cSTNode: 'CSTNode') -> 'CSTNode': ...
    def setMeaning(self, int: int) -> 'CSTNode': ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def write(self, printWriter: java.io.PrintWriter) -> None: ...

class Numbers:
    def __init__(self): ...
    @staticmethod
    def isDigit(char: str) -> bool: ...
    @staticmethod
    def isHexDigit(char: str) -> bool: ...
    @staticmethod
    def isNumericTypeSpecifier(char: str, boolean: bool) -> bool: ...
    @staticmethod
    def isOctalDigit(char: str) -> bool: ...
    @staticmethod
    def parseDecimal(string: str) -> java.lang.Number: ...
    @typing.overload
    @staticmethod
    def parseInteger(aST: groovyjarjarantlr.collections.AST, string: str) -> java.lang.Number: ...
    @typing.overload
    @staticmethod
    def parseInteger(string: str) -> java.lang.Number: ...

class ReadException(org.codehaus.groovy.GroovyException):
    @typing.overload
    def __init__(self, iOException: java.io.IOException): ...
    @typing.overload
    def __init__(self, string: str, iOException: java.io.IOException): ...
    def getIOCause(self) -> java.io.IOException: ...
    def getMessage(self) -> str: ...
    def toString(self) -> str: ...

class RuntimeParserException(groovy.lang.GroovyRuntimeException):
    def __init__(self, string: str, aSTNode: org.codehaus.groovy.ast.ASTNode): ...
    def throwParserException(self) -> None: ...

class SyntaxException(org.codehaus.groovy.GroovyException):
    @typing.overload
    def __init__(self, string: str, int: int, int2: int): ...
    @typing.overload
    def __init__(self, string: str, int: int, int2: int, int3: int, int4: int): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable, int: int, int2: int): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable, int: int, int2: int, int3: int, int4: int): ...
    @typing.overload
    def __init__(self, string: str, aSTNode: org.codehaus.groovy.ast.ASTNode): ...
    def getEndColumn(self) -> int: ...
    def getEndLine(self) -> int: ...
    def getLine(self) -> int: ...
    def getMessage(self) -> str: ...
    def getOriginalMessage(self) -> str: ...
    def getSourceLocator(self) -> str: ...
    def getStartColumn(self) -> int: ...
    def getStartLine(self) -> int: ...
    def setSourceLocator(self, string: str) -> None: ...

class TokenUtil:
    @staticmethod
    def removeAssignment(int: int) -> int: ...

class Types:
    EOF: typing.ClassVar[int] = ...
    UNKNOWN: typing.ClassVar[int] = ...
    NEWLINE: typing.ClassVar[int] = ...
    LEFT_CURLY_BRACE: typing.ClassVar[int] = ...
    RIGHT_CURLY_BRACE: typing.ClassVar[int] = ...
    LEFT_SQUARE_BRACKET: typing.ClassVar[int] = ...
    RIGHT_SQUARE_BRACKET: typing.ClassVar[int] = ...
    LEFT_PARENTHESIS: typing.ClassVar[int] = ...
    RIGHT_PARENTHESIS: typing.ClassVar[int] = ...
    DOT: typing.ClassVar[int] = ...
    DOT_DOT: typing.ClassVar[int] = ...
    DOT_DOT_DOT: typing.ClassVar[int] = ...
    NAVIGATE: typing.ClassVar[int] = ...
    FIND_REGEX: typing.ClassVar[int] = ...
    MATCH_REGEX: typing.ClassVar[int] = ...
    REGEX_PATTERN: typing.ClassVar[int] = ...
    EQUAL: typing.ClassVar[int] = ...
    EQUALS: typing.ClassVar[int] = ...
    ASSIGN: typing.ClassVar[int] = ...
    COMPARE_NOT_EQUAL: typing.ClassVar[int] = ...
    COMPARE_IDENTICAL: typing.ClassVar[int] = ...
    COMPARE_NOT_IDENTICAL: typing.ClassVar[int] = ...
    COMPARE_EQUAL: typing.ClassVar[int] = ...
    COMPARE_LESS_THAN: typing.ClassVar[int] = ...
    COMPARE_LESS_THAN_EQUAL: typing.ClassVar[int] = ...
    COMPARE_GREATER_THAN: typing.ClassVar[int] = ...
    COMPARE_GREATER_THAN_EQUAL: typing.ClassVar[int] = ...
    COMPARE_TO: typing.ClassVar[int] = ...
    NOT: typing.ClassVar[int] = ...
    LOGICAL_OR: typing.ClassVar[int] = ...
    LOGICAL_AND: typing.ClassVar[int] = ...
    LOGICAL_OR_EQUAL: typing.ClassVar[int] = ...
    LOGICAL_AND_EQUAL: typing.ClassVar[int] = ...
    PLUS: typing.ClassVar[int] = ...
    MINUS: typing.ClassVar[int] = ...
    MULTIPLY: typing.ClassVar[int] = ...
    DIVIDE: typing.ClassVar[int] = ...
    INTDIV: typing.ClassVar[int] = ...
    MOD: typing.ClassVar[int] = ...
    STAR_STAR: typing.ClassVar[int] = ...
    POWER: typing.ClassVar[int] = ...
    PLUS_EQUAL: typing.ClassVar[int] = ...
    MINUS_EQUAL: typing.ClassVar[int] = ...
    MULTIPLY_EQUAL: typing.ClassVar[int] = ...
    DIVIDE_EQUAL: typing.ClassVar[int] = ...
    INTDIV_EQUAL: typing.ClassVar[int] = ...
    MOD_EQUAL: typing.ClassVar[int] = ...
    POWER_EQUAL: typing.ClassVar[int] = ...
    PLUS_PLUS: typing.ClassVar[int] = ...
    PREFIX_PLUS_PLUS: typing.ClassVar[int] = ...
    POSTFIX_PLUS_PLUS: typing.ClassVar[int] = ...
    PREFIX_PLUS: typing.ClassVar[int] = ...
    MINUS_MINUS: typing.ClassVar[int] = ...
    PREFIX_MINUS_MINUS: typing.ClassVar[int] = ...
    POSTFIX_MINUS_MINUS: typing.ClassVar[int] = ...
    PREFIX_MINUS: typing.ClassVar[int] = ...
    LEFT_SHIFT: typing.ClassVar[int] = ...
    RIGHT_SHIFT: typing.ClassVar[int] = ...
    RIGHT_SHIFT_UNSIGNED: typing.ClassVar[int] = ...
    LEFT_SHIFT_EQUAL: typing.ClassVar[int] = ...
    RIGHT_SHIFT_EQUAL: typing.ClassVar[int] = ...
    RIGHT_SHIFT_UNSIGNED_EQUAL: typing.ClassVar[int] = ...
    STAR: typing.ClassVar[int] = ...
    COMMA: typing.ClassVar[int] = ...
    COLON: typing.ClassVar[int] = ...
    SEMICOLON: typing.ClassVar[int] = ...
    QUESTION: typing.ClassVar[int] = ...
    PIPE: typing.ClassVar[int] = ...
    DOUBLE_PIPE: typing.ClassVar[int] = ...
    BITWISE_OR: typing.ClassVar[int] = ...
    BITWISE_AND: typing.ClassVar[int] = ...
    BITWISE_XOR: typing.ClassVar[int] = ...
    BITWISE_OR_EQUAL: typing.ClassVar[int] = ...
    BITWISE_AND_EQUAL: typing.ClassVar[int] = ...
    BITWISE_XOR_EQUAL: typing.ClassVar[int] = ...
    BITWISE_NEGATION: typing.ClassVar[int] = ...
    STRING: typing.ClassVar[int] = ...
    IDENTIFIER: typing.ClassVar[int] = ...
    INTEGER_NUMBER: typing.ClassVar[int] = ...
    DECIMAL_NUMBER: typing.ClassVar[int] = ...
    KEYWORD_PRIVATE: typing.ClassVar[int] = ...
    KEYWORD_PROTECTED: typing.ClassVar[int] = ...
    KEYWORD_PUBLIC: typing.ClassVar[int] = ...
    KEYWORD_ABSTRACT: typing.ClassVar[int] = ...
    KEYWORD_FINAL: typing.ClassVar[int] = ...
    KEYWORD_NATIVE: typing.ClassVar[int] = ...
    KEYWORD_TRANSIENT: typing.ClassVar[int] = ...
    KEYWORD_VOLATILE: typing.ClassVar[int] = ...
    KEYWORD_SYNCHRONIZED: typing.ClassVar[int] = ...
    KEYWORD_STATIC: typing.ClassVar[int] = ...
    KEYWORD_DEF: typing.ClassVar[int] = ...
    KEYWORD_DEFMACRO: typing.ClassVar[int] = ...
    KEYWORD_CLASS: typing.ClassVar[int] = ...
    KEYWORD_INTERFACE: typing.ClassVar[int] = ...
    KEYWORD_MIXIN: typing.ClassVar[int] = ...
    KEYWORD_IMPLEMENTS: typing.ClassVar[int] = ...
    KEYWORD_EXTENDS: typing.ClassVar[int] = ...
    KEYWORD_THIS: typing.ClassVar[int] = ...
    KEYWORD_SUPER: typing.ClassVar[int] = ...
    KEYWORD_INSTANCEOF: typing.ClassVar[int] = ...
    KEYWORD_PROPERTY: typing.ClassVar[int] = ...
    KEYWORD_NEW: typing.ClassVar[int] = ...
    KEYWORD_PACKAGE: typing.ClassVar[int] = ...
    KEYWORD_IMPORT: typing.ClassVar[int] = ...
    KEYWORD_AS: typing.ClassVar[int] = ...
    KEYWORD_RETURN: typing.ClassVar[int] = ...
    KEYWORD_IF: typing.ClassVar[int] = ...
    KEYWORD_ELSE: typing.ClassVar[int] = ...
    KEYWORD_DO: typing.ClassVar[int] = ...
    KEYWORD_WHILE: typing.ClassVar[int] = ...
    KEYWORD_FOR: typing.ClassVar[int] = ...
    KEYWORD_IN: typing.ClassVar[int] = ...
    KEYWORD_BREAK: typing.ClassVar[int] = ...
    KEYWORD_CONTINUE: typing.ClassVar[int] = ...
    KEYWORD_SWITCH: typing.ClassVar[int] = ...
    KEYWORD_CASE: typing.ClassVar[int] = ...
    KEYWORD_DEFAULT: typing.ClassVar[int] = ...
    KEYWORD_TRY: typing.ClassVar[int] = ...
    KEYWORD_CATCH: typing.ClassVar[int] = ...
    KEYWORD_FINALLY: typing.ClassVar[int] = ...
    KEYWORD_THROW: typing.ClassVar[int] = ...
    KEYWORD_THROWS: typing.ClassVar[int] = ...
    KEYWORD_ASSERT: typing.ClassVar[int] = ...
    KEYWORD_VOID: typing.ClassVar[int] = ...
    KEYWORD_BOOLEAN: typing.ClassVar[int] = ...
    KEYWORD_BYTE: typing.ClassVar[int] = ...
    KEYWORD_SHORT: typing.ClassVar[int] = ...
    KEYWORD_INT: typing.ClassVar[int] = ...
    KEYWORD_LONG: typing.ClassVar[int] = ...
    KEYWORD_FLOAT: typing.ClassVar[int] = ...
    KEYWORD_DOUBLE: typing.ClassVar[int] = ...
    KEYWORD_CHAR: typing.ClassVar[int] = ...
    KEYWORD_TRUE: typing.ClassVar[int] = ...
    KEYWORD_FALSE: typing.ClassVar[int] = ...
    KEYWORD_NULL: typing.ClassVar[int] = ...
    KEYWORD_CONST: typing.ClassVar[int] = ...
    KEYWORD_GOTO: typing.ClassVar[int] = ...
    SYNTH_COMPILATION_UNIT: typing.ClassVar[int] = ...
    SYNTH_CLASS: typing.ClassVar[int] = ...
    SYNTH_INTERFACE: typing.ClassVar[int] = ...
    SYNTH_MIXIN: typing.ClassVar[int] = ...
    SYNTH_METHOD: typing.ClassVar[int] = ...
    SYNTH_PROPERTY: typing.ClassVar[int] = ...
    SYNTH_PARAMETER_DECLARATION: typing.ClassVar[int] = ...
    SYNTH_LIST: typing.ClassVar[int] = ...
    SYNTH_MAP: typing.ClassVar[int] = ...
    SYNTH_GSTRING: typing.ClassVar[int] = ...
    SYNTH_METHOD_CALL: typing.ClassVar[int] = ...
    SYNTH_CAST: typing.ClassVar[int] = ...
    SYNTH_BLOCK: typing.ClassVar[int] = ...
    SYNTH_CLOSURE: typing.ClassVar[int] = ...
    SYNTH_LABEL: typing.ClassVar[int] = ...
    SYNTH_TERNARY: typing.ClassVar[int] = ...
    SYNTH_TUPLE: typing.ClassVar[int] = ...
    SYNTH_VARIABLE_DECLARATION: typing.ClassVar[int] = ...
    GSTRING_START: typing.ClassVar[int] = ...
    GSTRING_END: typing.ClassVar[int] = ...
    GSTRING_EXPRESSION_START: typing.ClassVar[int] = ...
    GSTRING_EXPRESSION_END: typing.ClassVar[int] = ...
    ANY: typing.ClassVar[int] = ...
    NOT_EOF: typing.ClassVar[int] = ...
    GENERAL_END_OF_STATEMENT: typing.ClassVar[int] = ...
    ANY_END_OF_STATEMENT: typing.ClassVar[int] = ...
    ASSIGNMENT_OPERATOR: typing.ClassVar[int] = ...
    COMPARISON_OPERATOR: typing.ClassVar[int] = ...
    MATH_OPERATOR: typing.ClassVar[int] = ...
    LOGICAL_OPERATOR: typing.ClassVar[int] = ...
    RANGE_OPERATOR: typing.ClassVar[int] = ...
    REGEX_COMPARISON_OPERATOR: typing.ClassVar[int] = ...
    DEREFERENCE_OPERATOR: typing.ClassVar[int] = ...
    BITWISE_OPERATOR: typing.ClassVar[int] = ...
    PREFIX_OPERATOR: typing.ClassVar[int] = ...
    POSTFIX_OPERATOR: typing.ClassVar[int] = ...
    INFIX_OPERATOR: typing.ClassVar[int] = ...
    PREFIX_OR_INFIX_OPERATOR: typing.ClassVar[int] = ...
    PURE_PREFIX_OPERATOR: typing.ClassVar[int] = ...
    KEYWORD: typing.ClassVar[int] = ...
    SYMBOL: typing.ClassVar[int] = ...
    LITERAL: typing.ClassVar[int] = ...
    NUMBER: typing.ClassVar[int] = ...
    SIGN: typing.ClassVar[int] = ...
    NAMED_VALUE: typing.ClassVar[int] = ...
    TRUTH_VALUE: typing.ClassVar[int] = ...
    PRIMITIVE_TYPE: typing.ClassVar[int] = ...
    CREATABLE_PRIMITIVE_TYPE: typing.ClassVar[int] = ...
    LOOP: typing.ClassVar[int] = ...
    RESERVED_KEYWORD: typing.ClassVar[int] = ...
    KEYWORD_IDENTIFIER: typing.ClassVar[int] = ...
    SYNTHETIC: typing.ClassVar[int] = ...
    TYPE_DECLARATION: typing.ClassVar[int] = ...
    DECLARATION_MODIFIER: typing.ClassVar[int] = ...
    TYPE_NAME: typing.ClassVar[int] = ...
    CREATABLE_TYPE_NAME: typing.ClassVar[int] = ...
    MATCHED_CONTAINER: typing.ClassVar[int] = ...
    LEFT_OF_MATCHED_CONTAINER: typing.ClassVar[int] = ...
    RIGHT_OF_MATCHED_CONTAINER: typing.ClassVar[int] = ...
    EXPRESSION: typing.ClassVar[int] = ...
    OPERATOR_EXPRESSION: typing.ClassVar[int] = ...
    SYNTH_EXPRESSION: typing.ClassVar[int] = ...
    KEYWORD_EXPRESSION: typing.ClassVar[int] = ...
    LITERAL_EXPRESSION: typing.ClassVar[int] = ...
    ARRAY_EXPRESSION: typing.ClassVar[int] = ...
    SIMPLE_EXPRESSION: typing.ClassVar[int] = ...
    COMPLEX_EXPRESSION: typing.ClassVar[int] = ...
    PARAMETER_TERMINATORS: typing.ClassVar[int] = ...
    ARRAY_ITEM_TERMINATORS: typing.ClassVar[int] = ...
    TYPE_LIST_TERMINATORS: typing.ClassVar[int] = ...
    OPTIONAL_DATATYPE_FOLLOWERS: typing.ClassVar[int] = ...
    SWITCH_BLOCK_TERMINATORS: typing.ClassVar[int] = ...
    SWITCH_ENTRIES: typing.ClassVar[int] = ...
    METHOD_CALL_STARTERS: typing.ClassVar[int] = ...
    UNSAFE_OVER_NEWLINES: typing.ClassVar[int] = ...
    PRECLUDES_CAST_OPERATOR: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def canMean(int: int, int2: int) -> bool: ...
    @staticmethod
    def getDescription(int: int) -> str: ...
    @staticmethod
    def getKeywords() -> java.util.Collection[str]: ...
    @staticmethod
    def getPrecedence(int: int, boolean: bool) -> int: ...
    @staticmethod
    def getText(int: int) -> str: ...
    @staticmethod
    def isKeyword(string: str) -> bool: ...
    @staticmethod
    def lookup(string: str, int: int) -> int: ...
    @staticmethod
    def lookupKeyword(string: str) -> int: ...
    @staticmethod
    def lookupSymbol(string: str) -> int: ...
    @staticmethod
    def makePostfix(cSTNode: CSTNode, boolean: bool) -> None: ...
    @staticmethod
    def makePrefix(cSTNode: CSTNode, boolean: bool) -> None: ...
    @staticmethod
    def ofType(int: int, int2: int) -> bool: ...

class Reduction(CSTNode):
    EMPTY: typing.ClassVar['Reduction'] = ...
    def __init__(self, token: 'Token'): ...
    def add(self, cSTNode: CSTNode) -> CSTNode: ...
    def asReduction(self) -> 'Reduction': ...
    @typing.overload
    def get(self, int: int, boolean: bool) -> CSTNode: ...
    @typing.overload
    def get(self, int: int) -> CSTNode: ...
    @typing.overload
    def getRoot(self, boolean: bool) -> 'Token': ...
    @typing.overload
    def getRoot(self) -> 'Token': ...
    def isAnExpression(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def markAsExpression(self) -> None: ...
    @staticmethod
    def newContainer() -> 'Reduction': ...
    def remove(self, int: int) -> CSTNode: ...
    def set(self, int: int, cSTNode: CSTNode) -> CSTNode: ...
    def size(self) -> int: ...

class Token(CSTNode):
    NULL: typing.ClassVar['Token'] = ...
    EOF: typing.ClassVar['Token'] = ...
    def __init__(self, int: int, string: str, int2: int, int3: int): ...
    @typing.overload
    def asReduction(self) -> Reduction: ...
    @typing.overload
    def asReduction(self, cSTNode: CSTNode) -> Reduction: ...
    @typing.overload
    def asReduction(self, cSTNode: CSTNode, cSTNode2: CSTNode) -> Reduction: ...
    @typing.overload
    def asReduction(self, cSTNode: CSTNode, cSTNode2: CSTNode, cSTNode3: CSTNode) -> Reduction: ...
    def dup(self) -> 'Token': ...
    @typing.overload
    def get(self, int: int, boolean: bool) -> CSTNode: ...
    @typing.overload
    def get(self, int: int) -> CSTNode: ...
    def getMeaning(self) -> int: ...
    @typing.overload
    def getRoot(self, boolean: bool) -> 'Token': ...
    @typing.overload
    def getRoot(self) -> 'Token': ...
    def getRootText(self) -> str: ...
    def getStartColumn(self) -> int: ...
    def getStartLine(self) -> int: ...
    def getText(self) -> str: ...
    def getType(self) -> int: ...
    @staticmethod
    def newDecimal(string: str, int: int, int2: int) -> 'Token': ...
    @staticmethod
    def newIdentifier(string: str, int: int, int2: int) -> 'Token': ...
    @staticmethod
    def newInteger(string: str, int: int, int2: int) -> 'Token': ...
    @staticmethod
    def newKeyword(string: str, int: int, int2: int) -> 'Token': ...
    @staticmethod
    def newPlaceholder(int: int) -> 'Token': ...
    @staticmethod
    def newString(string: str, int: int, int2: int) -> 'Token': ...
    @typing.overload
    @staticmethod
    def newSymbol(int: int, int2: int, int3: int) -> 'Token': ...
    @typing.overload
    @staticmethod
    def newSymbol(string: str, int: int, int2: int) -> 'Token': ...
    def setMeaning(self, int: int) -> CSTNode: ...
    def setText(self, string: str) -> None: ...
    def size(self) -> int: ...

class TokenException(SyntaxException):
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable, int: int, int2: int): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable, int: int, int2: int, int3: int, int4: int): ...
    @typing.overload
    def __init__(self, string: str, token: Token): ...

class ParserException(TokenException):
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable, int: int, int2: int): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable, int: int, int2: int, int3: int, int4: int): ...
    @typing.overload
    def __init__(self, string: str, token: Token): ...

class TokenMismatchException(TokenException):
    def __init__(self, token: Token, int: int): ...
    def getExpectedType(self) -> int: ...
    def getUnexpectedToken(self) -> Token: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.syntax")``.

    ASTHelper: typing.Type[ASTHelper]
    CSTNode: typing.Type[CSTNode]
    Numbers: typing.Type[Numbers]
    ParserException: typing.Type[ParserException]
    ReadException: typing.Type[ReadException]
    Reduction: typing.Type[Reduction]
    RuntimeParserException: typing.Type[RuntimeParserException]
    SyntaxException: typing.Type[SyntaxException]
    Token: typing.Type[Token]
    TokenException: typing.Type[TokenException]
    TokenMismatchException: typing.Type[TokenMismatchException]
    TokenUtil: typing.Type[TokenUtil]
    Types: typing.Type[Types]
