
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import java.lang
import java.util
import java.util.concurrent
import jpype
import org.codehaus.groovy.ast
import org.codehaus.groovy.ast.expr
import org.codehaus.groovy.ast.stmt
import org.codehaus.groovy.control
import typing



class ExtensionMethodNode(org.codehaus.groovy.ast.MethodNode):
    @typing.overload
    def __init__(self, methodNode: org.codehaus.groovy.ast.MethodNode, string: str, int: int, classNode: org.codehaus.groovy.ast.ClassNode, parameterArray: typing.Union[typing.List[org.codehaus.groovy.ast.Parameter], jpype.JArray], classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], statement: org.codehaus.groovy.ast.stmt.Statement): ...
    @typing.overload
    def __init__(self, methodNode: org.codehaus.groovy.ast.MethodNode, string: str, int: int, classNode: org.codehaus.groovy.ast.ClassNode, parameterArray: typing.Union[typing.List[org.codehaus.groovy.ast.Parameter], jpype.JArray], classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], statement: org.codehaus.groovy.ast.stmt.Statement, boolean: bool): ...
    def getExtensionMethodNode(self) -> org.codehaus.groovy.ast.MethodNode: ...
    def isStaticExtension(self) -> bool: ...

_Receiver__T = typing.TypeVar('_Receiver__T')  # <T>
class Receiver(typing.Generic[_Receiver__T]):
    @typing.overload
    def __init__(self, classNode: org.codehaus.groovy.ast.ClassNode): ...
    @typing.overload
    def __init__(self, classNode: org.codehaus.groovy.ast.ClassNode, t: _Receiver__T): ...
    def getData(self) -> _Receiver__T: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    _make__T = typing.TypeVar('_make__T')  # <T>
    @staticmethod
    def make(classNode: org.codehaus.groovy.ast.ClassNode) -> 'Receiver'[_make__T]: ...
    def toString(self) -> str: ...

class SharedVariableCollector(org.codehaus.groovy.ast.ClassCodeVisitorSupport):
    def __init__(self, sourceUnit: org.codehaus.groovy.control.SourceUnit): ...
    def getClosureSharedExpressions(self) -> java.util.Set[org.codehaus.groovy.ast.expr.VariableExpression]: ...
    def visitVariableExpression(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...

class SignatureCodec:
    def decode(self, string: str) -> org.codehaus.groovy.ast.ClassNode: ...
    def encode(self, classNode: org.codehaus.groovy.ast.ClassNode) -> str: ...

class StaticTypeCheckingSupport:
    def __init__(self): ...
    @staticmethod
    def allParametersAndArgumentsMatch(parameterArray: typing.Union[typing.List[org.codehaus.groovy.ast.Parameter], jpype.JArray], classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray]) -> int: ...
    @typing.overload
    @staticmethod
    def checkCompatibleAssignmentTypes(classNode: org.codehaus.groovy.ast.ClassNode, classNode2: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @typing.overload
    @staticmethod
    def checkCompatibleAssignmentTypes(classNode: org.codehaus.groovy.ast.ClassNode, classNode2: org.codehaus.groovy.ast.ClassNode, expression: org.codehaus.groovy.ast.expr.Expression) -> bool: ...
    @typing.overload
    @staticmethod
    def checkCompatibleAssignmentTypes(classNode: org.codehaus.groovy.ast.ClassNode, classNode2: org.codehaus.groovy.ast.ClassNode, expression: org.codehaus.groovy.ast.expr.Expression, boolean: bool) -> bool: ...
    @staticmethod
    def chooseBestMethod(classNode: org.codehaus.groovy.ast.ClassNode, collection: typing.Union[java.util.Collection[org.codehaus.groovy.ast.MethodNode], typing.Sequence[org.codehaus.groovy.ast.MethodNode], typing.Set[org.codehaus.groovy.ast.MethodNode]], *classNode2: org.codehaus.groovy.ast.ClassNode) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    @staticmethod
    def collectAllInterfaces(classNode: org.codehaus.groovy.ast.ClassNode) -> java.util.Set[org.codehaus.groovy.ast.ClassNode]: ...
    @staticmethod
    def evaluateExpression(expression: org.codehaus.groovy.ast.expr.Expression, compilerConfiguration: org.codehaus.groovy.control.CompilerConfiguration) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def findDGMMethodsByNameAndArguments(classLoader: java.lang.ClassLoader, classNode: org.codehaus.groovy.ast.ClassNode, string: str, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray]) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    @typing.overload
    @staticmethod
    def findDGMMethodsByNameAndArguments(classLoader: java.lang.ClassLoader, classNode: org.codehaus.groovy.ast.ClassNode, string: str, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], list: java.util.List[org.codehaus.groovy.ast.MethodNode]) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    @typing.overload
    @staticmethod
    def findDGMMethodsByNameAndArguments(classNode: org.codehaus.groovy.ast.ClassNode, string: str, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray]) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    @typing.overload
    @staticmethod
    def findDGMMethodsByNameAndArguments(classNode: org.codehaus.groovy.ast.ClassNode, string: str, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], list: java.util.List[org.codehaus.groovy.ast.MethodNode]) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    @staticmethod
    def findSetters(classNode: org.codehaus.groovy.ast.ClassNode, string: str, boolean: bool) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    @staticmethod
    def getCorrectedClassNode(classNode: org.codehaus.groovy.ast.ClassNode, classNode2: org.codehaus.groovy.ast.ClassNode, boolean: bool) -> org.codehaus.groovy.ast.ClassNode: ...
    @staticmethod
    def implementsInterfaceOrIsSubclassOf(classNode: org.codehaus.groovy.ast.ClassNode, classNode2: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isAssignment(int: int) -> bool: ...
    @staticmethod
    def isBeingCompiled(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isClassClassNodeWrappingConcreteType(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isCompareToBoolean(int: int) -> bool: ...
    @staticmethod
    def isGStringOrGStringStringLUB(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isParameterizedWithGStringOrGStringString(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isParameterizedWithString(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isTraitSelf(variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> org.codehaus.groovy.ast.ClassNode: ...
    @staticmethod
    def isUsingGenericsOrIsArrayUsingGenerics(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isUsingUncheckedGenerics(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isWildcardLeftHandSide(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isWithCall(string: str, expression: org.codehaus.groovy.ast.expr.Expression) -> bool: ...
    @staticmethod
    def missesGenericsTypes(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def parameterizeArguments(classNode: org.codehaus.groovy.ast.ClassNode, methodNode: org.codehaus.groovy.ast.MethodNode) -> typing.MutableSequence[org.codehaus.groovy.ast.Parameter]: ...
    @staticmethod
    def resolveClassNodeGenerics(map: typing.Union[java.util.Map[org.codehaus.groovy.ast.GenericsType.GenericsTypeName, org.codehaus.groovy.ast.GenericsType], typing.Mapping[org.codehaus.groovy.ast.GenericsType.GenericsTypeName, org.codehaus.groovy.ast.GenericsType]], map2: typing.Union[java.util.Map[org.codehaus.groovy.ast.GenericsType.GenericsTypeName, org.codehaus.groovy.ast.GenericsType], typing.Mapping[org.codehaus.groovy.ast.GenericsType.GenericsTypeName, org.codehaus.groovy.ast.GenericsType]], classNode: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.ClassNode: ...

class StaticTypeCheckingVisitor(org.codehaus.groovy.ast.ClassCodeVisitorSupport):
    GENERATED_EMPTY_STATEMENT: typing.ClassVar[org.codehaus.groovy.ast.stmt.Statement] = ...
    CLOSURE_CALL_NO_ARG: typing.ClassVar[org.codehaus.groovy.ast.MethodNode] = ...
    CLOSURE_CALL_ONE_ARG: typing.ClassVar[org.codehaus.groovy.ast.MethodNode] = ...
    CLOSURE_CALL_VARGS: typing.ClassVar[org.codehaus.groovy.ast.MethodNode] = ...
    def __init__(self, sourceUnit: org.codehaus.groovy.control.SourceUnit, classNode: org.codehaus.groovy.ast.ClassNode): ...
    def addError(self, string: str, aSTNode: org.codehaus.groovy.ast.ASTNode) -> None: ...
    def addTypeCheckingExtension(self, typeCheckingExtension: 'TypeCheckingExtension') -> None: ...
    @staticmethod
    def extractPropertyNameFromMethodName(string: str, string2: str) -> str: ...
    def findInstanceOfNotReturnExpression(self, ifStatement: org.codehaus.groovy.ast.stmt.IfStatement) -> org.codehaus.groovy.ast.expr.BinaryExpression: ...
    def getTypeCheckingContext(self) -> 'TypeCheckingContext': ...
    @staticmethod
    def inferLoopElementType(classNode: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.ClassNode: ...
    def initialize(self) -> None: ...
    def isSkipMode(self, annotatedNode: org.codehaus.groovy.ast.AnnotatedNode) -> bool: ...
    def performSecondPass(self) -> None: ...
    def setCompilationUnit(self, compilationUnit: org.codehaus.groovy.control.CompilationUnit) -> None: ...
    def setMethodsToBeVisited(self, set: java.util.Set[org.codehaus.groovy.ast.MethodNode]) -> None: ...
    def visitAttributeExpression(self, attributeExpression: org.codehaus.groovy.ast.expr.AttributeExpression) -> None: ...
    def visitBinaryExpression(self, binaryExpression: org.codehaus.groovy.ast.expr.BinaryExpression) -> None: ...
    def visitBitwiseNegationExpression(self, bitwiseNegationExpression: org.codehaus.groovy.ast.expr.BitwiseNegationExpression) -> None: ...
    def visitBlockStatement(self, blockStatement: org.codehaus.groovy.ast.stmt.BlockStatement) -> None: ...
    def visitCaseStatement(self, caseStatement: org.codehaus.groovy.ast.stmt.CaseStatement) -> None: ...
    def visitCastExpression(self, castExpression: org.codehaus.groovy.ast.expr.CastExpression) -> None: ...
    def visitClass(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def visitClassExpression(self, classExpression: org.codehaus.groovy.ast.expr.ClassExpression) -> None: ...
    def visitClosingBlock(self, blockStatement: org.codehaus.groovy.ast.stmt.BlockStatement) -> None: ...
    def visitClosureExpression(self, closureExpression: org.codehaus.groovy.ast.expr.ClosureExpression) -> None: ...
    def visitConstructor(self, constructorNode: org.codehaus.groovy.ast.ConstructorNode) -> None: ...
    def visitConstructorCallExpression(self, constructorCallExpression: org.codehaus.groovy.ast.expr.ConstructorCallExpression) -> None: ...
    def visitField(self, fieldNode: org.codehaus.groovy.ast.FieldNode) -> None: ...
    def visitForLoop(self, forStatement: org.codehaus.groovy.ast.stmt.ForStatement) -> None: ...
    def visitIfElse(self, ifStatement: org.codehaus.groovy.ast.stmt.IfStatement) -> None: ...
    def visitInstanceofNot(self, binaryExpression: org.codehaus.groovy.ast.expr.BinaryExpression) -> None: ...
    def visitMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def visitMethodCallExpression(self, methodCallExpression: org.codehaus.groovy.ast.expr.MethodCallExpression) -> None: ...
    def visitPostfixExpression(self, postfixExpression: org.codehaus.groovy.ast.expr.PostfixExpression) -> None: ...
    def visitPrefixExpression(self, prefixExpression: org.codehaus.groovy.ast.expr.PrefixExpression) -> None: ...
    def visitProperty(self, propertyNode: org.codehaus.groovy.ast.PropertyNode) -> None: ...
    def visitPropertyExpression(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression) -> None: ...
    def visitRangeExpression(self, rangeExpression: org.codehaus.groovy.ast.expr.RangeExpression) -> None: ...
    def visitReturnStatement(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement) -> None: ...
    def visitStaticMethodCallExpression(self, staticMethodCallExpression: org.codehaus.groovy.ast.expr.StaticMethodCallExpression) -> None: ...
    def visitSwitch(self, switchStatement: org.codehaus.groovy.ast.stmt.SwitchStatement) -> None: ...
    def visitTernaryExpression(self, ternaryExpression: org.codehaus.groovy.ast.expr.TernaryExpression) -> None: ...
    def visitTryCatchFinally(self, tryCatchStatement: org.codehaus.groovy.ast.stmt.TryCatchStatement) -> None: ...
    def visitUnaryMinusExpression(self, unaryMinusExpression: org.codehaus.groovy.ast.expr.UnaryMinusExpression) -> None: ...
    def visitUnaryPlusExpression(self, unaryPlusExpression: org.codehaus.groovy.ast.expr.UnaryPlusExpression) -> None: ...
    def visitVariableExpression(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...
    def visitWhileLoop(self, whileStatement: org.codehaus.groovy.ast.stmt.WhileStatement) -> None: ...
    class SignatureCodecFactory:
        def __init__(self): ...
        @staticmethod
        def getCodec(int: int, classLoader: java.lang.ClassLoader) -> SignatureCodec: ...

class StaticTypesMarker(java.lang.Enum['StaticTypesMarker']):
    INFERRED_TYPE: typing.ClassVar['StaticTypesMarker'] = ...
    DECLARATION_INFERRED_TYPE: typing.ClassVar['StaticTypesMarker'] = ...
    INFERRED_RETURN_TYPE: typing.ClassVar['StaticTypesMarker'] = ...
    CLOSURE_ARGUMENTS: typing.ClassVar['StaticTypesMarker'] = ...
    READONLY_PROPERTY: typing.ClassVar['StaticTypesMarker'] = ...
    INITIAL_EXPRESSION: typing.ClassVar['StaticTypesMarker'] = ...
    DIRECT_METHOD_CALL_TARGET: typing.ClassVar['StaticTypesMarker'] = ...
    DELEGATION_METADATA: typing.ClassVar['StaticTypesMarker'] = ...
    IMPLICIT_RECEIVER: typing.ClassVar['StaticTypesMarker'] = ...
    PV_FIELDS_ACCESS: typing.ClassVar['StaticTypesMarker'] = ...
    PV_FIELDS_MUTATION: typing.ClassVar['StaticTypesMarker'] = ...
    PV_METHODS_ACCESS: typing.ClassVar['StaticTypesMarker'] = ...
    DYNAMIC_RESOLUTION: typing.ClassVar['StaticTypesMarker'] = ...
    SUPER_MOP_METHOD_REQUIRED: typing.ClassVar['StaticTypesMarker'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'StaticTypesMarker': ...
    @staticmethod
    def values() -> typing.MutableSequence['StaticTypesMarker']: ...

class TypeCheckingContext:
    def __init__(self, staticTypeCheckingVisitor: StaticTypeCheckingVisitor): ...
    def getCompilationUnit(self) -> org.codehaus.groovy.control.CompilationUnit: ...
    def getEnclosingBinaryExpression(self) -> org.codehaus.groovy.ast.expr.BinaryExpression: ...
    def getEnclosingBinaryExpressionStack(self) -> java.util.List[org.codehaus.groovy.ast.expr.BinaryExpression]: ...
    def getEnclosingClassNode(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def getEnclosingClassNodes(self) -> java.util.List[org.codehaus.groovy.ast.ClassNode]: ...
    def getEnclosingClosure(self) -> 'TypeCheckingContext.EnclosingClosure': ...
    def getEnclosingClosureStack(self) -> java.util.List['TypeCheckingContext.EnclosingClosure']: ...
    def getEnclosingConstructorCall(self) -> org.codehaus.groovy.ast.expr.ConstructorCallExpression: ...
    def getEnclosingConstructorCalls(self) -> java.util.List[org.codehaus.groovy.ast.expr.ConstructorCallExpression]: ...
    def getEnclosingMethod(self) -> org.codehaus.groovy.ast.MethodNode: ...
    def getEnclosingMethodCall(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getEnclosingMethodCalls(self) -> java.util.List[org.codehaus.groovy.ast.expr.Expression]: ...
    def getEnclosingMethods(self) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    def getEnclosingPropertyExpression(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getEnclosingPropertyExpressions(self) -> java.util.List[org.codehaus.groovy.ast.expr.PropertyExpression]: ...
    def getEnclosingReturnStatement(self) -> org.codehaus.groovy.ast.stmt.ReturnStatement: ...
    def getErrorCollector(self) -> org.codehaus.groovy.control.ErrorCollector: ...
    def getErrorCollectors(self) -> java.util.List[org.codehaus.groovy.control.ErrorCollector]: ...
    def getSource(self) -> org.codehaus.groovy.control.SourceUnit: ...
    def popEnclosingBinaryExpression(self) -> org.codehaus.groovy.ast.expr.BinaryExpression: ...
    def popEnclosingClassNode(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def popEnclosingClosure(self) -> 'TypeCheckingContext.EnclosingClosure': ...
    def popEnclosingConstructorCall(self) -> org.codehaus.groovy.ast.expr.ConstructorCallExpression: ...
    def popEnclosingMethod(self) -> org.codehaus.groovy.ast.MethodNode: ...
    def popEnclosingMethodCall(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def popEnclosingPropertyExpression(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def popEnclosingReturnStatement(self) -> org.codehaus.groovy.ast.stmt.ReturnStatement: ...
    def popErrorCollector(self) -> org.codehaus.groovy.control.ErrorCollector: ...
    def popTemporaryTypeInfo(self) -> None: ...
    def pushEnclosingBinaryExpression(self, binaryExpression: org.codehaus.groovy.ast.expr.BinaryExpression) -> None: ...
    def pushEnclosingClassNode(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def pushEnclosingClosureExpression(self, closureExpression: org.codehaus.groovy.ast.expr.ClosureExpression) -> None: ...
    def pushEnclosingConstructorCall(self, constructorCallExpression: org.codehaus.groovy.ast.expr.ConstructorCallExpression) -> None: ...
    def pushEnclosingMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def pushEnclosingMethodCall(self, expression: org.codehaus.groovy.ast.expr.Expression) -> None: ...
    def pushEnclosingPropertyExpression(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression) -> None: ...
    def pushEnclosingReturnStatement(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement) -> None: ...
    @typing.overload
    def pushErrorCollector(self) -> org.codehaus.groovy.control.ErrorCollector: ...
    @typing.overload
    def pushErrorCollector(self, errorCollector: org.codehaus.groovy.control.ErrorCollector) -> None: ...
    def pushTemporaryTypeInfo(self) -> None: ...
    def setCompilationUnit(self, compilationUnit: org.codehaus.groovy.control.CompilationUnit) -> None: ...
    class EnclosingClosure:
        def __init__(self, closureExpression: org.codehaus.groovy.ast.expr.ClosureExpression): ...
        def addReturnType(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
        def getClosureExpression(self) -> org.codehaus.groovy.ast.expr.ClosureExpression: ...
        def getReturnTypes(self) -> java.util.List[org.codehaus.groovy.ast.ClassNode]: ...
        def toString(self) -> str: ...

class TypeCheckingExtension:
    def __init__(self, staticTypeCheckingVisitor: StaticTypeCheckingVisitor): ...
    def addStaticTypeError(self, string: str, aSTNode: org.codehaus.groovy.ast.ASTNode) -> None: ...
    def afterMethodCall(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> None: ...
    def afterVisitClass(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def afterVisitMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def beforeMethodCall(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> bool: ...
    def beforeVisitClass(self, classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    def beforeVisitMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> bool: ...
    def buildListType(self, classNode: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.ClassNode: ...
    def buildMapType(self, classNode: org.codehaus.groovy.ast.ClassNode, classNode2: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.ClassNode: ...
    @typing.overload
    def classNodeFor(self, class_: typing.Type) -> org.codehaus.groovy.ast.ClassNode: ...
    @typing.overload
    def classNodeFor(self, string: str) -> org.codehaus.groovy.ast.ClassNode: ...
    @typing.overload
    def existsProperty(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression, boolean: bool) -> bool: ...
    @typing.overload
    def existsProperty(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression, boolean: bool, classCodeVisitorSupport: org.codehaus.groovy.ast.ClassCodeVisitorSupport) -> bool: ...
    def extractStaticReceiver(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> org.codehaus.groovy.ast.ClassNode: ...
    def finish(self) -> None: ...
    def getArgumentTypes(self, argumentListExpression: org.codehaus.groovy.ast.expr.ArgumentListExpression) -> typing.MutableSequence[org.codehaus.groovy.ast.ClassNode]: ...
    def getTargetMethod(self, expression: org.codehaus.groovy.ast.expr.Expression) -> org.codehaus.groovy.ast.MethodNode: ...
    def getType(self, aSTNode: org.codehaus.groovy.ast.ASTNode) -> org.codehaus.groovy.ast.ClassNode: ...
    def handleAmbiguousMethods(self, list: java.util.List[org.codehaus.groovy.ast.MethodNode], expression: org.codehaus.groovy.ast.expr.Expression) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    def handleIncompatibleAssignment(self, classNode: org.codehaus.groovy.ast.ClassNode, classNode2: org.codehaus.groovy.ast.ClassNode, expression: org.codehaus.groovy.ast.expr.Expression) -> bool: ...
    def handleIncompatibleReturnType(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement, classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    def handleMissingMethod(self, classNode: org.codehaus.groovy.ast.ClassNode, string: str, argumentListExpression: org.codehaus.groovy.ast.expr.ArgumentListExpression, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    def handleUnresolvedAttribute(self, attributeExpression: org.codehaus.groovy.ast.expr.AttributeExpression) -> bool: ...
    def handleUnresolvedProperty(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression) -> bool: ...
    def handleUnresolvedVariableExpression(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> bool: ...
    def isStaticMethodCallOnClass(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall, classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    def lookupClassNodeFor(self, string: str) -> org.codehaus.groovy.ast.ClassNode: ...
    def onMethodSelection(self, expression: org.codehaus.groovy.ast.expr.Expression, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def parameterizedType(self, classNode: org.codehaus.groovy.ast.ClassNode, *classNode2: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.ClassNode: ...
    def setup(self) -> None: ...
    def storeType(self, expression: org.codehaus.groovy.ast.expr.Expression, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...

class AbstractTypeCheckingExtension(TypeCheckingExtension):
    def __init__(self, staticTypeCheckingVisitor: StaticTypeCheckingVisitor): ...
    @typing.overload
    def argTypeMatches(self, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], int: int, class2: typing.Type) -> bool: ...
    @typing.overload
    def argTypeMatches(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall, int: int, class_: typing.Type) -> bool: ...
    @typing.overload
    def argTypesMatches(self, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], *class2: typing.Type) -> bool: ...
    @typing.overload
    def argTypesMatches(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall, *class_: typing.Type) -> bool: ...
    @typing.overload
    def delegatesTo(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    @typing.overload
    def delegatesTo(self, classNode: org.codehaus.groovy.ast.ClassNode, int: int) -> None: ...
    @typing.overload
    def delegatesTo(self, classNode: org.codehaus.groovy.ast.ClassNode, int: int, delegationMetadata: 'DelegationMetadata') -> None: ...
    @typing.overload
    def firstArgTypesMatches(self, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], *class2: typing.Type) -> bool: ...
    @typing.overload
    def firstArgTypesMatches(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall, *class_: typing.Type) -> bool: ...
    def getArguments(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> org.codehaus.groovy.ast.expr.ArgumentListExpression: ...
    def getCurrentScope(self) -> 'AbstractTypeCheckingExtension.TypeCheckingScope': ...
    def getEnclosingBinaryExpression(self) -> org.codehaus.groovy.ast.expr.BinaryExpression: ...
    def getEnclosingBinaryExpressionStack(self) -> java.util.List[org.codehaus.groovy.ast.expr.BinaryExpression]: ...
    def getEnclosingClassNode(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def getEnclosingClassNodes(self) -> java.util.List[org.codehaus.groovy.ast.ClassNode]: ...
    def getEnclosingClosure(self) -> TypeCheckingContext.EnclosingClosure: ...
    def getEnclosingClosureStack(self) -> java.util.List[TypeCheckingContext.EnclosingClosure]: ...
    def getEnclosingMethod(self) -> org.codehaus.groovy.ast.MethodNode: ...
    def getEnclosingMethodCall(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getEnclosingMethodCalls(self) -> java.util.List[org.codehaus.groovy.ast.expr.Expression]: ...
    def getEnclosingMethods(self) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    def getGeneratedMethods(self) -> java.util.Set[org.codehaus.groovy.ast.MethodNode]: ...
    @typing.overload
    def isAnnotatedBy(self, aSTNode: org.codehaus.groovy.ast.ASTNode, class_: typing.Type) -> bool: ...
    @typing.overload
    def isAnnotatedBy(self, aSTNode: org.codehaus.groovy.ast.ASTNode, classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    def isDynamic(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> bool: ...
    def isExtensionMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> bool: ...
    def isGenerated(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> bool: ...
    def isMethodCall(self, object: typing.Any) -> bool: ...
    def log(self, string: str) -> None: ...
    @typing.overload
    def makeDynamic(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> org.codehaus.groovy.ast.MethodNode: ...
    @typing.overload
    def makeDynamic(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall, classNode: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.MethodNode: ...
    @typing.overload
    def makeDynamic(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression) -> None: ...
    @typing.overload
    def makeDynamic(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    @typing.overload
    def makeDynamic(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...
    @typing.overload
    def makeDynamic(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    @typing.overload
    def newMethod(self, string: str, class_: typing.Type) -> org.codehaus.groovy.ast.MethodNode: ...
    @typing.overload
    def newMethod(self, string: str, callable: typing.Union[java.util.concurrent.Callable[org.codehaus.groovy.ast.ClassNode], typing.Callable[[], org.codehaus.groovy.ast.ClassNode]]) -> org.codehaus.groovy.ast.MethodNode: ...
    @typing.overload
    def newMethod(self, string: str, classNode: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.MethodNode: ...
    @typing.overload
    def newScope(self) -> 'AbstractTypeCheckingExtension.TypeCheckingScope': ...
    @typing.overload
    def newScope(self, closure: groovy.lang.Closure) -> 'AbstractTypeCheckingExtension.TypeCheckingScope': ...
    def popEnclosingBinaryExpression(self) -> org.codehaus.groovy.ast.expr.BinaryExpression: ...
    def popEnclosingClassNode(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def popEnclosingClosure(self) -> TypeCheckingContext.EnclosingClosure: ...
    def popEnclosingMethod(self) -> org.codehaus.groovy.ast.MethodNode: ...
    def popEnclosingMethodCall(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def popTemporaryTypeInfo(self) -> None: ...
    def pushEnclosingBinaryExpression(self, binaryExpression: org.codehaus.groovy.ast.expr.BinaryExpression) -> None: ...
    def pushEnclosingClassNode(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def pushEnclosingClosureExpression(self, closureExpression: org.codehaus.groovy.ast.expr.ClosureExpression) -> None: ...
    def pushEnclosingMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def pushEnclosingMethodCall(self, expression: org.codehaus.groovy.ast.expr.Expression) -> None: ...
    def pushTemporaryTypeInfo(self) -> None: ...
    @typing.overload
    def scopeExit(self) -> 'AbstractTypeCheckingExtension.TypeCheckingScope': ...
    @typing.overload
    def scopeExit(self, closure: groovy.lang.Closure) -> 'AbstractTypeCheckingExtension.TypeCheckingScope': ...
    def setHandled(self, boolean: bool) -> None: ...
    def unique(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    _withTypeChecker__R = typing.TypeVar('_withTypeChecker__R')  # <R>
    def withTypeChecker(self, closure: groovy.lang.Closure[_withTypeChecker__R]) -> _withTypeChecker__R: ...
    class TypeCheckingScope: ...

class DefaultTypeCheckingExtension(TypeCheckingExtension):
    def __init__(self, staticTypeCheckingVisitor: StaticTypeCheckingVisitor): ...
    def addHandler(self, typeCheckingExtension: TypeCheckingExtension) -> None: ...
    def afterMethodCall(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> None: ...
    def afterVisitClass(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def afterVisitMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def beforeMethodCall(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> bool: ...
    def beforeVisitClass(self, classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    def beforeVisitMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> bool: ...
    def finish(self) -> None: ...
    def handleAmbiguousMethods(self, list: java.util.List[org.codehaus.groovy.ast.MethodNode], expression: org.codehaus.groovy.ast.expr.Expression) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    def handleIncompatibleAssignment(self, classNode: org.codehaus.groovy.ast.ClassNode, classNode2: org.codehaus.groovy.ast.ClassNode, expression: org.codehaus.groovy.ast.expr.Expression) -> bool: ...
    def handleIncompatibleReturnType(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement, classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    def handleMissingMethod(self, classNode: org.codehaus.groovy.ast.ClassNode, string: str, argumentListExpression: org.codehaus.groovy.ast.expr.ArgumentListExpression, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    def handleUnresolvedAttribute(self, attributeExpression: org.codehaus.groovy.ast.expr.AttributeExpression) -> bool: ...
    def handleUnresolvedProperty(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression) -> bool: ...
    def handleUnresolvedVariableExpression(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> bool: ...
    def onMethodSelection(self, expression: org.codehaus.groovy.ast.expr.Expression, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def removeHandler(self, typeCheckingExtension: TypeCheckingExtension) -> None: ...
    def setup(self) -> None: ...

class SignatureCodecVersion1(SignatureCodec):
    def __init__(self, classLoader: java.lang.ClassLoader): ...
    def decode(self, string: str) -> org.codehaus.groovy.ast.ClassNode: ...
    def encode(self, classNode: org.codehaus.groovy.ast.ClassNode) -> str: ...

class DelegationMetadata: ...

class GroovyTypeCheckingExtensionSupport(AbstractTypeCheckingExtension):
    def __init__(self, staticTypeCheckingVisitor: StaticTypeCheckingVisitor, string: str, compilationUnit: org.codehaus.groovy.control.CompilationUnit): ...
    def afterMethodCall(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> None: ...
    def afterVisitClass(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def afterVisitMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def beforeMethodCall(self, methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> bool: ...
    def beforeVisitClass(self, classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    def beforeVisitMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> bool: ...
    def finish(self) -> None: ...
    def handleAmbiguousMethods(self, list: java.util.List[org.codehaus.groovy.ast.MethodNode], expression: org.codehaus.groovy.ast.expr.Expression) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    def handleIncompatibleAssignment(self, classNode: org.codehaus.groovy.ast.ClassNode, classNode2: org.codehaus.groovy.ast.ClassNode, expression: org.codehaus.groovy.ast.expr.Expression) -> bool: ...
    def handleIncompatibleReturnType(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement, classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    def handleMissingMethod(self, classNode: org.codehaus.groovy.ast.ClassNode, string: str, argumentListExpression: org.codehaus.groovy.ast.expr.ArgumentListExpression, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    def handleUnresolvedAttribute(self, attributeExpression: org.codehaus.groovy.ast.expr.AttributeExpression) -> bool: ...
    def handleUnresolvedProperty(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression) -> bool: ...
    def handleUnresolvedVariableExpression(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> bool: ...
    def onMethodSelection(self, expression: org.codehaus.groovy.ast.expr.Expression, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def setDebug(self, boolean: bool) -> None: ...
    def setup(self) -> None: ...
    class TypeCheckingDSL(groovy.lang.Script):
        def __init__(self): ...
        def getProperty(self, string: str) -> typing.Any: ...
        def invokeMethod(self, string: str, object: typing.Any) -> typing.Any: ...
        def setProperty(self, string: str, object: typing.Any) -> None: ...

class TraitTypeCheckingExtension(AbstractTypeCheckingExtension):
    def __init__(self, staticTypeCheckingVisitor: StaticTypeCheckingVisitor): ...
    def handleMissingMethod(self, classNode: org.codehaus.groovy.ast.ClassNode, string: str, argumentListExpression: org.codehaus.groovy.ast.expr.ArgumentListExpression, classNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ClassNode], jpype.JArray], methodCall: org.codehaus.groovy.ast.expr.MethodCall) -> java.util.List[org.codehaus.groovy.ast.MethodNode]: ...
    def setup(self) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.transform.stc")``.

    AbstractTypeCheckingExtension: typing.Type[AbstractTypeCheckingExtension]
    DefaultTypeCheckingExtension: typing.Type[DefaultTypeCheckingExtension]
    DelegationMetadata: typing.Type[DelegationMetadata]
    ExtensionMethodNode: typing.Type[ExtensionMethodNode]
    GroovyTypeCheckingExtensionSupport: typing.Type[GroovyTypeCheckingExtensionSupport]
    Receiver: typing.Type[Receiver]
    SharedVariableCollector: typing.Type[SharedVariableCollector]
    SignatureCodec: typing.Type[SignatureCodec]
    SignatureCodecVersion1: typing.Type[SignatureCodecVersion1]
    StaticTypeCheckingSupport: typing.Type[StaticTypeCheckingSupport]
    StaticTypeCheckingVisitor: typing.Type[StaticTypeCheckingVisitor]
    StaticTypesMarker: typing.Type[StaticTypesMarker]
    TraitTypeCheckingExtension: typing.Type[TraitTypeCheckingExtension]
    TypeCheckingContext: typing.Type[TypeCheckingContext]
    TypeCheckingExtension: typing.Type[TypeCheckingExtension]
