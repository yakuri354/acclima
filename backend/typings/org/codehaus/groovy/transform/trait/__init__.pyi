
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.transform
import java.lang.annotation
import java.lang.reflect
import java.util
import jpype
import org.codehaus.groovy.ast
import org.codehaus.groovy.control
import org.codehaus.groovy.transform
import typing



class TraitASTTransformation(org.codehaus.groovy.transform.AbstractASTTransformation, groovy.transform.CompilationUnitAware):
    DO_DYNAMIC: typing.ClassVar[str] = ...
    POST_TYPECHECKING_REPLACEMENT: typing.ClassVar[str] = ...
    def __init__(self): ...
    def setCompilationUnit(self, compilationUnit: org.codehaus.groovy.control.CompilationUnit) -> None: ...
    def visit(self, aSTNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ASTNode], jpype.JArray], sourceUnit: org.codehaus.groovy.control.SourceUnit) -> None: ...

class TraitComposer:
    COMPILESTATIC_CLASSNODE: typing.ClassVar[org.codehaus.groovy.ast.ClassNode] = ...
    def __init__(self): ...
    @staticmethod
    def doExtendTraits(classNode: org.codehaus.groovy.ast.ClassNode, sourceUnit: org.codehaus.groovy.control.SourceUnit, compilationUnit: org.codehaus.groovy.control.CompilationUnit) -> None: ...

class Traits:
    IMPLEMENTED_CLASSNODE: typing.ClassVar[org.codehaus.groovy.ast.ClassNode] = ...
    TRAITBRIDGE_CLASSNODE: typing.ClassVar[org.codehaus.groovy.ast.ClassNode] = ...
    TRAIT_CLASS: typing.ClassVar[typing.Type] = ...
    TRAIT_CLASSNODE: typing.ClassVar[org.codehaus.groovy.ast.ClassNode] = ...
    GENERATED_PROXY_CLASSNODE: typing.ClassVar[org.codehaus.groovy.ast.ClassNode] = ...
    SELFTYPE_CLASSNODE: typing.ClassVar[org.codehaus.groovy.ast.ClassNode] = ...
    THIS_OBJECT: typing.ClassVar[str] = ...
    STATIC_THIS_OBJECT: typing.ClassVar[str] = ...
    def __init__(self): ...
    @staticmethod
    def collectAllInterfacesReverseOrder(classNode: org.codehaus.groovy.ast.ClassNode, linkedHashSet: java.util.LinkedHashSet[org.codehaus.groovy.ast.ClassNode]) -> java.util.LinkedHashSet[org.codehaus.groovy.ast.ClassNode]: ...
    @typing.overload
    @staticmethod
    def collectSelfTypes(classNode: org.codehaus.groovy.ast.ClassNode, linkedHashSet: java.util.LinkedHashSet[org.codehaus.groovy.ast.ClassNode]) -> java.util.LinkedHashSet[org.codehaus.groovy.ast.ClassNode]: ...
    @typing.overload
    @staticmethod
    def collectSelfTypes(classNode: org.codehaus.groovy.ast.ClassNode, linkedHashSet: java.util.LinkedHashSet[org.codehaus.groovy.ast.ClassNode], boolean: bool, boolean2: bool) -> java.util.LinkedHashSet[org.codehaus.groovy.ast.ClassNode]: ...
    @staticmethod
    def decomposeSuperCallName(string: str) -> typing.MutableSequence[str]: ...
    @staticmethod
    def findFieldHelper(classNode: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.ClassNode: ...
    @staticmethod
    def findHelper(classNode: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.ClassNode: ...
    @staticmethod
    def findStaticFieldHelper(classNode: org.codehaus.groovy.ast.ClassNode) -> org.codehaus.groovy.ast.ClassNode: ...
    _getAsType__T = typing.TypeVar('_getAsType__T')  # <T>
    @staticmethod
    def getAsType(object: typing.Any, class_: typing.Type[_getAsType__T]) -> _getAsType__T: ...
    @staticmethod
    def getBridgeMethodTarget(method: java.lang.reflect.Method) -> java.lang.reflect.Method: ...
    @typing.overload
    @staticmethod
    def hasDefaultImplementation(method: java.lang.reflect.Method) -> bool: ...
    @typing.overload
    @staticmethod
    def hasDefaultImplementation(methodNode: org.codehaus.groovy.ast.MethodNode) -> bool: ...
    @staticmethod
    def isAnnotatedWithTrait(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    @staticmethod
    def isBridgeMethod(method: java.lang.reflect.Method) -> bool: ...
    @typing.overload
    @staticmethod
    def isTrait(class_: typing.Type[typing.Any]) -> bool: ...
    @typing.overload
    @staticmethod
    def isTrait(classNode: org.codehaus.groovy.ast.ClassNode) -> bool: ...
    class Implemented(java.lang.annotation.Annotation):
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...
    class TraitBridge(java.lang.annotation.Annotation):
        def desc(self) -> str: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...
        def traitClass(self) -> typing.Type[typing.Any]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.transform.trait")``.

    TraitASTTransformation: typing.Type[TraitASTTransformation]
    TraitComposer: typing.Type[TraitComposer]
    Traits: typing.Type[Traits]
