
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import java.lang
import java.util
import jpype
import org
import org.codehaus.groovy.ast
import org.codehaus.groovy.ast.expr
import org.codehaus.groovy.ast.stmt
import org.codehaus.groovy.control
import org.codehaus.groovy.runtime
import org.codehaus.groovy.transform
import typing



class AstHelper(groovy.lang.GroovyObject):
    def __init__(self): ...
    @staticmethod
    def createVariableAlias(string: str, classNode: org.codehaus.groovy.ast.ClassNode, string2: str) -> org.codehaus.groovy.ast.stmt.ExpressionStatement: ...
    @typing.overload
    @staticmethod
    def createVariableDefinition(string: str, classNode: org.codehaus.groovy.ast.ClassNode, expression: org.codehaus.groovy.ast.expr.Expression) -> org.codehaus.groovy.ast.stmt.ExpressionStatement: ...
    @typing.overload
    @staticmethod
    def createVariableDefinition(string: str, classNode: org.codehaus.groovy.ast.ClassNode, expression: org.codehaus.groovy.ast.expr.Expression, boolean: bool) -> org.codehaus.groovy.ast.stmt.ExpressionStatement: ...
    @staticmethod
    def createVariableReference(map: typing.Union[java.util.Map, typing.Mapping]) -> org.codehaus.groovy.ast.expr.VariableExpression: ...
    @staticmethod
    def recurByThrowStatement() -> org.codehaus.groovy.ast.stmt.Statement: ...
    @staticmethod
    def recurStatement() -> org.codehaus.groovy.ast.stmt.Statement: ...

class CollectRecursiveCalls(org.codehaus.groovy.ast.CodeVisitorSupport, groovy.lang.GroovyObject):
    def __init__(self): ...
    def collect(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> java.util.List[org.codehaus.groovy.ast.expr.Expression]: ...
    def getMethod(self) -> org.codehaus.groovy.ast.MethodNode: ...
    def getRecursiveCalls(self) -> java.util.List[org.codehaus.groovy.ast.expr.Expression]: ...
    def setMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def setRecursiveCalls(self, list: java.util.List[org.codehaus.groovy.ast.expr.Expression]) -> None: ...
    def visitMethodCallExpression(self, methodCallExpression: org.codehaus.groovy.ast.expr.MethodCallExpression) -> None: ...
    def visitStaticMethodCallExpression(self, staticMethodCallExpression: org.codehaus.groovy.ast.expr.StaticMethodCallExpression) -> None: ...

class GotoRecurHereException(java.lang.Throwable, groovy.lang.GroovyObject):
    def __init__(self): ...

class HasRecursiveCalls(org.codehaus.groovy.ast.CodeVisitorSupport, groovy.lang.GroovyObject):
    def __init__(self): ...
    def getHasRecursiveCalls(self) -> bool: ...
    def getMethod(self) -> org.codehaus.groovy.ast.MethodNode: ...
    def isHasRecursiveCalls(self) -> bool: ...
    def setHasRecursiveCalls(self, boolean: bool) -> None: ...
    def setMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def test(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> bool: ...
    def visitMethodCallExpression(self, methodCallExpression: org.codehaus.groovy.ast.expr.MethodCallExpression) -> None: ...
    def visitStaticMethodCallExpression(self, staticMethodCallExpression: org.codehaus.groovy.ast.expr.StaticMethodCallExpression) -> None: ...

class InWhileLoopWrapper(groovy.lang.GroovyObject):
    def __init__(self): ...
    @staticmethod
    def getLOOP_EXCEPTION() -> GotoRecurHereException: ...
    @staticmethod
    def getLOOP_LABEL() -> str: ...
    def wrap(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...

class RecursivenessTester(groovy.lang.GroovyObject):
    def __init__(self): ...
    @typing.overload
    def isRecursive(self, object: typing.Any) -> bool: ...
    @typing.overload
    def isRecursive(self, methodNode: org.codehaus.groovy.ast.MethodNode, methodCallExpression: org.codehaus.groovy.ast.expr.MethodCallExpression) -> bool: ...
    @typing.overload
    def isRecursive(self, methodNode: org.codehaus.groovy.ast.MethodNode, staticMethodCallExpression: org.codehaus.groovy.ast.expr.StaticMethodCallExpression) -> bool: ...

class ReturnAdderForClosures(org.codehaus.groovy.ast.CodeVisitorSupport, groovy.lang.GroovyObject):
    def __init__(self): ...
    def visitClosureExpression(self, closureExpression: org.codehaus.groovy.ast.expr.ClosureExpression) -> None: ...
    def visitMethod(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...

class ReturnStatementToIterationConverter(groovy.lang.GroovyObject):
    def __init__(self): ...
    def convert(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement, map: typing.Union[java.util.Map[int, typing.Union[java.util.Map, typing.Mapping]], typing.Mapping[int, typing.Union[java.util.Map, typing.Mapping]]]) -> org.codehaus.groovy.ast.stmt.Statement: ...
    def getRecurStatement(self) -> org.codehaus.groovy.ast.stmt.Statement: ...
    def setRecurStatement(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> None: ...

class StatementReplacer(org.codehaus.groovy.ast.CodeVisitorSupport, groovy.lang.GroovyObject):
    def __init__(self): ...
    def getClosureLevel(self) -> int: ...
    def getReplaceWith(self) -> groovy.lang.Closure[org.codehaus.groovy.ast.stmt.Statement]: ...
    def getWhen(self) -> groovy.lang.Closure[bool]: ...
    def replaceIn(self, aSTNode: org.codehaus.groovy.ast.ASTNode) -> None: ...
    def setClosureLevel(self, int: int) -> None: ...
    def setReplaceWith(self, closure: groovy.lang.Closure[org.codehaus.groovy.ast.stmt.Statement]) -> None: ...
    def setWhen(self, closure: groovy.lang.Closure[bool]) -> None: ...
    def visitBlockStatement(self, blockStatement: org.codehaus.groovy.ast.stmt.BlockStatement) -> None: ...
    def visitClosureExpression(self, closureExpression: org.codehaus.groovy.ast.expr.ClosureExpression) -> None: ...
    def visitDoWhileLoop(self, doWhileStatement: org.codehaus.groovy.ast.stmt.DoWhileStatement) -> None: ...
    def visitForLoop(self, forStatement: org.codehaus.groovy.ast.stmt.ForStatement) -> None: ...
    def visitIfElse(self, ifStatement: org.codehaus.groovy.ast.stmt.IfStatement) -> None: ...
    def visitWhileLoop(self, whileStatement: org.codehaus.groovy.ast.stmt.WhileStatement) -> None: ...
    class _closure1(groovy.lang.Closure, org.codehaus.groovy.runtime.GeneratedClosure):
        def __init__(self, object: typing.Any, object2: typing.Any): ...
        @typing.overload
        def call(self) -> typing.Any: ...
        @typing.overload
        def call(self, object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, *object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> typing.Any: ...
        def doCall(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> typing.Any: ...
    class _closure2(groovy.lang.Closure, org.codehaus.groovy.runtime.GeneratedClosure):
        def __init__(self, object: typing.Any, object2: typing.Any): ...
        @typing.overload
        def call(self) -> typing.Any: ...
        @typing.overload
        def call(self, object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, *object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> typing.Any: ...
        def doCall(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> typing.Any: ...

class TailRecursiveASTTransformation(org.codehaus.groovy.transform.AbstractASTTransformation, groovy.lang.GroovyObject):
    def __init__(self): ...
    @staticmethod
    def getMY_TYPE_NAME() -> str: ...
    def name2VariableMappingFor(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> java.util.Map[str, java.util.Map]: ...
    def position2VariableMappingFor(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> java.util.Map[int, java.util.Map]: ...
    def visit(self, aSTNodeArray: typing.Union[typing.List[org.codehaus.groovy.ast.ASTNode], jpype.JArray], sourceUnit: org.codehaus.groovy.control.SourceUnit) -> None: ...

class TernaryToIfStatementConverter(groovy.lang.GroovyObject):
    def __init__(self): ...
    def convert(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement) -> org.codehaus.groovy.ast.stmt.Statement: ...

class VariableAccessReplacer(groovy.lang.GroovyObject):
    def __init__(self): ...
    def getListener(self) -> 'VariableReplacedListener': ...
    def getNameAndTypeMapping(self) -> java.util.Map[str, java.util.Map]: ...
    def replaceIn(self, aSTNode: org.codehaus.groovy.ast.ASTNode) -> None: ...
    def setListener(self, variableReplacedListener: 'VariableReplacedListener') -> None: ...
    def setNameAndTypeMapping(self, map: typing.Union[java.util.Map[str, typing.Union[java.util.Map, typing.Mapping]], typing.Mapping[str, typing.Union[java.util.Map, typing.Mapping]]]) -> None: ...

class VariableExpressionReplacer(org.codehaus.groovy.ast.CodeVisitorSupport, groovy.lang.GroovyObject):
    def __init__(self): ...
    def getReplaceWith(self) -> groovy.lang.Closure[org.codehaus.groovy.ast.expr.VariableExpression]: ...
    def getWhen(self) -> groovy.lang.Closure[bool]: ...
    def replaceIn(self, aSTNode: org.codehaus.groovy.ast.ASTNode) -> None: ...
    def setReplaceWith(self, closure: groovy.lang.Closure[org.codehaus.groovy.ast.expr.VariableExpression]) -> None: ...
    def setWhen(self, closure: groovy.lang.Closure[bool]) -> None: ...
    def visitAssertStatement(self, assertStatement: org.codehaus.groovy.ast.stmt.AssertStatement) -> None: ...
    def visitBinaryExpression(self, binaryExpression: org.codehaus.groovy.ast.expr.BinaryExpression) -> None: ...
    def visitCaseStatement(self, caseStatement: org.codehaus.groovy.ast.stmt.CaseStatement) -> None: ...
    def visitDoWhileLoop(self, doWhileStatement: org.codehaus.groovy.ast.stmt.DoWhileStatement) -> None: ...
    def visitExpressionStatement(self, expressionStatement: org.codehaus.groovy.ast.stmt.ExpressionStatement) -> None: ...
    def visitForLoop(self, forStatement: org.codehaus.groovy.ast.stmt.ForStatement) -> None: ...
    def visitIfElse(self, ifStatement: org.codehaus.groovy.ast.stmt.IfStatement) -> None: ...
    def visitReturnStatement(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement) -> None: ...
    def visitSwitch(self, switchStatement: org.codehaus.groovy.ast.stmt.SwitchStatement) -> None: ...
    def visitSynchronizedStatement(self, synchronizedStatement: org.codehaus.groovy.ast.stmt.SynchronizedStatement) -> None: ...
    def visitThrowStatement(self, throwStatement: org.codehaus.groovy.ast.stmt.ThrowStatement) -> None: ...
    def visitWhileLoop(self, whileStatement: org.codehaus.groovy.ast.stmt.WhileStatement) -> None: ...
    class _closure1(groovy.lang.Closure, org.codehaus.groovy.runtime.GeneratedClosure):
        def __init__(self, object: typing.Any, object2: typing.Any): ...
        @typing.overload
        def call(self) -> typing.Any: ...
        @typing.overload
        def call(self, object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, *object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> typing.Any: ...
        def doCall(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> typing.Any: ...
    class _closure2(groovy.lang.Closure, org.codehaus.groovy.runtime.GeneratedClosure):
        def __init__(self, object: typing.Any, object2: typing.Any): ...
        @typing.overload
        def call(self) -> typing.Any: ...
        @typing.overload
        def call(self, object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, *object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> typing.Any: ...
        def doCall(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> typing.Any: ...

class VariableExpressionTransformer(org.codehaus.groovy.ast.expr.ExpressionTransformer, groovy.lang.GroovyObject):
    def __init__(self): ...
    def getReplaceWith(self) -> groovy.lang.Closure[org.codehaus.groovy.ast.expr.VariableExpression]: ...
    def getWhen(self) -> groovy.lang.Closure[bool]: ...
    def setReplaceWith(self, closure: groovy.lang.Closure[org.codehaus.groovy.ast.expr.VariableExpression]) -> None: ...
    def setWhen(self, closure: groovy.lang.Closure[bool]) -> None: ...
    def transform(self, expression: org.codehaus.groovy.ast.expr.Expression) -> org.codehaus.groovy.ast.expr.Expression: ...

class UsedVariableTracker(org.codehaus.groovy.transform.tailrec.VariableReplacedListener, groovy.lang.GroovyObject):
    def __init__(self): ...
    def getUsedVariableNames(self) -> java.util.Set[str]: ...
    def variableReplaced(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression, variableExpression2: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...

class VariableReplacedListener:
    NULL: typing.ClassVar['VariableReplacedListener'] = ...
    def variableReplaced(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression, variableExpression2: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...
    class 1(org.codehaus.groovy.transform.tailrec.VariableReplacedListener, groovy.lang.GroovyObject):
        this$0: typing.Type = ...
        def variableReplaced(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression, variableExpression2: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.transform.tailrec")``.

    AstHelper: typing.Type[AstHelper]
    CollectRecursiveCalls: typing.Type[CollectRecursiveCalls]
    GotoRecurHereException: typing.Type[GotoRecurHereException]
    HasRecursiveCalls: typing.Type[HasRecursiveCalls]
    InWhileLoopWrapper: typing.Type[InWhileLoopWrapper]
    RecursivenessTester: typing.Type[RecursivenessTester]
    ReturnAdderForClosures: typing.Type[ReturnAdderForClosures]
    ReturnStatementToIterationConverter: typing.Type[ReturnStatementToIterationConverter]
    StatementReplacer: typing.Type[StatementReplacer]
    TailRecursiveASTTransformation: typing.Type[TailRecursiveASTTransformation]
    TernaryToIfStatementConverter: typing.Type[TernaryToIfStatementConverter]
    UsedVariableTracker: typing.Type[UsedVariableTracker]
    VariableAccessReplacer: typing.Type[VariableAccessReplacer]
    VariableExpressionReplacer: typing.Type[VariableExpressionReplacer]
    VariableExpressionTransformer: typing.Type[VariableExpressionTransformer]
    VariableReplacedListener: typing.Type[VariableReplacedListener]
