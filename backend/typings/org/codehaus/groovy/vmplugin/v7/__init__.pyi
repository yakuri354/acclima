
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import java.lang
import java.lang.invoke
import java.lang.reflect
import java.util
import jpype
import org.codehaus.groovy.vmplugin.v6
import typing



class IndyArrayAccess:
    def __init__(self): ...
    @staticmethod
    def arrayGet(methodType: java.lang.invoke.MethodType) -> java.lang.invoke.MethodHandle: ...
    @staticmethod
    def arraySet(methodType: java.lang.invoke.MethodType) -> java.lang.invoke.MethodHandle: ...
    @staticmethod
    def notNegative(int: int) -> bool: ...

class IndyGuardsFiltersAndSignatures:
    def __init__(self): ...
    @staticmethod
    def invokeGroovyObjectInvoker(missingMethodException: groovy.lang.MissingMethodException, object: typing.Any, string: str, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.Any: ...
    @staticmethod
    def isNull(object: typing.Any) -> bool: ...
    @staticmethod
    def isSameMetaClass(metaClass: groovy.lang.MetaClass, object: typing.Any) -> bool: ...
    @staticmethod
    def sameClass(class_: typing.Type, object: typing.Any) -> bool: ...
    @staticmethod
    def setBeanProperties(metaClass: groovy.lang.MetaClass, object: typing.Any, map: typing.Union[java.util.Map, typing.Mapping]) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def unwrap(groovyRuntimeException: groovy.lang.GroovyRuntimeException) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def unwrap(object: typing.Any) -> typing.Any: ...

class IndyInterface:
    SAFE_NAVIGATION: typing.ClassVar[int] = ...
    THIS_CALL: typing.ClassVar[int] = ...
    GROOVY_OBJECT: typing.ClassVar[int] = ...
    IMPLICIT_THIS: typing.ClassVar[int] = ...
    SPREAD_CALL: typing.ClassVar[int] = ...
    UNCACHED_CALL: typing.ClassVar[int] = ...
    LOOKUP: typing.ClassVar[java.lang.invoke.MethodHandles.Lookup] = ...
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def bootstrap(lookup: java.lang.invoke.MethodHandles.Lookup, string: str, methodType: java.lang.invoke.MethodType) -> java.lang.invoke.CallSite: ...
    @typing.overload
    @staticmethod
    def bootstrap(lookup: java.lang.invoke.MethodHandles.Lookup, string: str, methodType: java.lang.invoke.MethodType, string2: str, int: int) -> java.lang.invoke.CallSite: ...
    @staticmethod
    def bootstrapCurrent(lookup: java.lang.invoke.MethodHandles.Lookup, string: str, methodType: java.lang.invoke.MethodType) -> java.lang.invoke.CallSite: ...
    @staticmethod
    def bootstrapCurrentSafe(lookup: java.lang.invoke.MethodHandles.Lookup, string: str, methodType: java.lang.invoke.MethodType) -> java.lang.invoke.CallSite: ...
    @staticmethod
    def bootstrapSafe(lookup: java.lang.invoke.MethodHandles.Lookup, string: str, methodType: java.lang.invoke.MethodType) -> java.lang.invoke.CallSite: ...
    @staticmethod
    def selectMethod(mutableCallSite: java.lang.invoke.MutableCallSite, class_: typing.Type, string: str, int: int, boolean: bool, boolean2: bool, boolean3: bool, object: typing.Any, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.Any: ...
    @staticmethod
    def staticArrayAccess(lookup: java.lang.invoke.MethodHandles.Lookup, string: str, methodType: java.lang.invoke.MethodType) -> java.lang.invoke.CallSite: ...
    class CALL_TYPES(java.lang.Enum['IndyInterface.CALL_TYPES']):
        METHOD: typing.ClassVar['IndyInterface.CALL_TYPES'] = ...
        INIT: typing.ClassVar['IndyInterface.CALL_TYPES'] = ...
        GET: typing.ClassVar['IndyInterface.CALL_TYPES'] = ...
        SET: typing.ClassVar['IndyInterface.CALL_TYPES'] = ...
        CAST: typing.ClassVar['IndyInterface.CALL_TYPES'] = ...
        def getCallSiteName(self) -> str: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'IndyInterface.CALL_TYPES': ...
        @staticmethod
        def values() -> typing.MutableSequence['IndyInterface.CALL_TYPES']: ...

class IndyMath:
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def and_(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def and_(long: int, long2: int) -> int: ...
    @staticmethod
    def chooseMathMethod(selector: 'Selector', metaMethod: groovy.lang.MetaMethod) -> bool: ...
    @staticmethod
    def div(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def leftShift(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def leftShift(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def minus(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def minus(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def minus(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def mod(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def mod(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def multiply(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def multiply(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def multiply(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def next(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def next(int: int) -> int: ...
    @typing.overload
    @staticmethod
    def next(long: int) -> int: ...
    @typing.overload
    @staticmethod
    def or_(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def or_(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def plus(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def plus(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def plus(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def previous(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def previous(int: int) -> int: ...
    @typing.overload
    @staticmethod
    def previous(long: int) -> int: ...
    @typing.overload
    @staticmethod
    def rightShift(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def rightShift(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def xor(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def xor(long: int, long2: int) -> int: ...

class Java7(org.codehaus.groovy.vmplugin.v6.Java6):
    def __init__(self): ...
    def getInvokeSpecialHandle(self, method: java.lang.reflect.Method, object: typing.Any) -> typing.Any: ...
    def getVersion(self) -> int: ...
    def invalidateCallSites(self) -> None: ...
    def invokeHandle(self, object: typing.Any, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.Any: ...

class Selector:
    args: typing.MutableSequence[typing.Any] = ...
    originalArguments: typing.MutableSequence[typing.Any] = ...
    method: groovy.lang.MetaMethod = ...
    targetType: java.lang.invoke.MethodType = ...
    currentType: java.lang.invoke.MethodType = ...
    name: str = ...
    handle: java.lang.invoke.MethodHandle = ...
    useMetaClass: bool = ...
    cache: bool = ...
    callSite: java.lang.invoke.MutableCallSite = ...
    sender: typing.Type = ...
    isVargs: bool = ...
    safeNavigation: bool = ...
    safeNavigationOrig: bool = ...
    spread: bool = ...
    skipSpreadCollector: bool = ...
    thisCall: bool = ...
    selectionBase: typing.Type = ...
    catchException: bool = ...
    callType: IndyInterface.CALL_TYPES = ...
    def __init__(self): ...
    def getCorrectedReceiver(self) -> typing.Any: ...
    @staticmethod
    def getSelector(mutableCallSite: java.lang.invoke.MutableCallSite, class_: typing.Type, string: str, int: int, boolean: bool, boolean2: bool, boolean3: bool, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> 'Selector': ...

class TypeHelper:
    def __init__(self): ...

class TypeTransformers:
    def __init__(self): ...
    @staticmethod
    def applyUnsharpFilter(methodHandle: java.lang.invoke.MethodHandle, int: int, methodHandle2: java.lang.invoke.MethodHandle) -> java.lang.invoke.MethodHandle: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.vmplugin.v7")``.

    IndyArrayAccess: typing.Type[IndyArrayAccess]
    IndyGuardsFiltersAndSignatures: typing.Type[IndyGuardsFiltersAndSignatures]
    IndyInterface: typing.Type[IndyInterface]
    IndyMath: typing.Type[IndyMath]
    Java7: typing.Type[Java7]
    Selector: typing.Type[Selector]
    TypeHelper: typing.Type[TypeHelper]
    TypeTransformers: typing.Type[TypeTransformers]
