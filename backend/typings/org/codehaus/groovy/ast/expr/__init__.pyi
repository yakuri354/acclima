
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import java.lang
import java.util
import jpype
import org.codehaus.groovy.ast
import org.codehaus.groovy.ast.stmt
import org.codehaus.groovy.syntax
import typing



class Expression(org.codehaus.groovy.ast.AnnotatedNode):
    def __init__(self): ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def setType(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def transformExpression(self, expressionTransformer: 'ExpressionTransformer') -> 'Expression': ...

class ExpressionTransformer:
    def transform(self, expression: Expression) -> Expression: ...

class MethodCall:
    def getArguments(self) -> Expression: ...
    def getMethodAsString(self) -> str: ...
    def getReceiver(self) -> org.codehaus.groovy.ast.ASTNode: ...
    def getText(self) -> str: ...

class ArrayExpression(Expression):
    @typing.overload
    def __init__(self, classNode: org.codehaus.groovy.ast.ClassNode, list: java.util.List[Expression]): ...
    @typing.overload
    def __init__(self, classNode: org.codehaus.groovy.ast.ClassNode, list: java.util.List[Expression], list2: java.util.List[Expression]): ...
    def addExpression(self, expression: Expression) -> None: ...
    def getElementType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def getExpression(self, int: int) -> Expression: ...
    def getExpressions(self) -> java.util.List[Expression]: ...
    def getSizeExpression(self) -> java.util.List[Expression]: ...
    def getText(self) -> str: ...
    def isDynamic(self) -> bool: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class BinaryExpression(Expression):
    def __init__(self, expression: Expression, token: org.codehaus.groovy.syntax.Token, expression2: Expression): ...
    def getLeftExpression(self) -> Expression: ...
    def getOperation(self) -> org.codehaus.groovy.syntax.Token: ...
    def getRightExpression(self) -> Expression: ...
    def getText(self) -> str: ...
    @staticmethod
    def newAssignmentExpression(variable: org.codehaus.groovy.ast.Variable, expression: Expression) -> 'BinaryExpression': ...
    @staticmethod
    def newInitializationExpression(string: str, classNode: org.codehaus.groovy.ast.ClassNode, expression: Expression) -> 'BinaryExpression': ...
    def setLeftExpression(self, expression: Expression) -> None: ...
    def setRightExpression(self, expression: Expression) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class BitwiseNegationExpression(Expression):
    def __init__(self, expression: Expression): ...
    def getExpression(self) -> Expression: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class BooleanExpression(Expression):
    def __init__(self, expression: Expression): ...
    def getExpression(self) -> Expression: ...
    def getText(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class CastExpression(Expression):
    @typing.overload
    def __init__(self, classNode: org.codehaus.groovy.ast.ClassNode, expression: Expression): ...
    @typing.overload
    def __init__(self, classNode: org.codehaus.groovy.ast.ClassNode, expression: Expression, boolean: bool): ...
    @staticmethod
    def asExpression(classNode: org.codehaus.groovy.ast.ClassNode, expression: Expression) -> 'CastExpression': ...
    def getExpression(self) -> Expression: ...
    def getText(self) -> str: ...
    def isCoerce(self) -> bool: ...
    def isIgnoringAutoboxing(self) -> bool: ...
    def isStrict(self) -> bool: ...
    def setCoerce(self, boolean: bool) -> None: ...
    def setStrict(self, boolean: bool) -> None: ...
    def setType(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class ClassExpression(Expression):
    def __init__(self, classNode: org.codehaus.groovy.ast.ClassNode): ...
    def getText(self) -> str: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class ClosureExpression(Expression):
    def __init__(self, parameterArray: typing.Union[typing.List[org.codehaus.groovy.ast.Parameter], jpype.JArray], statement: org.codehaus.groovy.ast.stmt.Statement): ...
    def getCode(self) -> org.codehaus.groovy.ast.stmt.Statement: ...
    def getParameters(self) -> typing.MutableSequence[org.codehaus.groovy.ast.Parameter]: ...
    def getText(self) -> str: ...
    def getVariableScope(self) -> org.codehaus.groovy.ast.VariableScope: ...
    def isParameterSpecified(self) -> bool: ...
    def setCode(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> None: ...
    def setVariableScope(self, variableScope: org.codehaus.groovy.ast.VariableScope) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class ConstantExpression(Expression):
    NULL: typing.ClassVar['ConstantExpression'] = ...
    TRUE: typing.ClassVar['ConstantExpression'] = ...
    FALSE: typing.ClassVar['ConstantExpression'] = ...
    EMPTY_STRING: typing.ClassVar['ConstantExpression'] = ...
    PRIM_TRUE: typing.ClassVar['ConstantExpression'] = ...
    PRIM_FALSE: typing.ClassVar['ConstantExpression'] = ...
    VOID: typing.ClassVar['ConstantExpression'] = ...
    EMPTY_EXPRESSION: typing.ClassVar['ConstantExpression'] = ...
    @typing.overload
    def __init__(self, object: typing.Any): ...
    @typing.overload
    def __init__(self, object: typing.Any, boolean: bool): ...
    def getConstantName(self) -> str: ...
    def getText(self) -> str: ...
    def getValue(self) -> typing.Any: ...
    def isEmptyStringExpression(self) -> bool: ...
    def isFalseExpression(self) -> bool: ...
    def isNullExpression(self) -> bool: ...
    def isTrueExpression(self) -> bool: ...
    def setConstantName(self, string: str) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class ConstructorCallExpression(Expression, MethodCall):
    def __init__(self, classNode: org.codehaus.groovy.ast.ClassNode, expression: Expression): ...
    def getArguments(self) -> Expression: ...
    def getMethodAsString(self) -> str: ...
    def getReceiver(self) -> org.codehaus.groovy.ast.ASTNode: ...
    def getText(self) -> str: ...
    def isSpecialCall(self) -> bool: ...
    def isSuperCall(self) -> bool: ...
    def isThisCall(self) -> bool: ...
    def isUsingAnonymousInnerClass(self) -> bool: ...
    def setUsingAnonymousInnerClass(self, boolean: bool) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class EmptyExpression(Expression):
    INSTANCE: typing.ClassVar['EmptyExpression'] = ...
    def __init__(self): ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class FieldExpression(Expression):
    def __init__(self, fieldNode: org.codehaus.groovy.ast.FieldNode): ...
    def getField(self) -> org.codehaus.groovy.ast.FieldNode: ...
    def getFieldName(self) -> str: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def isDynamicTyped(self) -> bool: ...
    def isUseReferenceDirectly(self) -> bool: ...
    def setType(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def setUseReferenceDirectly(self, boolean: bool) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class GStringExpression(Expression):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, list: java.util.List[ConstantExpression], list2: java.util.List[Expression]): ...
    def addString(self, constantExpression: ConstantExpression) -> None: ...
    def addValue(self, expression: Expression) -> None: ...
    def asConstantString(self) -> Expression: ...
    def getStrings(self) -> java.util.List[ConstantExpression]: ...
    def getText(self) -> str: ...
    def getValue(self, int: int) -> Expression: ...
    def getValues(self) -> java.util.List[Expression]: ...
    def isConstantString(self) -> bool: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class ListExpression(Expression):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, list: java.util.List[Expression]): ...
    def addExpression(self, expression: Expression) -> None: ...
    def getExpression(self, int: int) -> Expression: ...
    def getExpressions(self) -> java.util.List[Expression]: ...
    def getText(self) -> str: ...
    def isWrapped(self) -> bool: ...
    def setWrapped(self, boolean: bool) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class MapEntryExpression(Expression):
    def __init__(self, expression: Expression, expression2: Expression): ...
    def getKeyExpression(self) -> Expression: ...
    def getValueExpression(self) -> Expression: ...
    def setKeyExpression(self, expression: Expression) -> None: ...
    def setValueExpression(self, expression: Expression) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class MapExpression(Expression):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, list: java.util.List[MapEntryExpression]): ...
    @typing.overload
    def addMapEntryExpression(self, expression: Expression, expression2: Expression) -> None: ...
    @typing.overload
    def addMapEntryExpression(self, mapEntryExpression: MapEntryExpression) -> None: ...
    def getMapEntryExpressions(self) -> java.util.List[MapEntryExpression]: ...
    def getText(self) -> str: ...
    def isDynamic(self) -> bool: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class MethodCallExpression(Expression, MethodCall):
    NO_ARGUMENTS: typing.ClassVar[Expression] = ...
    @typing.overload
    def __init__(self, expression: Expression, string: str, expression2: Expression): ...
    @typing.overload
    def __init__(self, expression: Expression, expression2: Expression, expression3: Expression): ...
    def getArguments(self) -> Expression: ...
    def getGenericsTypes(self) -> typing.MutableSequence[org.codehaus.groovy.ast.GenericsType]: ...
    def getMethod(self) -> Expression: ...
    def getMethodAsString(self) -> str: ...
    def getMethodTarget(self) -> org.codehaus.groovy.ast.MethodNode: ...
    def getObjectExpression(self) -> Expression: ...
    def getReceiver(self) -> org.codehaus.groovy.ast.ASTNode: ...
    def getText(self) -> str: ...
    def isImplicitThis(self) -> bool: ...
    def isSafe(self) -> bool: ...
    def isSpreadSafe(self) -> bool: ...
    def isUsingGenerics(self) -> bool: ...
    def setArguments(self, expression: Expression) -> None: ...
    def setGenericsTypes(self, genericsTypeArray: typing.Union[typing.List[org.codehaus.groovy.ast.GenericsType], jpype.JArray]) -> None: ...
    def setImplicitThis(self, boolean: bool) -> None: ...
    def setMethod(self, expression: Expression) -> None: ...
    def setMethodTarget(self, methodNode: org.codehaus.groovy.ast.MethodNode) -> None: ...
    def setObjectExpression(self, expression: Expression) -> None: ...
    def setSafe(self, boolean: bool) -> None: ...
    def setSpreadSafe(self, boolean: bool) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class MethodPointerExpression(Expression):
    def __init__(self, expression: Expression, expression2: Expression): ...
    def getExpression(self) -> Expression: ...
    def getMethodName(self) -> Expression: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def getTypeClass(self) -> typing.Type: ...
    def isDynamic(self) -> bool: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class PostfixExpression(Expression):
    def __init__(self, expression: Expression, token: org.codehaus.groovy.syntax.Token): ...
    def getExpression(self) -> Expression: ...
    def getOperation(self) -> org.codehaus.groovy.syntax.Token: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def setExpression(self, expression: Expression) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class PrefixExpression(Expression):
    def __init__(self, token: org.codehaus.groovy.syntax.Token, expression: Expression): ...
    def getExpression(self) -> Expression: ...
    def getOperation(self) -> org.codehaus.groovy.syntax.Token: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def setExpression(self, expression: Expression) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class PropertyExpression(Expression):
    @typing.overload
    def __init__(self, expression: Expression, string: str): ...
    @typing.overload
    def __init__(self, expression: Expression, expression2: Expression): ...
    @typing.overload
    def __init__(self, expression: Expression, expression2: Expression, boolean: bool): ...
    def getObjectExpression(self) -> Expression: ...
    def getProperty(self) -> Expression: ...
    def getPropertyAsString(self) -> str: ...
    def getText(self) -> str: ...
    def isDynamic(self) -> bool: ...
    def isImplicitThis(self) -> bool: ...
    def isSafe(self) -> bool: ...
    def isSpreadSafe(self) -> bool: ...
    def isStatic(self) -> bool: ...
    def setImplicitThis(self, boolean: bool) -> None: ...
    def setObjectExpression(self, expression: Expression) -> None: ...
    def setSpreadSafe(self, boolean: bool) -> None: ...
    def setStatic(self, boolean: bool) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class RangeExpression(Expression):
    def __init__(self, expression: Expression, expression2: Expression, boolean: bool): ...
    def getFrom(self) -> Expression: ...
    def getText(self) -> str: ...
    def getTo(self) -> Expression: ...
    def isInclusive(self) -> bool: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class SpreadExpression(Expression):
    def __init__(self, expression: Expression): ...
    def getExpression(self) -> Expression: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class SpreadMapExpression(Expression):
    def __init__(self, expression: Expression): ...
    def getExpression(self) -> Expression: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class StaticMethodCallExpression(Expression, MethodCall):
    def __init__(self, classNode: org.codehaus.groovy.ast.ClassNode, string: str, expression: Expression): ...
    def getArguments(self) -> Expression: ...
    def getMetaMethod(self) -> groovy.lang.MetaMethod: ...
    def getMethod(self) -> str: ...
    def getMethodAsString(self) -> str: ...
    def getOwnerType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def getReceiver(self) -> org.codehaus.groovy.ast.ASTNode: ...
    def getText(self) -> str: ...
    def setMetaMethod(self, metaMethod: groovy.lang.MetaMethod) -> None: ...
    def setOwnerType(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class TernaryExpression(Expression):
    def __init__(self, booleanExpression: BooleanExpression, expression: Expression, expression2: Expression): ...
    def getBooleanExpression(self) -> BooleanExpression: ...
    def getFalseExpression(self) -> Expression: ...
    def getText(self) -> str: ...
    def getTrueExpression(self) -> Expression: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class TupleExpression(Expression, java.lang.Iterable[Expression]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, list: java.util.List[Expression]): ...
    @typing.overload
    def __init__(self, expression: Expression): ...
    @typing.overload
    def __init__(self, expression: Expression, expression2: Expression): ...
    @typing.overload
    def __init__(self, expression: Expression, expression2: Expression, expression3: Expression): ...
    @typing.overload
    def __init__(self, expressionArray: typing.Union[typing.List[Expression], jpype.JArray]): ...
    def addExpression(self, expression: Expression) -> 'TupleExpression': ...
    def getExpression(self, int: int) -> Expression: ...
    def getExpressions(self) -> java.util.List[Expression]: ...
    def getText(self) -> str: ...
    def iterator(self) -> java.util.Iterator[Expression]: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class UnaryMinusExpression(Expression):
    def __init__(self, expression: Expression): ...
    def getExpression(self) -> Expression: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def isDynamic(self) -> bool: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class UnaryPlusExpression(Expression):
    def __init__(self, expression: Expression): ...
    def getExpression(self) -> Expression: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def isDynamic(self) -> bool: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class VariableExpression(Expression, org.codehaus.groovy.ast.Variable):
    THIS_EXPRESSION: typing.ClassVar['VariableExpression'] = ...
    SUPER_EXPRESSION: typing.ClassVar['VariableExpression'] = ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, classNode: org.codehaus.groovy.ast.ClassNode): ...
    @typing.overload
    def __init__(self, variable: org.codehaus.groovy.ast.Variable): ...
    def getAccessedVariable(self) -> org.codehaus.groovy.ast.Variable: ...
    def getInitialExpression(self) -> Expression: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getOriginType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def getText(self) -> str: ...
    def getType(self) -> org.codehaus.groovy.ast.ClassNode: ...
    def hasInitialExpression(self) -> bool: ...
    def isClosureSharedVariable(self) -> bool: ...
    def isDynamicTyped(self) -> bool: ...
    def isInStaticContext(self) -> bool: ...
    def isSuperExpression(self) -> bool: ...
    def isThisExpression(self) -> bool: ...
    def isUseReferenceDirectly(self) -> bool: ...
    def setAccessedVariable(self, variable: org.codehaus.groovy.ast.Variable) -> None: ...
    def setClosureSharedVariable(self, boolean: bool) -> None: ...
    def setInStaticContext(self, boolean: bool) -> None: ...
    def setModifiers(self, int: int) -> None: ...
    def setType(self, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
    def setUseReferenceDirectly(self, boolean: bool) -> None: ...
    def toString(self) -> str: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class AnnotationConstantExpression(ConstantExpression):
    def __init__(self, annotationNode: org.codehaus.groovy.ast.AnnotationNode): ...
    def toString(self) -> str: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class ArgumentListExpression(TupleExpression):
    EMPTY_ARRAY: typing.ClassVar[typing.MutableSequence[typing.Any]] = ...
    EMPTY_ARGUMENTS: typing.ClassVar['ArgumentListExpression'] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, list: java.util.List[Expression]): ...
    @typing.overload
    def __init__(self, parameterArray: typing.Union[typing.List[org.codehaus.groovy.ast.Parameter], jpype.JArray]): ...
    @typing.overload
    def __init__(self, expression: Expression): ...
    @typing.overload
    def __init__(self, expression: Expression, expression2: Expression): ...
    @typing.overload
    def __init__(self, expression: Expression, expression2: Expression, expression3: Expression): ...
    @typing.overload
    def __init__(self, expressionArray: typing.Union[typing.List[Expression], jpype.JArray]): ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class AttributeExpression(PropertyExpression):
    @typing.overload
    def __init__(self, expression: Expression, expression2: Expression): ...
    @typing.overload
    def __init__(self, expression: Expression, expression2: Expression, boolean: bool): ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class ClosureListExpression(ListExpression):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, list: java.util.List[Expression]): ...
    def getText(self) -> str: ...
    def getVariableScope(self) -> org.codehaus.groovy.ast.VariableScope: ...
    def setVariableScope(self, variableScope: org.codehaus.groovy.ast.VariableScope) -> None: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class DeclarationExpression(BinaryExpression):
    @typing.overload
    def __init__(self, expression: Expression, token: org.codehaus.groovy.syntax.Token, expression2: Expression): ...
    @typing.overload
    def __init__(self, variableExpression: VariableExpression, token: org.codehaus.groovy.syntax.Token, expression: Expression): ...
    def getTupleExpression(self) -> TupleExpression: ...
    def getVariableExpression(self) -> VariableExpression: ...
    def isMultipleAssignmentDeclaration(self) -> bool: ...
    def setLeftExpression(self, expression: Expression) -> None: ...
    def setRightExpression(self, expression: Expression) -> None: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class ElvisOperatorExpression(TernaryExpression):
    def __init__(self, expression: Expression, expression2: Expression): ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...

class NamedArgumentListExpression(MapExpression):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, list: java.util.List[MapEntryExpression]): ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...

class NotExpression(BooleanExpression):
    def __init__(self, expression: Expression): ...
    def isDynamic(self) -> bool: ...
    def transformExpression(self, expressionTransformer: ExpressionTransformer) -> Expression: ...
    def visit(self, groovyCodeVisitor: org.codehaus.groovy.ast.GroovyCodeVisitor) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.ast.expr")``.

    AnnotationConstantExpression: typing.Type[AnnotationConstantExpression]
    ArgumentListExpression: typing.Type[ArgumentListExpression]
    ArrayExpression: typing.Type[ArrayExpression]
    AttributeExpression: typing.Type[AttributeExpression]
    BinaryExpression: typing.Type[BinaryExpression]
    BitwiseNegationExpression: typing.Type[BitwiseNegationExpression]
    BooleanExpression: typing.Type[BooleanExpression]
    CastExpression: typing.Type[CastExpression]
    ClassExpression: typing.Type[ClassExpression]
    ClosureExpression: typing.Type[ClosureExpression]
    ClosureListExpression: typing.Type[ClosureListExpression]
    ConstantExpression: typing.Type[ConstantExpression]
    ConstructorCallExpression: typing.Type[ConstructorCallExpression]
    DeclarationExpression: typing.Type[DeclarationExpression]
    ElvisOperatorExpression: typing.Type[ElvisOperatorExpression]
    EmptyExpression: typing.Type[EmptyExpression]
    Expression: typing.Type[Expression]
    ExpressionTransformer: typing.Type[ExpressionTransformer]
    FieldExpression: typing.Type[FieldExpression]
    GStringExpression: typing.Type[GStringExpression]
    ListExpression: typing.Type[ListExpression]
    MapEntryExpression: typing.Type[MapEntryExpression]
    MapExpression: typing.Type[MapExpression]
    MethodCall: typing.Type[MethodCall]
    MethodCallExpression: typing.Type[MethodCallExpression]
    MethodPointerExpression: typing.Type[MethodPointerExpression]
    NamedArgumentListExpression: typing.Type[NamedArgumentListExpression]
    NotExpression: typing.Type[NotExpression]
    PostfixExpression: typing.Type[PostfixExpression]
    PrefixExpression: typing.Type[PrefixExpression]
    PropertyExpression: typing.Type[PropertyExpression]
    RangeExpression: typing.Type[RangeExpression]
    SpreadExpression: typing.Type[SpreadExpression]
    SpreadMapExpression: typing.Type[SpreadMapExpression]
    StaticMethodCallExpression: typing.Type[StaticMethodCallExpression]
    TernaryExpression: typing.Type[TernaryExpression]
    TupleExpression: typing.Type[TupleExpression]
    UnaryMinusExpression: typing.Type[UnaryMinusExpression]
    UnaryPlusExpression: typing.Type[UnaryPlusExpression]
    VariableExpression: typing.Type[VariableExpression]
