
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import java.util
import org.codehaus.groovy.ast
import org.codehaus.groovy.control
import org.codehaus.groovy.runtime
import typing



class AstBuilder(groovy.lang.GroovyObject):
    def __init__(self): ...
    @typing.overload
    def buildFromCode(self, closure: groovy.lang.Closure) -> java.util.List[org.codehaus.groovy.ast.ASTNode]: ...
    @typing.overload
    def buildFromCode(self, compilePhase: org.codehaus.groovy.control.CompilePhase, boolean: bool, closure: groovy.lang.Closure) -> java.util.List[org.codehaus.groovy.ast.ASTNode]: ...
    @typing.overload
    def buildFromCode(self, compilePhase: org.codehaus.groovy.control.CompilePhase, closure: groovy.lang.Closure) -> java.util.List[org.codehaus.groovy.ast.ASTNode]: ...
    def buildFromSpec(self, closure: groovy.lang.Closure) -> java.util.List[org.codehaus.groovy.ast.ASTNode]: ...
    @typing.overload
    def buildFromString(self, string: str) -> java.util.List[org.codehaus.groovy.ast.ASTNode]: ...
    @typing.overload
    def buildFromString(self, compilePhase: org.codehaus.groovy.control.CompilePhase, boolean: bool, string: str) -> java.util.List[org.codehaus.groovy.ast.ASTNode]: ...
    @typing.overload
    def buildFromString(self, compilePhase: org.codehaus.groovy.control.CompilePhase, string: str) -> java.util.List[org.codehaus.groovy.ast.ASTNode]: ...

class AstBuilderTransformation(org.codehaus.groovy.ast.MethodCallTransformation):
    def __init__(self): ...

class AstSpecificationCompiler(groovy.lang.GroovyInterceptable):
    def __init__(self, closure: groovy.lang.Closure): ...
    @typing.overload
    def annotation(self, class_: typing.Type) -> None: ...
    @typing.overload
    def annotation(self, class_: typing.Type, closure: groovy.lang.Closure) -> None: ...
    def annotationConstant(self, closure: groovy.lang.Closure) -> None: ...
    def annotations(self, closure: groovy.lang.Closure) -> None: ...
    def argumentList(self, closure: groovy.lang.Closure) -> None: ...
    def array(self, class_: typing.Type, closure: groovy.lang.Closure) -> None: ...
    def assertStatement(self, closure: groovy.lang.Closure) -> None: ...
    def attribute(self, closure: groovy.lang.Closure) -> None: ...
    def binary(self, closure: groovy.lang.Closure) -> None: ...
    def bitwiseNegation(self, closure: groovy.lang.Closure) -> None: ...
    def block(self, closure: groovy.lang.Closure) -> None: ...
    def booleanExpression(self, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def breakStatement(self) -> None: ...
    @typing.overload
    def breakStatement(self, string: str) -> None: ...
    def caseStatement(self, closure: groovy.lang.Closure) -> None: ...
    def cast(self, class_: typing.Type, closure: groovy.lang.Closure) -> None: ...
    def catchStatement(self, closure: groovy.lang.Closure) -> None: ...
    def classExpression(self, class_: typing.Type) -> None: ...
    @typing.overload
    def classNode(self, class_: typing.Type) -> None: ...
    @typing.overload
    def classNode(self, string: str, int: int, closure: groovy.lang.Closure) -> None: ...
    def closure(self, closure: groovy.lang.Closure) -> None: ...
    def closureList(self, closure: groovy.lang.Closure) -> None: ...
    def constant(self, object: typing.Any) -> None: ...
    def constructor(self, int: int, closure: groovy.lang.Closure) -> None: ...
    def constructorCall(self, class_: typing.Type, closure: groovy.lang.Closure) -> None: ...
    def constructors(self, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def continueStatement(self) -> None: ...
    @typing.overload
    def continueStatement(self, closure: groovy.lang.Closure) -> None: ...
    def declaration(self, closure: groovy.lang.Closure) -> None: ...
    def defaultCase(self, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def dynamicVariable(self, string: str) -> None: ...
    @typing.overload
    def dynamicVariable(self, string: str, boolean: bool) -> None: ...
    def elvisOperator(self, closure: groovy.lang.Closure) -> None: ...
    def empty(self) -> None: ...
    def exceptions(self, closure: groovy.lang.Closure) -> None: ...
    def expression(self, closure: groovy.lang.Closure) -> None: ...
    def field(self, closure: groovy.lang.Closure) -> None: ...
    def fieldNode(self, string: str, int: int, class_: typing.Type, class2: typing.Type, closure: groovy.lang.Closure) -> None: ...
    def fields(self, closure: groovy.lang.Closure) -> None: ...
    def forStatement(self, closure: groovy.lang.Closure) -> None: ...
    def gString(self, string: str, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def genericsType(self, class_: typing.Type) -> None: ...
    @typing.overload
    def genericsType(self, class_: typing.Type, closure: groovy.lang.Closure) -> None: ...
    def genericsTypes(self, closure: groovy.lang.Closure) -> None: ...
    def getExpression(self) -> java.util.List[org.codehaus.groovy.ast.ASTNode]: ...
    def ifStatement(self, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def importNode(self, class_: typing.Type) -> None: ...
    @typing.overload
    def importNode(self, class_: typing.Type, string: str) -> None: ...
    def inclusive(self, boolean: bool) -> None: ...
    def innerClass(self, string: str, int: int, closure: groovy.lang.Closure) -> None: ...
    def interfaces(self, closure: groovy.lang.Closure) -> None: ...
    def label(self, string: str) -> None: ...
    def list(self, closure: groovy.lang.Closure) -> None: ...
    def lowerBound(self, class_: typing.Type) -> None: ...
    def map(self, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def mapEntry(self, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def mapEntry(self, map: typing.Union[java.util.Map, typing.Mapping]) -> None: ...
    def member(self, string: str, closure: groovy.lang.Closure) -> None: ...
    def method(self, string: str, int: int, class_: typing.Type, closure: groovy.lang.Closure) -> None: ...
    def methodCall(self, closure: groovy.lang.Closure) -> None: ...
    def methodPointer(self, closure: groovy.lang.Closure) -> None: ...
    def methods(self, closure: groovy.lang.Closure) -> None: ...
    def mixin(self, string: str, int: int, closure: groovy.lang.Closure) -> None: ...
    def mixins(self, closure: groovy.lang.Closure) -> None: ...
    def namedArgumentList(self, closure: groovy.lang.Closure) -> None: ...
    def not_(self, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def parameter(self, map: typing.Union[java.util.Map[str, typing.Type], typing.Mapping[str, typing.Type]]) -> None: ...
    @typing.overload
    def parameter(self, map: typing.Union[java.util.Map[str, typing.Type], typing.Mapping[str, typing.Type]], closure: groovy.lang.Closure) -> None: ...
    def parameters(self, closure: groovy.lang.Closure) -> None: ...
    def postfix(self, closure: groovy.lang.Closure) -> None: ...
    def prefix(self, closure: groovy.lang.Closure) -> None: ...
    def properties(self, closure: groovy.lang.Closure) -> None: ...
    def property(self, closure: groovy.lang.Closure) -> None: ...
    def propertyNode(self, string: str, int: int, class_: typing.Type, class2: typing.Type, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def range(self, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def range(self, range: groovy.lang.Range) -> None: ...
    def returnStatement(self, closure: groovy.lang.Closure) -> None: ...
    def spread(self, closure: groovy.lang.Closure) -> None: ...
    def spreadMap(self, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def staticMethodCall(self, class_: typing.Type, string: str, closure: groovy.lang.Closure) -> None: ...
    @typing.overload
    def staticMethodCall(self, methodClosure: org.codehaus.groovy.runtime.MethodClosure, closure: groovy.lang.Closure) -> None: ...
    def strings(self, closure: groovy.lang.Closure) -> None: ...
    def switchStatement(self, closure: groovy.lang.Closure) -> None: ...
    def synchronizedStatement(self, closure: groovy.lang.Closure) -> None: ...
    def throwStatement(self, closure: groovy.lang.Closure) -> None: ...
    def token(self, string: str) -> None: ...
    def tryCatch(self, closure: groovy.lang.Closure) -> None: ...
    def tuple(self, closure: groovy.lang.Closure) -> None: ...
    def unaryMinus(self, closure: groovy.lang.Closure) -> None: ...
    def unaryPlus(self, closure: groovy.lang.Closure) -> None: ...
    def upperBound(self, closure: groovy.lang.Closure) -> None: ...
    def values(self, closure: groovy.lang.Closure) -> None: ...
    def variable(self, string: str) -> None: ...
    def whileStatement(self, closure: groovy.lang.Closure) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.ast.builder")``.

    AstBuilder: typing.Type[AstBuilder]
    AstBuilderTransformation: typing.Type[AstBuilderTransformation]
    AstSpecificationCompiler: typing.Type[AstSpecificationCompiler]
