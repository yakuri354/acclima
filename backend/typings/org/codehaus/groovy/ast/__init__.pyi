
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import groovyjarjarasm.asm
import java.security
import java.util
import jpype
import org.codehaus.groovy.ast.builder
import org.codehaus.groovy.ast.decompiled
import org.codehaus.groovy.ast.expr
import org.codehaus.groovy.ast.stmt
import org.codehaus.groovy.ast.tools
import org.codehaus.groovy.classgen
import org.codehaus.groovy.control
import org.codehaus.groovy.control.io
import org.codehaus.groovy.transform
import org.codehaus.groovy.util
import typing



class ASTNode:
    def __init__(self): ...
    def copyNodeMetaData(self, aSTNode: 'ASTNode') -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getColumnNumber(self) -> int: ...
    def getLastColumnNumber(self) -> int: ...
    def getLastLineNumber(self) -> int: ...
    def getLineNumber(self) -> int: ...
    def getMetaDataMap(self) -> org.codehaus.groovy.util.ListHashMap: ...
    _getNodeMetaData_0__T = typing.TypeVar('_getNodeMetaData_0__T')  # <T>
    @typing.overload
    def getNodeMetaData(self, object: typing.Any) -> _getNodeMetaData_0__T: ...
    @typing.overload
    def getNodeMetaData(self) -> java.util.Map[typing.Any, typing.Any]: ...
    def getText(self) -> str: ...
    def hashCode(self) -> int: ...
    def putNodeMetaData(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    def removeNodeMetaData(self, object: typing.Any) -> None: ...
    def setColumnNumber(self, int: int) -> None: ...
    def setLastColumnNumber(self, int: int) -> None: ...
    def setLastLineNumber(self, int: int) -> None: ...
    def setLineNumber(self, int: int) -> None: ...
    def setNodeMetaData(self, object: typing.Any, object2: typing.Any) -> None: ...
    def setSourcePosition(self, aSTNode: 'ASTNode') -> None: ...
    def visit(self, groovyCodeVisitor: 'GroovyCodeVisitor') -> None: ...

class AstToTextHelper:
    def __init__(self): ...
    @staticmethod
    def getClassText(classNode: 'ClassNode') -> str: ...
    @staticmethod
    def getModifiersText(int: int) -> str: ...
    @staticmethod
    def getParameterText(parameter: 'Parameter') -> str: ...
    @staticmethod
    def getParametersText(parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray]) -> str: ...
    @staticmethod
    def getThrowsClauseText(classNodeArray: typing.Union[typing.List['ClassNode'], jpype.JArray]) -> str: ...

class ClassHelper:
    DYNAMIC_TYPE: typing.ClassVar['ClassNode'] = ...
    OBJECT_TYPE: typing.ClassVar['ClassNode'] = ...
    VOID_TYPE: typing.ClassVar['ClassNode'] = ...
    CLOSURE_TYPE: typing.ClassVar['ClassNode'] = ...
    GSTRING_TYPE: typing.ClassVar['ClassNode'] = ...
    LIST_TYPE: typing.ClassVar['ClassNode'] = ...
    MAP_TYPE: typing.ClassVar['ClassNode'] = ...
    RANGE_TYPE: typing.ClassVar['ClassNode'] = ...
    PATTERN_TYPE: typing.ClassVar['ClassNode'] = ...
    STRING_TYPE: typing.ClassVar['ClassNode'] = ...
    SCRIPT_TYPE: typing.ClassVar['ClassNode'] = ...
    REFERENCE_TYPE: typing.ClassVar['ClassNode'] = ...
    BINDING_TYPE: typing.ClassVar['ClassNode'] = ...
    boolean_TYPE: typing.ClassVar['ClassNode'] = ...
    char_TYPE: typing.ClassVar['ClassNode'] = ...
    byte_TYPE: typing.ClassVar['ClassNode'] = ...
    int_TYPE: typing.ClassVar['ClassNode'] = ...
    long_TYPE: typing.ClassVar['ClassNode'] = ...
    short_TYPE: typing.ClassVar['ClassNode'] = ...
    double_TYPE: typing.ClassVar['ClassNode'] = ...
    float_TYPE: typing.ClassVar['ClassNode'] = ...
    Byte_TYPE: typing.ClassVar['ClassNode'] = ...
    Short_TYPE: typing.ClassVar['ClassNode'] = ...
    Integer_TYPE: typing.ClassVar['ClassNode'] = ...
    Long_TYPE: typing.ClassVar['ClassNode'] = ...
    Character_TYPE: typing.ClassVar['ClassNode'] = ...
    Float_TYPE: typing.ClassVar['ClassNode'] = ...
    Double_TYPE: typing.ClassVar['ClassNode'] = ...
    Boolean_TYPE: typing.ClassVar['ClassNode'] = ...
    BigInteger_TYPE: typing.ClassVar['ClassNode'] = ...
    BigDecimal_TYPE: typing.ClassVar['ClassNode'] = ...
    Number_TYPE: typing.ClassVar['ClassNode'] = ...
    void_WRAPPER_TYPE: typing.ClassVar['ClassNode'] = ...
    METACLASS_TYPE: typing.ClassVar['ClassNode'] = ...
    Iterator_TYPE: typing.ClassVar['ClassNode'] = ...
    Enum_Type: typing.ClassVar['ClassNode'] = ...
    Annotation_TYPE: typing.ClassVar['ClassNode'] = ...
    ELEMENT_TYPE_TYPE: typing.ClassVar['ClassNode'] = ...
    CLASS_Type: typing.ClassVar['ClassNode'] = ...
    COMPARABLE_TYPE: typing.ClassVar['ClassNode'] = ...
    GENERATED_CLOSURE_Type: typing.ClassVar['ClassNode'] = ...
    GROOVY_OBJECT_SUPPORT_TYPE: typing.ClassVar['ClassNode'] = ...
    GROOVY_OBJECT_TYPE: typing.ClassVar['ClassNode'] = ...
    GROOVY_INTERCEPTABLE_TYPE: typing.ClassVar['ClassNode'] = ...
    OBJECT: typing.ClassVar[str] = ...
    def __init__(self): ...
    @staticmethod
    def findSAM(classNode: 'ClassNode') -> 'MethodNode': ...
    @staticmethod
    def getNextSuperClass(classNode: 'ClassNode', classNode2: 'ClassNode') -> 'ClassNode': ...
    @staticmethod
    def getUnwrapper(classNode: 'ClassNode') -> 'ClassNode': ...
    @staticmethod
    def getWrapper(classNode: 'ClassNode') -> 'ClassNode': ...
    @staticmethod
    def isCachedType(classNode: 'ClassNode') -> bool: ...
    @staticmethod
    def isNumberType(classNode: 'ClassNode') -> bool: ...
    @staticmethod
    def isPrimitiveType(classNode: 'ClassNode') -> bool: ...
    @staticmethod
    def isSAMType(classNode: 'ClassNode') -> bool: ...
    @staticmethod
    def isStaticConstantInitializerType(classNode: 'ClassNode') -> bool: ...
    @typing.overload
    @staticmethod
    def make(class_: typing.Type) -> 'ClassNode': ...
    @typing.overload
    @staticmethod
    def make(class_: typing.Type, boolean: bool) -> 'ClassNode': ...
    @typing.overload
    @staticmethod
    def make(string: str) -> 'ClassNode': ...
    @typing.overload
    @staticmethod
    def make(classArray: typing.Union[typing.List[typing.Type], jpype.JArray]) -> typing.MutableSequence['ClassNode']: ...
    @staticmethod
    def makeCached(class_: typing.Type) -> 'ClassNode': ...
    @staticmethod
    def makeReference() -> 'ClassNode': ...
    @typing.overload
    @staticmethod
    def makeWithoutCaching(class_: typing.Type) -> 'ClassNode': ...
    @typing.overload
    @staticmethod
    def makeWithoutCaching(class_: typing.Type, boolean: bool) -> 'ClassNode': ...
    @typing.overload
    @staticmethod
    def makeWithoutCaching(string: str) -> 'ClassNode': ...

class CompileUnit:
    @typing.overload
    def __init__(self, groovyClassLoader: groovy.lang.GroovyClassLoader, codeSource: java.security.CodeSource, compilerConfiguration: org.codehaus.groovy.control.CompilerConfiguration): ...
    @typing.overload
    def __init__(self, groovyClassLoader: groovy.lang.GroovyClassLoader, compilerConfiguration: org.codehaus.groovy.control.CompilerConfiguration): ...
    def addClass(self, classNode: 'ClassNode') -> None: ...
    def addClassNodeToCompile(self, classNode: 'ClassNode', sourceUnit: org.codehaus.groovy.control.SourceUnit) -> None: ...
    def addGeneratedInnerClass(self, innerClassNode: 'InnerClassNode') -> None: ...
    def addModule(self, moduleNode: 'ModuleNode') -> None: ...
    @typing.overload
    def getClass(self) -> typing.Type[typing.Any]: ...
    @typing.overload
    def getClass(self, string: str) -> 'ClassNode': ...
    def getClassLoader(self) -> groovy.lang.GroovyClassLoader: ...
    def getClasses(self) -> java.util.List: ...
    def getCodeSource(self) -> java.security.CodeSource: ...
    def getConfig(self) -> org.codehaus.groovy.control.CompilerConfiguration: ...
    def getGeneratedInnerClass(self, string: str) -> 'InnerClassNode': ...
    def getGeneratedInnerClasses(self) -> java.util.Map[str, 'InnerClassNode']: ...
    def getMetaDataMap(self) -> org.codehaus.groovy.util.ListHashMap: ...
    def getModules(self) -> java.util.List['ModuleNode']: ...
    _getNodeMetaData_0__T = typing.TypeVar('_getNodeMetaData_0__T')  # <T>
    @typing.overload
    def getNodeMetaData(self, object: typing.Any) -> _getNodeMetaData_0__T: ...
    @typing.overload
    def getNodeMetaData(self) -> java.util.Map[typing.Any, typing.Any]: ...
    def getScriptSourceLocation(self, string: str) -> org.codehaus.groovy.control.SourceUnit: ...
    def hasClassNodeToCompile(self) -> bool: ...
    def iterateClassNodeToCompile(self) -> java.util.Iterator[str]: ...
    def putNodeMetaData(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    def removeNodeMetaData(self, object: typing.Any) -> None: ...
    def setNodeMetaData(self, object: typing.Any, object2: typing.Any) -> None: ...

class GroovyClassVisitor:
    def visitClass(self, classNode: 'ClassNode') -> None: ...
    def visitConstructor(self, constructorNode: 'ConstructorNode') -> None: ...
    def visitField(self, fieldNode: 'FieldNode') -> None: ...
    def visitMethod(self, methodNode: 'MethodNode') -> None: ...
    def visitProperty(self, propertyNode: 'PropertyNode') -> None: ...

class GroovyCodeVisitor:
    def visitArgumentlistExpression(self, argumentListExpression: org.codehaus.groovy.ast.expr.ArgumentListExpression) -> None: ...
    def visitArrayExpression(self, arrayExpression: org.codehaus.groovy.ast.expr.ArrayExpression) -> None: ...
    def visitAssertStatement(self, assertStatement: org.codehaus.groovy.ast.stmt.AssertStatement) -> None: ...
    def visitAttributeExpression(self, attributeExpression: org.codehaus.groovy.ast.expr.AttributeExpression) -> None: ...
    def visitBinaryExpression(self, binaryExpression: org.codehaus.groovy.ast.expr.BinaryExpression) -> None: ...
    def visitBitwiseNegationExpression(self, bitwiseNegationExpression: org.codehaus.groovy.ast.expr.BitwiseNegationExpression) -> None: ...
    def visitBlockStatement(self, blockStatement: org.codehaus.groovy.ast.stmt.BlockStatement) -> None: ...
    def visitBooleanExpression(self, booleanExpression: org.codehaus.groovy.ast.expr.BooleanExpression) -> None: ...
    def visitBreakStatement(self, breakStatement: org.codehaus.groovy.ast.stmt.BreakStatement) -> None: ...
    def visitBytecodeExpression(self, bytecodeExpression: org.codehaus.groovy.classgen.BytecodeExpression) -> None: ...
    def visitCaseStatement(self, caseStatement: org.codehaus.groovy.ast.stmt.CaseStatement) -> None: ...
    def visitCastExpression(self, castExpression: org.codehaus.groovy.ast.expr.CastExpression) -> None: ...
    def visitCatchStatement(self, catchStatement: org.codehaus.groovy.ast.stmt.CatchStatement) -> None: ...
    def visitClassExpression(self, classExpression: org.codehaus.groovy.ast.expr.ClassExpression) -> None: ...
    def visitClosureExpression(self, closureExpression: org.codehaus.groovy.ast.expr.ClosureExpression) -> None: ...
    def visitClosureListExpression(self, closureListExpression: org.codehaus.groovy.ast.expr.ClosureListExpression) -> None: ...
    def visitConstantExpression(self, constantExpression: org.codehaus.groovy.ast.expr.ConstantExpression) -> None: ...
    def visitConstructorCallExpression(self, constructorCallExpression: org.codehaus.groovy.ast.expr.ConstructorCallExpression) -> None: ...
    def visitContinueStatement(self, continueStatement: org.codehaus.groovy.ast.stmt.ContinueStatement) -> None: ...
    def visitDeclarationExpression(self, declarationExpression: org.codehaus.groovy.ast.expr.DeclarationExpression) -> None: ...
    def visitDoWhileLoop(self, doWhileStatement: org.codehaus.groovy.ast.stmt.DoWhileStatement) -> None: ...
    def visitExpressionStatement(self, expressionStatement: org.codehaus.groovy.ast.stmt.ExpressionStatement) -> None: ...
    def visitFieldExpression(self, fieldExpression: org.codehaus.groovy.ast.expr.FieldExpression) -> None: ...
    def visitForLoop(self, forStatement: org.codehaus.groovy.ast.stmt.ForStatement) -> None: ...
    def visitGStringExpression(self, gStringExpression: org.codehaus.groovy.ast.expr.GStringExpression) -> None: ...
    def visitIfElse(self, ifStatement: org.codehaus.groovy.ast.stmt.IfStatement) -> None: ...
    def visitListExpression(self, listExpression: org.codehaus.groovy.ast.expr.ListExpression) -> None: ...
    def visitMapEntryExpression(self, mapEntryExpression: org.codehaus.groovy.ast.expr.MapEntryExpression) -> None: ...
    def visitMapExpression(self, mapExpression: org.codehaus.groovy.ast.expr.MapExpression) -> None: ...
    def visitMethodCallExpression(self, methodCallExpression: org.codehaus.groovy.ast.expr.MethodCallExpression) -> None: ...
    def visitMethodPointerExpression(self, methodPointerExpression: org.codehaus.groovy.ast.expr.MethodPointerExpression) -> None: ...
    def visitNotExpression(self, notExpression: org.codehaus.groovy.ast.expr.NotExpression) -> None: ...
    def visitPostfixExpression(self, postfixExpression: org.codehaus.groovy.ast.expr.PostfixExpression) -> None: ...
    def visitPrefixExpression(self, prefixExpression: org.codehaus.groovy.ast.expr.PrefixExpression) -> None: ...
    def visitPropertyExpression(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression) -> None: ...
    def visitRangeExpression(self, rangeExpression: org.codehaus.groovy.ast.expr.RangeExpression) -> None: ...
    def visitReturnStatement(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement) -> None: ...
    def visitShortTernaryExpression(self, elvisOperatorExpression: org.codehaus.groovy.ast.expr.ElvisOperatorExpression) -> None: ...
    def visitSpreadExpression(self, spreadExpression: org.codehaus.groovy.ast.expr.SpreadExpression) -> None: ...
    def visitSpreadMapExpression(self, spreadMapExpression: org.codehaus.groovy.ast.expr.SpreadMapExpression) -> None: ...
    def visitStaticMethodCallExpression(self, staticMethodCallExpression: org.codehaus.groovy.ast.expr.StaticMethodCallExpression) -> None: ...
    def visitSwitch(self, switchStatement: org.codehaus.groovy.ast.stmt.SwitchStatement) -> None: ...
    def visitSynchronizedStatement(self, synchronizedStatement: org.codehaus.groovy.ast.stmt.SynchronizedStatement) -> None: ...
    def visitTernaryExpression(self, ternaryExpression: org.codehaus.groovy.ast.expr.TernaryExpression) -> None: ...
    def visitThrowStatement(self, throwStatement: org.codehaus.groovy.ast.stmt.ThrowStatement) -> None: ...
    def visitTryCatchFinally(self, tryCatchStatement: org.codehaus.groovy.ast.stmt.TryCatchStatement) -> None: ...
    def visitTupleExpression(self, tupleExpression: org.codehaus.groovy.ast.expr.TupleExpression) -> None: ...
    def visitUnaryMinusExpression(self, unaryMinusExpression: org.codehaus.groovy.ast.expr.UnaryMinusExpression) -> None: ...
    def visitUnaryPlusExpression(self, unaryPlusExpression: org.codehaus.groovy.ast.expr.UnaryPlusExpression) -> None: ...
    def visitVariableExpression(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...
    def visitWhileLoop(self, whileStatement: org.codehaus.groovy.ast.stmt.WhileStatement) -> None: ...

class MethodCallTransformation(org.codehaus.groovy.transform.ASTTransformation):
    def __init__(self): ...
    def visit(self, aSTNodeArray: typing.Union[typing.List[ASTNode], jpype.JArray], sourceUnit: org.codehaus.groovy.control.SourceUnit) -> None: ...

class MixinASTTransformation(org.codehaus.groovy.transform.AbstractASTTransformation):
    def __init__(self): ...
    def visit(self, aSTNodeArray: typing.Union[typing.List[ASTNode], jpype.JArray], sourceUnit: org.codehaus.groovy.control.SourceUnit) -> None: ...

class Variable:
    def getInitialExpression(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getOriginType(self) -> 'ClassNode': ...
    def getType(self) -> 'ClassNode': ...
    def hasInitialExpression(self) -> bool: ...
    def isClosureSharedVariable(self) -> bool: ...
    def isDynamicTyped(self) -> bool: ...
    def isInStaticContext(self) -> bool: ...
    def setClosureSharedVariable(self, boolean: bool) -> None: ...

class VariableScope:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, variableScope: 'VariableScope'): ...
    def copy(self) -> 'VariableScope': ...
    def getClassScope(self) -> 'ClassNode': ...
    def getDeclaredVariable(self, string: str) -> Variable: ...
    def getDeclaredVariables(self) -> java.util.Map[str, Variable]: ...
    def getDeclaredVariablesIterator(self) -> java.util.Iterator[Variable]: ...
    def getParent(self) -> 'VariableScope': ...
    def getReferencedClassVariable(self, string: str) -> Variable: ...
    def getReferencedClassVariables(self) -> java.util.Map[str, Variable]: ...
    def getReferencedClassVariablesIterator(self) -> java.util.Iterator[Variable]: ...
    def getReferencedLocalVariable(self, string: str) -> Variable: ...
    def getReferencedLocalVariablesCount(self) -> int: ...
    def getReferencedLocalVariablesIterator(self) -> java.util.Iterator[Variable]: ...
    def isClassScope(self) -> bool: ...
    def isInStaticContext(self) -> bool: ...
    def isReferencedClassVariable(self, string: str) -> bool: ...
    def isReferencedLocalVariable(self, string: str) -> bool: ...
    def isRoot(self) -> bool: ...
    def putDeclaredVariable(self, variable: Variable) -> None: ...
    def putReferencedClassVariable(self, variable: Variable) -> None: ...
    def putReferencedLocalVariable(self, variable: Variable) -> None: ...
    def removeReferencedClassVariable(self, string: str) -> typing.Any: ...
    def setClassScope(self, classNode: 'ClassNode') -> None: ...
    def setInStaticContext(self, boolean: bool) -> None: ...

class AnnotatedNode(ASTNode):
    def __init__(self): ...
    def addAnnotation(self, annotationNode: 'AnnotationNode') -> None: ...
    def addAnnotations(self, list: java.util.List['AnnotationNode']) -> None: ...
    @typing.overload
    def getAnnotations(self) -> java.util.List['AnnotationNode']: ...
    @typing.overload
    def getAnnotations(self, classNode: 'ClassNode') -> java.util.List['AnnotationNode']: ...
    def getDeclaringClass(self) -> 'ClassNode': ...
    def hasNoRealSourcePosition(self) -> bool: ...
    def isSynthetic(self) -> bool: ...
    def setDeclaringClass(self, classNode: 'ClassNode') -> None: ...
    def setHasNoRealSourcePosition(self, boolean: bool) -> None: ...
    def setSynthetic(self, boolean: bool) -> None: ...

class AnnotationNode(ASTNode):
    CONSTRUCTOR_TARGET: typing.ClassVar[int] = ...
    METHOD_TARGET: typing.ClassVar[int] = ...
    FIELD_TARGET: typing.ClassVar[int] = ...
    PARAMETER_TARGET: typing.ClassVar[int] = ...
    LOCAL_VARIABLE_TARGET: typing.ClassVar[int] = ...
    ANNOTATION_TARGET: typing.ClassVar[int] = ...
    PACKAGE_TARGET: typing.ClassVar[int] = ...
    TYPE_PARAMETER_TARGET: typing.ClassVar[int] = ...
    TYPE_USE_TARGET: typing.ClassVar[int] = ...
    TYPE_TARGET: typing.ClassVar[int] = ...
    def __init__(self, classNode: 'ClassNode'): ...
    def addMember(self, string: str, expression: org.codehaus.groovy.ast.expr.Expression) -> None: ...
    def getClassNode(self) -> 'ClassNode': ...
    def getMember(self, string: str) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getMembers(self) -> java.util.Map[str, org.codehaus.groovy.ast.expr.Expression]: ...
    def hasClassRetention(self) -> bool: ...
    def hasRuntimeRetention(self) -> bool: ...
    def hasSourceRetention(self) -> bool: ...
    def isBuiltIn(self) -> bool: ...
    def isTargetAllowed(self, int: int) -> bool: ...
    def setAllowedTargets(self, int: int) -> None: ...
    def setClassRetention(self, boolean: bool) -> None: ...
    def setMember(self, string: str, expression: org.codehaus.groovy.ast.expr.Expression) -> None: ...
    def setRuntimeRetention(self, boolean: bool) -> None: ...
    def setSourceRetention(self, boolean: bool) -> None: ...
    @staticmethod
    def targetToName(int: int) -> str: ...

class CodeVisitorSupport(GroovyCodeVisitor):
    def __init__(self): ...
    def visitArgumentlistExpression(self, argumentListExpression: org.codehaus.groovy.ast.expr.ArgumentListExpression) -> None: ...
    def visitArrayExpression(self, arrayExpression: org.codehaus.groovy.ast.expr.ArrayExpression) -> None: ...
    def visitAssertStatement(self, assertStatement: org.codehaus.groovy.ast.stmt.AssertStatement) -> None: ...
    def visitAttributeExpression(self, attributeExpression: org.codehaus.groovy.ast.expr.AttributeExpression) -> None: ...
    def visitBinaryExpression(self, binaryExpression: org.codehaus.groovy.ast.expr.BinaryExpression) -> None: ...
    def visitBitwiseNegationExpression(self, bitwiseNegationExpression: org.codehaus.groovy.ast.expr.BitwiseNegationExpression) -> None: ...
    def visitBlockStatement(self, blockStatement: org.codehaus.groovy.ast.stmt.BlockStatement) -> None: ...
    def visitBooleanExpression(self, booleanExpression: org.codehaus.groovy.ast.expr.BooleanExpression) -> None: ...
    def visitBreakStatement(self, breakStatement: org.codehaus.groovy.ast.stmt.BreakStatement) -> None: ...
    def visitBytecodeExpression(self, bytecodeExpression: org.codehaus.groovy.classgen.BytecodeExpression) -> None: ...
    def visitCaseStatement(self, caseStatement: org.codehaus.groovy.ast.stmt.CaseStatement) -> None: ...
    def visitCastExpression(self, castExpression: org.codehaus.groovy.ast.expr.CastExpression) -> None: ...
    def visitCatchStatement(self, catchStatement: org.codehaus.groovy.ast.stmt.CatchStatement) -> None: ...
    def visitClassExpression(self, classExpression: org.codehaus.groovy.ast.expr.ClassExpression) -> None: ...
    def visitClosureExpression(self, closureExpression: org.codehaus.groovy.ast.expr.ClosureExpression) -> None: ...
    def visitClosureListExpression(self, closureListExpression: org.codehaus.groovy.ast.expr.ClosureListExpression) -> None: ...
    def visitConstantExpression(self, constantExpression: org.codehaus.groovy.ast.expr.ConstantExpression) -> None: ...
    def visitConstructorCallExpression(self, constructorCallExpression: org.codehaus.groovy.ast.expr.ConstructorCallExpression) -> None: ...
    def visitContinueStatement(self, continueStatement: org.codehaus.groovy.ast.stmt.ContinueStatement) -> None: ...
    def visitDeclarationExpression(self, declarationExpression: org.codehaus.groovy.ast.expr.DeclarationExpression) -> None: ...
    def visitDoWhileLoop(self, doWhileStatement: org.codehaus.groovy.ast.stmt.DoWhileStatement) -> None: ...
    def visitExpressionStatement(self, expressionStatement: org.codehaus.groovy.ast.stmt.ExpressionStatement) -> None: ...
    def visitFieldExpression(self, fieldExpression: org.codehaus.groovy.ast.expr.FieldExpression) -> None: ...
    def visitForLoop(self, forStatement: org.codehaus.groovy.ast.stmt.ForStatement) -> None: ...
    def visitGStringExpression(self, gStringExpression: org.codehaus.groovy.ast.expr.GStringExpression) -> None: ...
    def visitIfElse(self, ifStatement: org.codehaus.groovy.ast.stmt.IfStatement) -> None: ...
    def visitListExpression(self, listExpression: org.codehaus.groovy.ast.expr.ListExpression) -> None: ...
    def visitMapEntryExpression(self, mapEntryExpression: org.codehaus.groovy.ast.expr.MapEntryExpression) -> None: ...
    def visitMapExpression(self, mapExpression: org.codehaus.groovy.ast.expr.MapExpression) -> None: ...
    def visitMethodCallExpression(self, methodCallExpression: org.codehaus.groovy.ast.expr.MethodCallExpression) -> None: ...
    def visitMethodPointerExpression(self, methodPointerExpression: org.codehaus.groovy.ast.expr.MethodPointerExpression) -> None: ...
    def visitNotExpression(self, notExpression: org.codehaus.groovy.ast.expr.NotExpression) -> None: ...
    def visitPostfixExpression(self, postfixExpression: org.codehaus.groovy.ast.expr.PostfixExpression) -> None: ...
    def visitPrefixExpression(self, prefixExpression: org.codehaus.groovy.ast.expr.PrefixExpression) -> None: ...
    def visitPropertyExpression(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression) -> None: ...
    def visitRangeExpression(self, rangeExpression: org.codehaus.groovy.ast.expr.RangeExpression) -> None: ...
    def visitReturnStatement(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement) -> None: ...
    def visitShortTernaryExpression(self, elvisOperatorExpression: org.codehaus.groovy.ast.expr.ElvisOperatorExpression) -> None: ...
    def visitSpreadExpression(self, spreadExpression: org.codehaus.groovy.ast.expr.SpreadExpression) -> None: ...
    def visitSpreadMapExpression(self, spreadMapExpression: org.codehaus.groovy.ast.expr.SpreadMapExpression) -> None: ...
    def visitStaticMethodCallExpression(self, staticMethodCallExpression: org.codehaus.groovy.ast.expr.StaticMethodCallExpression) -> None: ...
    def visitSwitch(self, switchStatement: org.codehaus.groovy.ast.stmt.SwitchStatement) -> None: ...
    def visitSynchronizedStatement(self, synchronizedStatement: org.codehaus.groovy.ast.stmt.SynchronizedStatement) -> None: ...
    def visitTernaryExpression(self, ternaryExpression: org.codehaus.groovy.ast.expr.TernaryExpression) -> None: ...
    def visitThrowStatement(self, throwStatement: org.codehaus.groovy.ast.stmt.ThrowStatement) -> None: ...
    def visitTryCatchFinally(self, tryCatchStatement: org.codehaus.groovy.ast.stmt.TryCatchStatement) -> None: ...
    def visitTupleExpression(self, tupleExpression: org.codehaus.groovy.ast.expr.TupleExpression) -> None: ...
    def visitUnaryMinusExpression(self, unaryMinusExpression: org.codehaus.groovy.ast.expr.UnaryMinusExpression) -> None: ...
    def visitUnaryPlusExpression(self, unaryPlusExpression: org.codehaus.groovy.ast.expr.UnaryPlusExpression) -> None: ...
    def visitVariableExpression(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...
    def visitWhileLoop(self, whileStatement: org.codehaus.groovy.ast.stmt.WhileStatement) -> None: ...

class DynamicVariable(Variable):
    def __init__(self, string: str, boolean: bool): ...
    def getInitialExpression(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getOriginType(self) -> 'ClassNode': ...
    def getType(self) -> 'ClassNode': ...
    def hasInitialExpression(self) -> bool: ...
    def isClosureSharedVariable(self) -> bool: ...
    def isDynamicTyped(self) -> bool: ...
    def isInStaticContext(self) -> bool: ...
    def setClosureSharedVariable(self, boolean: bool) -> None: ...

class GenericsType(ASTNode):
    EMPTY_ARRAY: typing.ClassVar[typing.MutableSequence['GenericsType']] = ...
    @typing.overload
    def __init__(self, classNode: 'ClassNode'): ...
    @typing.overload
    def __init__(self, classNode: 'ClassNode', classNodeArray: typing.Union[typing.List['ClassNode'], jpype.JArray], classNode3: 'ClassNode'): ...
    def getLowerBound(self) -> 'ClassNode': ...
    def getName(self) -> str: ...
    def getType(self) -> 'ClassNode': ...
    def getUpperBounds(self) -> typing.MutableSequence['ClassNode']: ...
    def isCompatibleWith(self, classNode: 'ClassNode') -> bool: ...
    def isPlaceholder(self) -> bool: ...
    def isResolved(self) -> bool: ...
    def isWildcard(self) -> bool: ...
    def setName(self, string: str) -> None: ...
    def setPlaceholder(self, boolean: bool) -> None: ...
    def setResolved(self, boolean: bool) -> None: ...
    def setType(self, classNode: 'ClassNode') -> None: ...
    def setWildcard(self, boolean: bool) -> None: ...
    def toString(self) -> str: ...
    class GenericsTypeName:
        def __init__(self, string: str): ...
        def equals(self, object: typing.Any) -> bool: ...
        def getName(self) -> str: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

class ModuleNode(ASTNode, groovyjarjarasm.asm.Opcodes):
    @typing.overload
    def __init__(self, compileUnit: CompileUnit): ...
    @typing.overload
    def __init__(self, sourceUnit: org.codehaus.groovy.control.SourceUnit): ...
    def addClass(self, classNode: 'ClassNode') -> None: ...
    @typing.overload
    def addImport(self, string: str, classNode: 'ClassNode') -> None: ...
    @typing.overload
    def addImport(self, string: str, classNode: 'ClassNode', list: java.util.List[AnnotationNode]) -> None: ...
    def addMethod(self, methodNode: 'MethodNode') -> None: ...
    @typing.overload
    def addStarImport(self, string: str) -> None: ...
    @typing.overload
    def addStarImport(self, string: str, list: java.util.List[AnnotationNode]) -> None: ...
    def addStatement(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> None: ...
    @typing.overload
    def addStaticImport(self, classNode: 'ClassNode', string: str, string2: str) -> None: ...
    @typing.overload
    def addStaticImport(self, classNode: 'ClassNode', string: str, string2: str, list: java.util.List[AnnotationNode]) -> None: ...
    @typing.overload
    def addStaticStarImport(self, string: str, classNode: 'ClassNode') -> None: ...
    @typing.overload
    def addStaticStarImport(self, string: str, classNode: 'ClassNode', list: java.util.List[AnnotationNode]) -> None: ...
    def getClasses(self) -> java.util.List['ClassNode']: ...
    def getContext(self) -> org.codehaus.groovy.control.SourceUnit: ...
    def getDescription(self) -> str: ...
    def getImport(self, string: str) -> 'ImportNode': ...
    def getImportType(self, string: str) -> 'ClassNode': ...
    def getImports(self) -> java.util.List['ImportNode']: ...
    def getMainClassName(self) -> str: ...
    def getMethods(self) -> java.util.List['MethodNode']: ...
    def getPackage(self) -> 'PackageNode': ...
    def getPackageName(self) -> str: ...
    def getScriptClassDummy(self) -> 'ClassNode': ...
    def getStarImports(self) -> java.util.List['ImportNode']: ...
    def getStatementBlock(self) -> org.codehaus.groovy.ast.stmt.BlockStatement: ...
    def getStaticImports(self) -> java.util.Map[str, 'ImportNode']: ...
    def getStaticStarImports(self) -> java.util.Map[str, 'ImportNode']: ...
    def getUnit(self) -> CompileUnit: ...
    def hasImportsResolved(self) -> bool: ...
    def hasPackage(self) -> bool: ...
    def hasPackageName(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def setDescription(self, string: str) -> None: ...
    def setImportsResolved(self, boolean: bool) -> None: ...
    def setPackage(self, packageNode: 'PackageNode') -> None: ...
    def setPackageName(self, string: str) -> None: ...
    def sortClasses(self) -> None: ...
    def visit(self, groovyCodeVisitor: GroovyCodeVisitor) -> None: ...

class ClassCodeVisitorSupport(CodeVisitorSupport, org.codehaus.groovy.transform.ErrorCollecting, GroovyClassVisitor):
    def __init__(self): ...
    def addError(self, string: str, aSTNode: ASTNode) -> None: ...
    def visitAnnotations(self, annotatedNode: AnnotatedNode) -> None: ...
    def visitAssertStatement(self, assertStatement: org.codehaus.groovy.ast.stmt.AssertStatement) -> None: ...
    def visitBlockStatement(self, blockStatement: org.codehaus.groovy.ast.stmt.BlockStatement) -> None: ...
    def visitBreakStatement(self, breakStatement: org.codehaus.groovy.ast.stmt.BreakStatement) -> None: ...
    def visitCaseStatement(self, caseStatement: org.codehaus.groovy.ast.stmt.CaseStatement) -> None: ...
    def visitCatchStatement(self, catchStatement: org.codehaus.groovy.ast.stmt.CatchStatement) -> None: ...
    def visitClass(self, classNode: 'ClassNode') -> None: ...
    def visitConstructor(self, constructorNode: 'ConstructorNode') -> None: ...
    def visitContinueStatement(self, continueStatement: org.codehaus.groovy.ast.stmt.ContinueStatement) -> None: ...
    def visitDeclarationExpression(self, declarationExpression: org.codehaus.groovy.ast.expr.DeclarationExpression) -> None: ...
    def visitDoWhileLoop(self, doWhileStatement: org.codehaus.groovy.ast.stmt.DoWhileStatement) -> None: ...
    def visitExpressionStatement(self, expressionStatement: org.codehaus.groovy.ast.stmt.ExpressionStatement) -> None: ...
    def visitField(self, fieldNode: 'FieldNode') -> None: ...
    def visitForLoop(self, forStatement: org.codehaus.groovy.ast.stmt.ForStatement) -> None: ...
    def visitIfElse(self, ifStatement: org.codehaus.groovy.ast.stmt.IfStatement) -> None: ...
    def visitImports(self, moduleNode: ModuleNode) -> None: ...
    def visitMethod(self, methodNode: 'MethodNode') -> None: ...
    def visitPackage(self, packageNode: 'PackageNode') -> None: ...
    def visitProperty(self, propertyNode: 'PropertyNode') -> None: ...
    def visitReturnStatement(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement) -> None: ...
    def visitSwitch(self, switchStatement: org.codehaus.groovy.ast.stmt.SwitchStatement) -> None: ...
    def visitSynchronizedStatement(self, synchronizedStatement: org.codehaus.groovy.ast.stmt.SynchronizedStatement) -> None: ...
    def visitThrowStatement(self, throwStatement: org.codehaus.groovy.ast.stmt.ThrowStatement) -> None: ...
    def visitTryCatchFinally(self, tryCatchStatement: org.codehaus.groovy.ast.stmt.TryCatchStatement) -> None: ...
    def visitWhileLoop(self, whileStatement: org.codehaus.groovy.ast.stmt.WhileStatement) -> None: ...

class ClassNode(AnnotatedNode, groovyjarjarasm.asm.Opcodes):
    EMPTY_ARRAY: typing.ClassVar[typing.MutableSequence['ClassNode']] = ...
    THIS: typing.ClassVar['ClassNode'] = ...
    SUPER: typing.ClassVar['ClassNode'] = ...
    @typing.overload
    def __init__(self, class_: typing.Type): ...
    @typing.overload
    def __init__(self, string: str, int: int, classNode: 'ClassNode'): ...
    @typing.overload
    def __init__(self, string: str, int: int, classNode: 'ClassNode', classNodeArray: typing.Union[typing.List['ClassNode'], jpype.JArray], mixinNodeArray: typing.Union[typing.List['MixinNode'], jpype.JArray]): ...
    @typing.overload
    def addConstructor(self, int: int, parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray], classNodeArray: typing.Union[typing.List['ClassNode'], jpype.JArray], statement: org.codehaus.groovy.ast.stmt.Statement) -> 'ConstructorNode': ...
    @typing.overload
    def addConstructor(self, constructorNode: 'ConstructorNode') -> None: ...
    @typing.overload
    def addField(self, string: str, int: int, classNode: 'ClassNode', expression: org.codehaus.groovy.ast.expr.Expression) -> 'FieldNode': ...
    @typing.overload
    def addField(self, fieldNode: 'FieldNode') -> None: ...
    @typing.overload
    def addFieldFirst(self, string: str, int: int, classNode: 'ClassNode', expression: org.codehaus.groovy.ast.expr.Expression) -> 'FieldNode': ...
    @typing.overload
    def addFieldFirst(self, fieldNode: 'FieldNode') -> None: ...
    def addInterface(self, classNode: 'ClassNode') -> None: ...
    @typing.overload
    def addMethod(self, string: str, int: int, classNode: 'ClassNode', parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray], classNodeArray: typing.Union[typing.List['ClassNode'], jpype.JArray], statement: org.codehaus.groovy.ast.stmt.Statement) -> 'MethodNode': ...
    @typing.overload
    def addMethod(self, methodNode: 'MethodNode') -> None: ...
    def addMixin(self, mixinNode: 'MixinNode') -> None: ...
    def addObjectInitializerStatements(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> None: ...
    @typing.overload
    def addProperty(self, string: str, int: int, classNode: 'ClassNode', expression: org.codehaus.groovy.ast.expr.Expression, statement: org.codehaus.groovy.ast.stmt.Statement, statement2: org.codehaus.groovy.ast.stmt.Statement) -> 'PropertyNode': ...
    @typing.overload
    def addProperty(self, propertyNode: 'PropertyNode') -> None: ...
    def addStaticInitializerStatements(self, list: java.util.List[org.codehaus.groovy.ast.stmt.Statement], boolean: bool) -> None: ...
    def addSyntheticMethod(self, string: str, int: int, classNode: 'ClassNode', parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray], classNodeArray: typing.Union[typing.List['ClassNode'], jpype.JArray], statement: org.codehaus.groovy.ast.stmt.Statement) -> 'MethodNode': ...
    def addTransform(self, class_: typing.Type[org.codehaus.groovy.transform.ASTTransformation], aSTNode: ASTNode) -> None: ...
    def declaresInterface(self, classNode: 'ClassNode') -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAbstractMethods(self) -> java.util.List['MethodNode']: ...
    def getAllDeclaredMethods(self) -> java.util.List['MethodNode']: ...
    def getAllInterfaces(self) -> java.util.Set['ClassNode']: ...
    @typing.overload
    def getAnnotations(self) -> java.util.List[AnnotationNode]: ...
    @typing.overload
    def getAnnotations(self, classNode: 'ClassNode') -> java.util.List[AnnotationNode]: ...
    def getCompileUnit(self) -> CompileUnit: ...
    def getComponentType(self) -> 'ClassNode': ...
    def getDeclaredConstructor(self, parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray]) -> 'ConstructorNode': ...
    def getDeclaredConstructors(self) -> java.util.List['ConstructorNode']: ...
    def getDeclaredField(self, string: str) -> 'FieldNode': ...
    def getDeclaredMethod(self, string: str, parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray]) -> 'MethodNode': ...
    def getDeclaredMethods(self, string: str) -> java.util.List['MethodNode']: ...
    def getDeclaredMethodsMap(self) -> java.util.Map[str, 'MethodNode']: ...
    def getEnclosingMethod(self) -> 'MethodNode': ...
    def getField(self, string: str) -> 'FieldNode': ...
    def getFieldIndex(self) -> java.util.Map[str, 'FieldNode']: ...
    def getFields(self) -> java.util.List['FieldNode']: ...
    def getGenericsTypes(self) -> typing.MutableSequence[GenericsType]: ...
    @typing.overload
    def getGetterMethod(self, string: str) -> 'MethodNode': ...
    @typing.overload
    def getGetterMethod(self, string: str, boolean: bool) -> 'MethodNode': ...
    def getInnerClasses(self) -> java.util.Iterator['InnerClassNode']: ...
    def getInterfaces(self) -> typing.MutableSequence['ClassNode']: ...
    def getMethod(self, string: str, parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray]) -> 'MethodNode': ...
    @typing.overload
    def getMethods(self) -> java.util.List['MethodNode']: ...
    @typing.overload
    def getMethods(self, string: str) -> java.util.List['MethodNode']: ...
    def getMixins(self) -> typing.MutableSequence['MixinNode']: ...
    def getModifiers(self) -> int: ...
    def getModule(self) -> ModuleNode: ...
    def getName(self) -> str: ...
    def getNameWithoutPackage(self) -> str: ...
    def getObjectInitializerStatements(self) -> java.util.List[org.codehaus.groovy.ast.stmt.Statement]: ...
    def getOuterClass(self) -> 'ClassNode': ...
    def getOuterClasses(self) -> java.util.List['ClassNode']: ...
    def getOuterField(self, string: str) -> 'FieldNode': ...
    def getPackage(self) -> 'PackageNode': ...
    def getPackageName(self) -> str: ...
    def getPlainNodeReference(self) -> 'ClassNode': ...
    def getProperties(self) -> java.util.List['PropertyNode']: ...
    def getProperty(self, string: str) -> 'PropertyNode': ...
    @typing.overload
    def getSetterMethod(self, string: str) -> 'MethodNode': ...
    @typing.overload
    def getSetterMethod(self, string: str, boolean: bool) -> 'MethodNode': ...
    def getSuperClass(self) -> 'ClassNode': ...
    def getText(self) -> str: ...
    def getTransforms(self, compilePhase: org.codehaus.groovy.control.CompilePhase) -> java.util.Map[typing.Type[org.codehaus.groovy.transform.ASTTransformation], java.util.Set[ASTNode]]: ...
    def getTypeClass(self) -> typing.Type: ...
    @typing.overload
    def getUnresolvedInterfaces(self) -> typing.MutableSequence['ClassNode']: ...
    @typing.overload
    def getUnresolvedInterfaces(self, boolean: bool) -> typing.MutableSequence['ClassNode']: ...
    def getUnresolvedName(self) -> str: ...
    @typing.overload
    def getUnresolvedSuperClass(self) -> 'ClassNode': ...
    @typing.overload
    def getUnresolvedSuperClass(self, boolean: bool) -> 'ClassNode': ...
    def hasDeclaredMethod(self, string: str, parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray]) -> bool: ...
    def hasMethod(self, string: str, parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray]) -> bool: ...
    def hasPackageName(self) -> bool: ...
    def hasPossibleMethod(self, string: str, expression: org.codehaus.groovy.ast.expr.Expression) -> bool: ...
    def hasPossibleStaticMethod(self, string: str, expression: org.codehaus.groovy.ast.expr.Expression) -> bool: ...
    def hasProperty(self, string: str) -> bool: ...
    def hashCode(self) -> int: ...
    def implementsInterface(self, classNode: 'ClassNode') -> bool: ...
    def isAbstract(self) -> bool: ...
    def isAnnotated(self) -> bool: ...
    def isAnnotationDefinition(self) -> bool: ...
    def isArray(self) -> bool: ...
    def isDerivedFrom(self, classNode: 'ClassNode') -> bool: ...
    def isDerivedFromGroovyObject(self) -> bool: ...
    def isEnum(self) -> bool: ...
    def isGenericsPlaceHolder(self) -> bool: ...
    def isInterface(self) -> bool: ...
    def isPrimaryClassNode(self) -> bool: ...
    def isRedirectNode(self) -> bool: ...
    def isResolved(self) -> bool: ...
    def isScript(self) -> bool: ...
    def isScriptBody(self) -> bool: ...
    def isStaticClass(self) -> bool: ...
    def isSyntheticPublic(self) -> bool: ...
    def isUsingGenerics(self) -> bool: ...
    def makeArray(self) -> 'ClassNode': ...
    def positionStmtsAfterEnumInitStmts(self, list: java.util.List[org.codehaus.groovy.ast.stmt.Statement]) -> None: ...
    def redirect(self) -> 'ClassNode': ...
    def removeConstructor(self, constructorNode: 'ConstructorNode') -> None: ...
    def removeField(self, string: str) -> None: ...
    def removeMethod(self, methodNode: 'MethodNode') -> None: ...
    def renameField(self, string: str, string2: str) -> None: ...
    def setAnnotated(self, boolean: bool) -> None: ...
    def setEnclosingMethod(self, methodNode: 'MethodNode') -> None: ...
    def setGenericsPlaceHolder(self, boolean: bool) -> None: ...
    def setGenericsTypes(self, genericsTypeArray: typing.Union[typing.List[GenericsType], jpype.JArray]) -> None: ...
    def setInterfaces(self, classNodeArray: typing.Union[typing.List['ClassNode'], jpype.JArray]) -> None: ...
    def setModifiers(self, int: int) -> None: ...
    def setModule(self, moduleNode: ModuleNode) -> None: ...
    def setName(self, string: str) -> str: ...
    def setRedirect(self, classNode: 'ClassNode') -> None: ...
    def setScript(self, boolean: bool) -> None: ...
    def setScriptBody(self, boolean: bool) -> None: ...
    def setStaticClass(self, boolean: bool) -> None: ...
    def setSuperClass(self, classNode: 'ClassNode') -> None: ...
    def setSyntheticPublic(self, boolean: bool) -> None: ...
    def setUnresolvedSuperClass(self, classNode: 'ClassNode') -> None: ...
    def setUsingGenerics(self, boolean: bool) -> None: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self, boolean: bool) -> str: ...
    def tryFindPossibleMethod(self, string: str, expression: org.codehaus.groovy.ast.expr.Expression) -> 'MethodNode': ...
    def visitContents(self, groovyClassVisitor: GroovyClassVisitor) -> None: ...

class FieldNode(AnnotatedNode, groovyjarjarasm.asm.Opcodes, Variable):
    def __init__(self, string: str, int: int, classNode: ClassNode, classNode2: ClassNode, expression: org.codehaus.groovy.ast.expr.Expression): ...
    def getInitialExpression(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getInitialValueExpression(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getOriginType(self) -> ClassNode: ...
    def getOwner(self) -> ClassNode: ...
    def getType(self) -> ClassNode: ...
    def hasInitialExpression(self) -> bool: ...
    def isClosureSharedVariable(self) -> bool: ...
    def isDynamicTyped(self) -> bool: ...
    def isEnum(self) -> bool: ...
    def isFinal(self) -> bool: ...
    def isHolder(self) -> bool: ...
    def isInStaticContext(self) -> bool: ...
    def isPrivate(self) -> bool: ...
    def isProtected(self) -> bool: ...
    def isPublic(self) -> bool: ...
    def isStatic(self) -> bool: ...
    def isVolatile(self) -> bool: ...
    @staticmethod
    def newStatic(class_: typing.Type, string: str) -> 'FieldNode': ...
    def rename(self, string: str) -> None: ...
    def setClosureSharedVariable(self, boolean: bool) -> None: ...
    def setHolder(self, boolean: bool) -> None: ...
    def setInitialValueExpression(self, expression: org.codehaus.groovy.ast.expr.Expression) -> None: ...
    def setModifiers(self, int: int) -> None: ...
    def setOriginType(self, classNode: ClassNode) -> None: ...
    def setOwner(self, classNode: ClassNode) -> None: ...
    def setType(self, classNode: ClassNode) -> None: ...

class ImportNode(AnnotatedNode, groovyjarjarasm.asm.Opcodes):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, classNode: ClassNode): ...
    @typing.overload
    def __init__(self, classNode: ClassNode, string: str): ...
    @typing.overload
    def __init__(self, classNode: ClassNode, string: str, string2: str): ...
    def getAlias(self) -> str: ...
    def getClassName(self) -> str: ...
    def getFieldName(self) -> str: ...
    def getPackageName(self) -> str: ...
    def getText(self) -> str: ...
    def getType(self) -> ClassNode: ...
    def isStar(self) -> bool: ...
    def isStatic(self) -> bool: ...
    def visit(self, groovyCodeVisitor: GroovyCodeVisitor) -> None: ...

class MethodInvocationTrap(CodeVisitorSupport):
    def __init__(self, readerSource: org.codehaus.groovy.control.io.ReaderSource, sourceUnit: org.codehaus.groovy.control.SourceUnit): ...
    def visitMethodCallExpression(self, methodCallExpression: org.codehaus.groovy.ast.expr.MethodCallExpression) -> None: ...

class MethodNode(AnnotatedNode, groovyjarjarasm.asm.Opcodes):
    SCRIPT_BODY_METHOD_KEY: typing.ClassVar[str] = ...
    def __init__(self, string: str, int: int, classNode: ClassNode, parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray], classNodeArray: typing.Union[typing.List[ClassNode], jpype.JArray], statement: org.codehaus.groovy.ast.stmt.Statement): ...
    def getCode(self) -> org.codehaus.groovy.ast.stmt.Statement: ...
    def getExceptions(self) -> typing.MutableSequence[ClassNode]: ...
    def getFirstStatement(self) -> org.codehaus.groovy.ast.stmt.Statement: ...
    def getGenericsTypes(self) -> typing.MutableSequence[GenericsType]: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getParameters(self) -> typing.MutableSequence['Parameter']: ...
    def getReturnType(self) -> ClassNode: ...
    def getText(self) -> str: ...
    def getTypeDescriptor(self) -> str: ...
    def getVariableScope(self) -> VariableScope: ...
    def hasAnnotationDefault(self) -> bool: ...
    def hasDefaultValue(self) -> bool: ...
    def isAbstract(self) -> bool: ...
    def isDynamicReturnType(self) -> bool: ...
    def isFinal(self) -> bool: ...
    def isPackageScope(self) -> bool: ...
    def isPrivate(self) -> bool: ...
    def isProtected(self) -> bool: ...
    def isPublic(self) -> bool: ...
    def isScriptBody(self) -> bool: ...
    def isStatic(self) -> bool: ...
    def isStaticConstructor(self) -> bool: ...
    def isSyntheticPublic(self) -> bool: ...
    def isVoidMethod(self) -> bool: ...
    def setAnnotationDefault(self, boolean: bool) -> None: ...
    def setCode(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> None: ...
    def setGenericsTypes(self, genericsTypeArray: typing.Union[typing.List[GenericsType], jpype.JArray]) -> None: ...
    def setIsScriptBody(self) -> None: ...
    def setModifiers(self, int: int) -> None: ...
    def setParameters(self, parameterArray: typing.Union[typing.List['Parameter'], jpype.JArray]) -> None: ...
    def setReturnType(self, classNode: ClassNode) -> None: ...
    def setSyntheticPublic(self, boolean: bool) -> None: ...
    def setVariableScope(self, variableScope: VariableScope) -> None: ...
    def toString(self) -> str: ...

class PackageNode(AnnotatedNode):
    def __init__(self, string: str): ...
    def getName(self) -> str: ...
    def getText(self) -> str: ...
    def visit(self, groovyCodeVisitor: GroovyCodeVisitor) -> None: ...

class Parameter(AnnotatedNode, Variable):
    EMPTY_ARRAY: typing.ClassVar[typing.MutableSequence['Parameter']] = ...
    @typing.overload
    def __init__(self, classNode: ClassNode, string: str): ...
    @typing.overload
    def __init__(self, classNode: ClassNode, string: str, expression: org.codehaus.groovy.ast.expr.Expression): ...
    def getInitialExpression(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getOriginType(self) -> ClassNode: ...
    def getType(self) -> ClassNode: ...
    def hasInitialExpression(self) -> bool: ...
    def isClosureSharedVariable(self) -> bool: ...
    def isDynamicTyped(self) -> bool: ...
    def isInStaticContext(self) -> bool: ...
    def setClosureSharedVariable(self, boolean: bool) -> None: ...
    def setInStaticContext(self, boolean: bool) -> None: ...
    def setInitialExpression(self, expression: org.codehaus.groovy.ast.expr.Expression) -> None: ...
    def setModifiers(self, int: int) -> None: ...
    def setOriginType(self, classNode: ClassNode) -> None: ...
    def setType(self, classNode: ClassNode) -> None: ...
    def toString(self) -> str: ...

class PropertyNode(AnnotatedNode, groovyjarjarasm.asm.Opcodes, Variable):
    @typing.overload
    def __init__(self, string: str, int: int, classNode: ClassNode, classNode2: ClassNode, expression: org.codehaus.groovy.ast.expr.Expression, statement: org.codehaus.groovy.ast.stmt.Statement, statement2: org.codehaus.groovy.ast.stmt.Statement): ...
    @typing.overload
    def __init__(self, fieldNode: FieldNode, int: int, statement: org.codehaus.groovy.ast.stmt.Statement, statement2: org.codehaus.groovy.ast.stmt.Statement): ...
    def getField(self) -> FieldNode: ...
    def getGetterBlock(self) -> org.codehaus.groovy.ast.stmt.Statement: ...
    def getInitialExpression(self) -> org.codehaus.groovy.ast.expr.Expression: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getOriginType(self) -> ClassNode: ...
    def getSetterBlock(self) -> org.codehaus.groovy.ast.stmt.Statement: ...
    def getType(self) -> ClassNode: ...
    def hasInitialExpression(self) -> bool: ...
    def isClosureSharedVariable(self) -> bool: ...
    def isDynamicTyped(self) -> bool: ...
    def isInStaticContext(self) -> bool: ...
    def isPrivate(self) -> bool: ...
    def isPublic(self) -> bool: ...
    def isStatic(self) -> bool: ...
    def setClosureSharedVariable(self, boolean: bool) -> None: ...
    def setField(self, fieldNode: FieldNode) -> None: ...
    def setGetterBlock(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> None: ...
    def setSetterBlock(self, statement: org.codehaus.groovy.ast.stmt.Statement) -> None: ...
    def setType(self, classNode: ClassNode) -> None: ...

class TransformingCodeVisitor(CodeVisitorSupport):
    def __init__(self, classCodeExpressionTransformer: 'ClassCodeExpressionTransformer'): ...
    def visitArgumentlistExpression(self, argumentListExpression: org.codehaus.groovy.ast.expr.ArgumentListExpression) -> None: ...
    def visitArrayExpression(self, arrayExpression: org.codehaus.groovy.ast.expr.ArrayExpression) -> None: ...
    def visitAssertStatement(self, assertStatement: org.codehaus.groovy.ast.stmt.AssertStatement) -> None: ...
    def visitAttributeExpression(self, attributeExpression: org.codehaus.groovy.ast.expr.AttributeExpression) -> None: ...
    def visitBinaryExpression(self, binaryExpression: org.codehaus.groovy.ast.expr.BinaryExpression) -> None: ...
    def visitBitwiseNegationExpression(self, bitwiseNegationExpression: org.codehaus.groovy.ast.expr.BitwiseNegationExpression) -> None: ...
    def visitBlockStatement(self, blockStatement: org.codehaus.groovy.ast.stmt.BlockStatement) -> None: ...
    def visitBooleanExpression(self, booleanExpression: org.codehaus.groovy.ast.expr.BooleanExpression) -> None: ...
    def visitBreakStatement(self, breakStatement: org.codehaus.groovy.ast.stmt.BreakStatement) -> None: ...
    def visitBytecodeExpression(self, bytecodeExpression: org.codehaus.groovy.classgen.BytecodeExpression) -> None: ...
    def visitCaseStatement(self, caseStatement: org.codehaus.groovy.ast.stmt.CaseStatement) -> None: ...
    def visitCastExpression(self, castExpression: org.codehaus.groovy.ast.expr.CastExpression) -> None: ...
    def visitCatchStatement(self, catchStatement: org.codehaus.groovy.ast.stmt.CatchStatement) -> None: ...
    def visitClassExpression(self, classExpression: org.codehaus.groovy.ast.expr.ClassExpression) -> None: ...
    def visitClosureExpression(self, closureExpression: org.codehaus.groovy.ast.expr.ClosureExpression) -> None: ...
    def visitClosureListExpression(self, closureListExpression: org.codehaus.groovy.ast.expr.ClosureListExpression) -> None: ...
    def visitConstantExpression(self, constantExpression: org.codehaus.groovy.ast.expr.ConstantExpression) -> None: ...
    def visitContinueStatement(self, continueStatement: org.codehaus.groovy.ast.stmt.ContinueStatement) -> None: ...
    def visitDeclarationExpression(self, declarationExpression: org.codehaus.groovy.ast.expr.DeclarationExpression) -> None: ...
    def visitDoWhileLoop(self, doWhileStatement: org.codehaus.groovy.ast.stmt.DoWhileStatement) -> None: ...
    def visitExpressionStatement(self, expressionStatement: org.codehaus.groovy.ast.stmt.ExpressionStatement) -> None: ...
    def visitFieldExpression(self, fieldExpression: org.codehaus.groovy.ast.expr.FieldExpression) -> None: ...
    def visitForLoop(self, forStatement: org.codehaus.groovy.ast.stmt.ForStatement) -> None: ...
    def visitGStringExpression(self, gStringExpression: org.codehaus.groovy.ast.expr.GStringExpression) -> None: ...
    def visitIfElse(self, ifStatement: org.codehaus.groovy.ast.stmt.IfStatement) -> None: ...
    def visitListExpression(self, listExpression: org.codehaus.groovy.ast.expr.ListExpression) -> None: ...
    def visitMapEntryExpression(self, mapEntryExpression: org.codehaus.groovy.ast.expr.MapEntryExpression) -> None: ...
    def visitMapExpression(self, mapExpression: org.codehaus.groovy.ast.expr.MapExpression) -> None: ...
    def visitMethodPointerExpression(self, methodPointerExpression: org.codehaus.groovy.ast.expr.MethodPointerExpression) -> None: ...
    def visitNotExpression(self, notExpression: org.codehaus.groovy.ast.expr.NotExpression) -> None: ...
    def visitPostfixExpression(self, postfixExpression: org.codehaus.groovy.ast.expr.PostfixExpression) -> None: ...
    def visitPrefixExpression(self, prefixExpression: org.codehaus.groovy.ast.expr.PrefixExpression) -> None: ...
    def visitPropertyExpression(self, propertyExpression: org.codehaus.groovy.ast.expr.PropertyExpression) -> None: ...
    def visitRangeExpression(self, rangeExpression: org.codehaus.groovy.ast.expr.RangeExpression) -> None: ...
    def visitReturnStatement(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement) -> None: ...
    def visitShortTernaryExpression(self, elvisOperatorExpression: org.codehaus.groovy.ast.expr.ElvisOperatorExpression) -> None: ...
    def visitSpreadExpression(self, spreadExpression: org.codehaus.groovy.ast.expr.SpreadExpression) -> None: ...
    def visitSpreadMapExpression(self, spreadMapExpression: org.codehaus.groovy.ast.expr.SpreadMapExpression) -> None: ...
    def visitStaticMethodCallExpression(self, staticMethodCallExpression: org.codehaus.groovy.ast.expr.StaticMethodCallExpression) -> None: ...
    def visitSwitch(self, switchStatement: org.codehaus.groovy.ast.stmt.SwitchStatement) -> None: ...
    def visitSynchronizedStatement(self, synchronizedStatement: org.codehaus.groovy.ast.stmt.SynchronizedStatement) -> None: ...
    def visitTernaryExpression(self, ternaryExpression: org.codehaus.groovy.ast.expr.TernaryExpression) -> None: ...
    def visitThrowStatement(self, throwStatement: org.codehaus.groovy.ast.stmt.ThrowStatement) -> None: ...
    def visitTryCatchFinally(self, tryCatchStatement: org.codehaus.groovy.ast.stmt.TryCatchStatement) -> None: ...
    def visitTupleExpression(self, tupleExpression: org.codehaus.groovy.ast.expr.TupleExpression) -> None: ...
    def visitUnaryMinusExpression(self, unaryMinusExpression: org.codehaus.groovy.ast.expr.UnaryMinusExpression) -> None: ...
    def visitUnaryPlusExpression(self, unaryPlusExpression: org.codehaus.groovy.ast.expr.UnaryPlusExpression) -> None: ...
    def visitVariableExpression(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...
    def visitWhileLoop(self, whileStatement: org.codehaus.groovy.ast.stmt.WhileStatement) -> None: ...

class ClassCodeExpressionTransformer(ClassCodeVisitorSupport, org.codehaus.groovy.ast.expr.ExpressionTransformer):
    def __init__(self): ...
    def transform(self, expression: org.codehaus.groovy.ast.expr.Expression) -> org.codehaus.groovy.ast.expr.Expression: ...
    def visitAnnotations(self, annotatedNode: AnnotatedNode) -> None: ...
    def visitAssertStatement(self, assertStatement: org.codehaus.groovy.ast.stmt.AssertStatement) -> None: ...
    def visitCaseStatement(self, caseStatement: org.codehaus.groovy.ast.stmt.CaseStatement) -> None: ...
    def visitDoWhileLoop(self, doWhileStatement: org.codehaus.groovy.ast.stmt.DoWhileStatement) -> None: ...
    def visitExpressionStatement(self, expressionStatement: org.codehaus.groovy.ast.stmt.ExpressionStatement) -> None: ...
    def visitField(self, fieldNode: FieldNode) -> None: ...
    def visitForLoop(self, forStatement: org.codehaus.groovy.ast.stmt.ForStatement) -> None: ...
    def visitIfElse(self, ifStatement: org.codehaus.groovy.ast.stmt.IfStatement) -> None: ...
    def visitProperty(self, propertyNode: PropertyNode) -> None: ...
    def visitReturnStatement(self, returnStatement: org.codehaus.groovy.ast.stmt.ReturnStatement) -> None: ...
    def visitSwitch(self, switchStatement: org.codehaus.groovy.ast.stmt.SwitchStatement) -> None: ...
    def visitSynchronizedStatement(self, synchronizedStatement: org.codehaus.groovy.ast.stmt.SynchronizedStatement) -> None: ...
    def visitThrowStatement(self, throwStatement: org.codehaus.groovy.ast.stmt.ThrowStatement) -> None: ...
    def visitWhileLoop(self, whileStatement: org.codehaus.groovy.ast.stmt.WhileStatement) -> None: ...

class ConstructorNode(MethodNode):
    @typing.overload
    def __init__(self, int: int, parameterArray: typing.Union[typing.List[Parameter], jpype.JArray], classNodeArray: typing.Union[typing.List[ClassNode], jpype.JArray], statement: org.codehaus.groovy.ast.stmt.Statement): ...
    @typing.overload
    def __init__(self, int: int, statement: org.codehaus.groovy.ast.stmt.Statement): ...
    def firstStatementIsSpecialConstructorCall(self) -> bool: ...

class InnerClassNode(ClassNode):
    @typing.overload
    def __init__(self, classNode: ClassNode, string: str, int: int, classNode2: ClassNode): ...
    @typing.overload
    def __init__(self, classNode: ClassNode, string: str, int: int, classNode2: ClassNode, classNodeArray: typing.Union[typing.List[ClassNode], jpype.JArray], mixinNodeArray: typing.Union[typing.List['MixinNode'], jpype.JArray]): ...
    @typing.overload
    def addConstructor(self, int: int, parameterArray: typing.Union[typing.List[Parameter], jpype.JArray], classNodeArray: typing.Union[typing.List[ClassNode], jpype.JArray], statement: org.codehaus.groovy.ast.stmt.Statement) -> ConstructorNode: ...
    @typing.overload
    def addConstructor(self, constructorNode: ConstructorNode) -> None: ...
    def getOuterClass(self) -> ClassNode: ...
    def getOuterField(self, string: str) -> FieldNode: ...
    def getOuterMostClass(self) -> ClassNode: ...
    def getVariableScope(self) -> VariableScope: ...
    def isAnonymous(self) -> bool: ...
    def setAnonymous(self, boolean: bool) -> None: ...
    def setVariableScope(self, variableScope: VariableScope) -> None: ...

class MixinNode(ClassNode):
    EMPTY_ARRAY: typing.ClassVar[typing.MutableSequence['MixinNode']] = ...
    @typing.overload
    def __init__(self, string: str, int: int, classNode: ClassNode): ...
    @typing.overload
    def __init__(self, string: str, int: int, classNode: ClassNode, classNodeArray: typing.Union[typing.List[ClassNode], jpype.JArray]): ...

class EnumConstantClassNode(InnerClassNode):
    def __init__(self, classNode: ClassNode, string: str, int: int, classNode2: ClassNode): ...

class InterfaceHelperClassNode(InnerClassNode):
    def __init__(self, classNode: ClassNode, string: str, int: int, classNode2: ClassNode, list: java.util.List[str]): ...
    def getCallSites(self) -> java.util.List[str]: ...
    def setCallSites(self, list: java.util.List[str]) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.ast")``.

    ASTNode: typing.Type[ASTNode]
    AnnotatedNode: typing.Type[AnnotatedNode]
    AnnotationNode: typing.Type[AnnotationNode]
    AstToTextHelper: typing.Type[AstToTextHelper]
    ClassCodeExpressionTransformer: typing.Type[ClassCodeExpressionTransformer]
    ClassCodeVisitorSupport: typing.Type[ClassCodeVisitorSupport]
    ClassHelper: typing.Type[ClassHelper]
    ClassNode: typing.Type[ClassNode]
    CodeVisitorSupport: typing.Type[CodeVisitorSupport]
    CompileUnit: typing.Type[CompileUnit]
    ConstructorNode: typing.Type[ConstructorNode]
    DynamicVariable: typing.Type[DynamicVariable]
    EnumConstantClassNode: typing.Type[EnumConstantClassNode]
    FieldNode: typing.Type[FieldNode]
    GenericsType: typing.Type[GenericsType]
    GroovyClassVisitor: typing.Type[GroovyClassVisitor]
    GroovyCodeVisitor: typing.Type[GroovyCodeVisitor]
    ImportNode: typing.Type[ImportNode]
    InnerClassNode: typing.Type[InnerClassNode]
    InterfaceHelperClassNode: typing.Type[InterfaceHelperClassNode]
    MethodCallTransformation: typing.Type[MethodCallTransformation]
    MethodInvocationTrap: typing.Type[MethodInvocationTrap]
    MethodNode: typing.Type[MethodNode]
    MixinASTTransformation: typing.Type[MixinASTTransformation]
    MixinNode: typing.Type[MixinNode]
    ModuleNode: typing.Type[ModuleNode]
    PackageNode: typing.Type[PackageNode]
    Parameter: typing.Type[Parameter]
    PropertyNode: typing.Type[PropertyNode]
    TransformingCodeVisitor: typing.Type[TransformingCodeVisitor]
    Variable: typing.Type[Variable]
    VariableScope: typing.Type[VariableScope]
    builder: org.codehaus.groovy.ast.builder.__module_protocol__
    decompiled: org.codehaus.groovy.ast.decompiled.__module_protocol__
    expr: org.codehaus.groovy.ast.expr.__module_protocol__
    stmt: org.codehaus.groovy.ast.stmt.__module_protocol__
    tools: org.codehaus.groovy.ast.tools.__module_protocol__
