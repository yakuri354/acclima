
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import groovy.util
import java.lang
import java.util
import jline.console.completer
import org.codehaus.groovy.antlr
import org.codehaus.groovy.antlr.parser
import org.codehaus.groovy.runtime
import org.codehaus.groovy.tools.shell
import org.codehaus.groovy.tools.shell.util
import typing



class BackslashEscapeCompleter(jline.console.completer.Completer, groovy.lang.GroovyObject):
    def __init__(self): ...
    def complete(self, string: str, int: int, list: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> int: ...

class CommandNameCompleter(org.codehaus.groovy.tools.shell.util.SimpleCompletor):
    def __init__(self, commandRegistry: org.codehaus.groovy.tools.shell.CommandRegistry, boolean: bool): ...
    def getCandidates(self) -> java.util.SortedSet[str]: ...

class FileNameCompleter(jline.console.completer.FileNameCompleter, groovy.lang.GroovyObject):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, boolean: bool, boolean2: bool): ...
    @typing.overload
    def __init__(self, boolean: bool, boolean2: bool, boolean3: bool): ...
    def complete(self, string: str, int: int, list: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> int: ...
    def getEscapeBackslash(self) -> bool: ...
    def getEscapeSpaces(self) -> bool: ...
    def getPrintSpaceAfterFullCompletion(self) -> bool: ...
    def isEscapeBackslash(self) -> bool: ...
    def isEscapeSpaces(self) -> bool: ...
    def isPrintSpaceAfterFullCompletion(self) -> bool: ...
    def setEscapeBackslash(self, boolean: bool) -> None: ...
    def setEscapeSpaces(self, boolean: bool) -> None: ...
    def setPrintSpaceAfterFullCompletion(self, boolean: bool) -> None: ...

class GroovySyntaxCompletor(jline.console.completer.Completer, groovy.lang.GroovyObject):
    def __init__(self, groovysh: org.codehaus.groovy.tools.shell.Groovysh, reflectionCompletor: 'ReflectionCompletor', identifierCompletor: 'IdentifierCompletor', list: java.util.List['IdentifierCompletor'], completer: jline.console.completer.Completer): ...
    def complete(self, string: str, int: int, list: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> int: ...
    def completeIdentifier(self, list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken], list2: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> int: ...
    @staticmethod
    def createGroovyLexer(string: str) -> org.codehaus.groovy.antlr.parser.GroovyLexer: ...
    @staticmethod
    def getCompletionCase(list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken]) -> 'GroovySyntaxCompletor.CompletionCase': ...
    @staticmethod
    def isCommand(string: str, commandRegistry: org.codehaus.groovy.tools.shell.CommandRegistry) -> bool: ...
    @staticmethod
    def tokenizeBuffer(string: str, list: java.util.List[str], list2: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken]) -> bool: ...
    class CompletionCase(java.lang.Enum['GroovySyntaxCompletor.CompletionCase'], groovy.lang.GroovyObject):
        SECOND_IDENT: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        NO_COMPLETION: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        DOT_LAST: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        SPREAD_DOT_LAST: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        PREFIX_AFTER_DOT: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        PREFIX_AFTER_SPREAD_DOT: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        NO_DOT_PREFIX: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        INSTANCEOF: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        MIN_VALUE: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        MAX_VALUE: typing.ClassVar['GroovySyntaxCompletor.CompletionCase'] = ...
        @typing.overload
        def __init__(self, string: str, int: int): ...
        @typing.overload
        def __init__(self, string: str, int: int, linkedHashMap: java.util.LinkedHashMap): ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'GroovySyntaxCompletor.CompletionCase': ...
        @staticmethod
        def values() -> typing.MutableSequence['GroovySyntaxCompletor.CompletionCase']: ...
    class InStringException(java.lang.Exception, groovy.lang.GroovyObject):
        @typing.overload
        def __init__(self): ...
        @typing.overload
        def __init__(self, int: int): ...
        @typing.overload
        def __init__(self, int: int, string: str): ...
        def getColumn(self) -> int: ...
        def getOpenDelim(self) -> str: ...
        def setColumn(self, int: int) -> None: ...
        def setOpenDelim(self, string: str) -> None: ...
        def toString(self) -> str: ...

class IdentifierCompletor:
    def complete(self, list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken], list2: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> bool: ...

class NavigablePropertiesCompleter(groovy.lang.GroovyObject):
    def __init__(self): ...
    def addCompletions(self, object: typing.Any, string: str, set: java.util.Set[typing.Union[java.lang.CharSequence, str]]) -> None: ...
    def addIndirectObjectMembers(self, object: typing.Any, string: str, set: java.util.Set[typing.Union[java.lang.CharSequence, str]]) -> None: ...
    @staticmethod
    def addMapProperties(map: typing.Union[java.util.Map, typing.Mapping], string: str, set: java.util.Set[typing.Union[java.lang.CharSequence, str]]) -> None: ...
    def addNodeChildren(self, node: groovy.util.Node, string: str, set: java.util.Set[typing.Union[java.lang.CharSequence, str]]) -> None: ...
    def addNodeListEntries(self, nodeList: groovy.util.NodeList, string: str, set: java.util.Set[typing.Union[java.lang.CharSequence, str]]) -> None: ...

class ReflectionCompletionCandidate(java.lang.Comparable['ReflectionCompletionCandidate'], groovy.lang.GroovyObject):
    def __init__(self, string: str, *string2: str): ...
    def compareTo(self, reflectionCompletionCandidate: 'ReflectionCompletionCandidate') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getValue(self) -> str: ...
    def getjAnsiCodes(self) -> java.util.List[str]: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class ReflectionCompletor(groovy.lang.GroovyObject):
    def __init__(self, groovysh: org.codehaus.groovy.tools.shell.Groovysh): ...
    @staticmethod
    def acceptName(string: str, string2: str) -> bool: ...
    def complete(self, list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken], list2: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> int: ...
    @staticmethod
    def getDefaultMethods(object: typing.Any, string: str) -> java.util.List[str]: ...
    @staticmethod
    def getFieldnameForAccessor(string: str, int: int) -> java.lang.CharSequence: ...
    def getInvokerClassOrInstance(self, list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken]) -> typing.Any: ...
    @staticmethod
    def getInvokerTokens(list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken]) -> java.util.List[org.codehaus.groovy.antlr.GroovySourceToken]: ...
    @staticmethod
    def getMetaclassMethods(object: typing.Any, string: str, boolean: bool) -> java.util.Collection[str]: ...
    @staticmethod
    def getPublicFieldsAndMethods(object: typing.Any, string: str) -> java.util.Collection[ReflectionCompletionCandidate]: ...
    def getShell(self) -> org.codehaus.groovy.tools.shell.Groovysh: ...
    @staticmethod
    def removeStandardMethods(collection: typing.Union[java.util.Collection[ReflectionCompletionCandidate], typing.Sequence[ReflectionCompletionCandidate], typing.Set[ReflectionCompletionCandidate]]) -> typing.Any: ...
    @staticmethod
    def tokenListToEvalString(list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken]) -> str: ...

class StricterArgumentCompleter(jline.console.completer.ArgumentCompleter, groovy.lang.GroovyObject):
    def __init__(self, list: java.util.List[jline.console.completer.Completer]): ...
    def complete(self, string: str, int: int, list: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> int: ...

class CustomClassSyntaxCompletor(IdentifierCompletor, groovy.lang.GroovyObject):
    def __init__(self, groovysh: org.codehaus.groovy.tools.shell.Groovysh): ...
    def complete(self, list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken], list2: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> bool: ...

class ImportsSyntaxCompletor(IdentifierCompletor, groovy.lang.GroovyObject):
    def __init__(self, groovysh: org.codehaus.groovy.tools.shell.Groovysh): ...
    def collectImportedSymbols(self, string: str, collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]]) -> None: ...
    def complete(self, list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken], list2: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> bool: ...
    def findMatchingImportedClassesCached(self, string: str, string2: str, list: java.util.List[str]) -> bool: ...
    def findMatchingPreImportedClasses(self, string: str, collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]]) -> bool: ...
    def getCachedImports(self) -> java.util.Map[str, java.util.Collection[str]]: ...
    def getPreimportedClassNames(self) -> java.util.List[str]: ...
    def getShell(self) -> org.codehaus.groovy.tools.shell.Groovysh: ...
    def setPreimportedClassNames(self, list: java.util.List[str]) -> None: ...
    class _closure1(groovy.lang.Closure, org.codehaus.groovy.runtime.GeneratedClosure):
        def __init__(self, object: typing.Any, object2: typing.Any): ...
        @typing.overload
        def call(self) -> typing.Any: ...
        @typing.overload
        def call(self, object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, *object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, string: str) -> typing.Any: ...
        def doCall(self, string: str) -> typing.Any: ...

class InfixKeywordSyntaxCompletor(IdentifierCompletor, groovy.lang.GroovyObject):
    def __init__(self): ...
    def complete(self, list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken], list2: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> bool: ...

class KeywordSyntaxCompletor(IdentifierCompletor, groovy.lang.GroovyObject):
    def __init__(self): ...
    def complete(self, list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken], list2: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> bool: ...

class VariableSyntaxCompletor(IdentifierCompletor, groovy.lang.GroovyObject):
    def __init__(self, groovysh: org.codehaus.groovy.tools.shell.Groovysh): ...
    def complete(self, list: java.util.List[org.codehaus.groovy.antlr.GroovySourceToken], list2: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> bool: ...
    def getShell(self) -> org.codehaus.groovy.tools.shell.Groovysh: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.tools.shell.completion")``.

    BackslashEscapeCompleter: typing.Type[BackslashEscapeCompleter]
    CommandNameCompleter: typing.Type[CommandNameCompleter]
    CustomClassSyntaxCompletor: typing.Type[CustomClassSyntaxCompletor]
    FileNameCompleter: typing.Type[FileNameCompleter]
    GroovySyntaxCompletor: typing.Type[GroovySyntaxCompletor]
    IdentifierCompletor: typing.Type[IdentifierCompletor]
    ImportsSyntaxCompletor: typing.Type[ImportsSyntaxCompletor]
    InfixKeywordSyntaxCompletor: typing.Type[InfixKeywordSyntaxCompletor]
    KeywordSyntaxCompletor: typing.Type[KeywordSyntaxCompletor]
    NavigablePropertiesCompleter: typing.Type[NavigablePropertiesCompleter]
    ReflectionCompletionCandidate: typing.Type[ReflectionCompletionCandidate]
    ReflectionCompletor: typing.Type[ReflectionCompletor]
    StricterArgumentCompleter: typing.Type[StricterArgumentCompleter]
    VariableSyntaxCompletor: typing.Type[VariableSyntaxCompletor]
