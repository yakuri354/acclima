
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import java.io
import java.lang
import java.util
import java.util.concurrent
import jline.console
import jline.console.completer
import jline.console.history
import org.codehaus.groovy.control
import org.codehaus.groovy.runtime
import org.codehaus.groovy.tools.shell.commands
import org.codehaus.groovy.tools.shell.completion
import org.codehaus.groovy.tools.shell.util
import typing



class AnsiDetector(java.util.concurrent.Callable[bool], groovy.lang.GroovyObject):
    def __init__(self): ...
    def call(self) -> bool: ...

class BufferManager(groovy.lang.GroovyObject):
    def __init__(self): ...
    def clearSelected(self) -> None: ...
    def create(self, boolean: bool) -> int: ...
    def current(self) -> java.util.List[str]: ...
    def delete(self, int: int) -> None: ...
    def deleteSelected(self) -> None: ...
    def getBuffers(self) -> java.util.List[java.util.List[str]]: ...
    def getSelected(self) -> int: ...
    def reset(self) -> None: ...
    def select(self, int: int) -> None: ...
    def setSelected(self, int: int) -> None: ...
    def size(self) -> int: ...
    def updateSelected(self, list: java.util.List) -> None: ...

class Command:
    def execute(self, list: java.util.List[str]) -> typing.Any: ...
    def getAliases(self) -> java.util.List: ...
    def getCompleter(self) -> jline.console.completer.Completer: ...
    def getDescription(self) -> str: ...
    def getHelp(self) -> str: ...
    def getHidden(self) -> bool: ...
    def getName(self) -> str: ...
    def getShortcut(self) -> str: ...
    def getUsage(self) -> str: ...

class CommandException(java.lang.Exception, groovy.lang.GroovyObject):
    @typing.overload
    def __init__(self, command: Command, string: str): ...
    @typing.overload
    def __init__(self, command: Command, string: str, throwable: java.lang.Throwable): ...
    def getCommand(self) -> Command: ...

class CommandRegistry(groovy.lang.GroovyObject):
    def __init__(self): ...
    def commands(self) -> java.util.List[Command]: ...
    def find(self, string: str) -> Command: ...
    def getCommandList(self) -> java.util.List[Command]: ...
    def getProperty(self, string: str) -> Command: ...
    def iterator(self) -> java.util.Iterator: ...
    def register(self, command: Command) -> Command: ...
    def remove(self, command: Command) -> None: ...

class CommandsMultiCompleter(jline.console.completer.AggregateCompleter, groovy.lang.GroovyObject):
    def __init__(self): ...
    def add(self, command: Command) -> typing.Any: ...
    def complete(self, string: str, int: int, list: java.util.List) -> int: ...
    def getList(self) -> java.util.List: ...
    def refresh(self) -> None: ...
    def setList(self, list: java.util.List) -> None: ...

class Evaluator:
    def evaluate(self, collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]]) -> typing.Any: ...

class ExitNotification(java.lang.Error, groovy.lang.GroovyObject):
    def __init__(self, int: int): ...
    def getCode(self) -> int: ...

class IO(java.io.Closeable):
    inputStream: java.io.InputStream = ...
    outputStream: java.io.OutputStream = ...
    errorStream: java.io.OutputStream = ...
    in_: java.io.Reader = ...
    out: java.io.PrintWriter = ...
    err: java.io.PrintWriter = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream, outputStream: java.io.OutputStream, outputStream2: java.io.OutputStream): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def getVerbosity(self) -> 'IO.Verbosity': ...
    def isDebug(self) -> bool: ...
    def isInfo(self) -> bool: ...
    def isQuiet(self) -> bool: ...
    def isVerbose(self) -> bool: ...
    def setVerbosity(self, verbosity: 'IO.Verbosity') -> None: ...
    class Verbosity:
        QUIET: typing.ClassVar['IO.Verbosity'] = ...
        INFO: typing.ClassVar['IO.Verbosity'] = ...
        VERBOSE: typing.ClassVar['IO.Verbosity'] = ...
        DEBUG: typing.ClassVar['IO.Verbosity'] = ...
        name: str = ...
        @staticmethod
        def forName(string: str) -> 'IO.Verbosity': ...
        def toString(self) -> str: ...

class Main(groovy.lang.GroovyObject):
    @typing.overload
    def __init__(self, iO: IO): ...
    @typing.overload
    def __init__(self, iO: IO, compilerConfiguration: org.codehaus.groovy.control.CompilerConfiguration): ...
    def getGroovysh(self) -> 'Groovysh': ...
    @staticmethod
    def installAnsi() -> None: ...
    @staticmethod
    def main(*string: str) -> None: ...
    @staticmethod
    def setSystemProperty(string: str) -> None: ...
    @staticmethod
    def setTerminalType(string: str, boolean: bool) -> None: ...

class ParseCode(groovy.lang.GroovyObject):
    @staticmethod
    def getCOMPLETE() -> 'ParseCode': ...
    def getCode(self) -> int: ...
    @staticmethod
    def getERROR() -> 'ParseCode': ...
    @staticmethod
    def getINCOMPLETE() -> 'ParseCode': ...
    def toString(self) -> str: ...

class ParseStatus(groovy.lang.GroovyObject):
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, parseCode: ParseCode): ...
    @typing.overload
    def __init__(self, parseCode: ParseCode, throwable: java.lang.Throwable): ...
    def getCause(self) -> java.lang.Throwable: ...
    def getCode(self) -> ParseCode: ...

class Parser(groovy.lang.GroovyObject):
    def __init__(self): ...
    @staticmethod
    def getNEWLINE() -> str: ...
    def parse(self, collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]]) -> ParseStatus: ...

class Parsing:
    def parse(self, collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]]) -> ParseStatus: ...

class Shell(groovy.lang.GroovyObject):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iO: IO): ...
    def execute(self, string: str) -> typing.Any: ...
    @typing.overload
    def findCommand(self, string: str) -> Command: ...
    @typing.overload
    def findCommand(self, string: str, list: java.util.List[str]) -> Command: ...
    def getIo(self) -> IO: ...
    def getRegistry(self) -> CommandRegistry: ...
    def isExecutable(self, string: str) -> bool: ...
    @typing.overload
    def leftShift(self, string: str) -> typing.Any: ...
    @typing.overload
    def leftShift(self, command: Command) -> Command: ...
    def register(self, command: Command) -> Command: ...

class ShellRunner(java.lang.Runnable, groovy.lang.GroovyObject):
    def getBreakOnNull(self) -> bool: ...
    def getErrorHandler(self) -> groovy.lang.Closure: ...
    def getMetaClass(self) -> groovy.lang.MetaClass: ...
    def getProperty(self, string: str) -> typing.Any: ...
    def getRunning(self) -> bool: ...
    def getShell(self) -> Shell: ...
    def invokeMethod(self, string: str, object: typing.Any) -> typing.Any: ...
    def isBreakOnNull(self) -> bool: ...
    def isRunning(self) -> bool: ...
    def run(self) -> None: ...
    def setBreakOnNull(self, boolean: bool) -> None: ...
    def setErrorHandler(self, closure: groovy.lang.Closure) -> None: ...
    def setMetaClass(self, metaClass: groovy.lang.MetaClass) -> None: ...
    def setProperty(self, string: str, object: typing.Any) -> None: ...
    def setRunning(self, boolean: bool) -> None: ...
    class _closure1(groovy.lang.Closure, org.codehaus.groovy.runtime.GeneratedClosure):
        def __init__(self, object: typing.Any, object2: typing.Any): ...
        def doCall(self, object: typing.Any) -> typing.Any: ...

class CommandSupport(Command, groovy.lang.GroovyObject):
    def getAliases(self) -> java.util.List: ...
    def getCompleter(self) -> jline.console.completer.Completer: ...
    def getDescription(self) -> str: ...
    def getHelp(self) -> str: ...
    def getHidden(self) -> bool: ...
    def getMetaClass(self) -> groovy.lang.MetaClass: ...
    def getName(self) -> str: ...
    def getProperty(self, string: str) -> typing.Any: ...
    def getShortcut(self) -> str: ...
    def getUsage(self) -> str: ...
    def invokeMethod(self, string: str, object: typing.Any) -> typing.Any: ...
    def setHidden(self, boolean: bool) -> None: ...
    def setMetaClass(self, metaClass: groovy.lang.MetaClass) -> None: ...
    def setProperty(self, string: str, object: typing.Any) -> None: ...

class Groovysh(Shell):
    COLLECTED_BOUND_VARS_MAP_VARNAME: typing.ClassVar[str] = ...
    INTERPRETER_MODE_PREFERENCE_KEY: typing.ClassVar[str] = ...
    AUTOINDENT_PREFERENCE_KEY: typing.ClassVar[str] = ...
    COLORS_PREFERENCE_KEY: typing.ClassVar[str] = ...
    SANITIZE_PREFERENCE_KEY: typing.ClassVar[str] = ...
    SHOW_LAST_RESULT_PREFERENCE_KEY: typing.ClassVar[str] = ...
    METACLASS_COMPLETION_PREFIX_LENGTH_PREFERENCE_KEY: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, binding: groovy.lang.Binding, iO: IO): ...
    @typing.overload
    def __init__(self, classLoader: java.lang.ClassLoader, binding: groovy.lang.Binding, iO: IO): ...
    @typing.overload
    def __init__(self, classLoader: java.lang.ClassLoader, binding: groovy.lang.Binding, iO: IO, closure: groovy.lang.Closure): ...
    @typing.overload
    def __init__(self, classLoader: java.lang.ClassLoader, binding: groovy.lang.Binding, iO: IO, closure: groovy.lang.Closure, compilerConfiguration: org.codehaus.groovy.control.CompilerConfiguration): ...
    @typing.overload
    def __init__(self, iO: IO): ...
    @typing.overload
    def __init__(self, iO: IO, compilerConfiguration: org.codehaus.groovy.control.CompilerConfiguration): ...
    def displayBuffer(self, list: java.util.List) -> None: ...
    def displayWelcomeBanner(self, interactiveShellRunner: 'InteractiveShellRunner') -> None: ...
    def execute(self, string: str) -> typing.Any: ...
    def getBuffers(self) -> BufferManager: ...
    def getDefaultErrorHook(self) -> groovy.lang.Closure: ...
    def getDefaultResultHook(self) -> groovy.lang.Closure: ...
    def getErrorHook(self) -> groovy.lang.Closure: ...
    def getEvictedLine(self) -> str: ...
    def getHistory(self) -> jline.console.history.FileHistory: ...
    def getHistoryFull(self) -> bool: ...
    def getImportStatements(self) -> str: ...
    def getImports(self) -> java.util.List[str]: ...
    def getIndentPrefix(self) -> str: ...
    def getIndentSize(self) -> int: ...
    def getInterp(self) -> 'Interpreter': ...
    def getPackageHelper(self) -> org.codehaus.groovy.tools.shell.util.PackageHelper: ...
    def getParser(self) -> Parser: ...
    def getResultHook(self) -> groovy.lang.Closure: ...
    def getRunner(self) -> 'InteractiveShellRunner': ...
    def getUserStateDirectory(self) -> java.io.File: ...
    def isHistoryFull(self) -> bool: ...
    @staticmethod
    def isTypeOrMethodDeclaration(list: java.util.List[str]) -> bool: ...
    def renderPrompt(self) -> str: ...
    @typing.overload
    def run(self, string: str) -> int: ...
    @typing.overload
    def run(self, string: str, list: java.util.List[str]) -> int: ...
    def setErrorHook(self, closure: groovy.lang.Closure) -> None: ...
    def setEvictedLine(self, string: str) -> None: ...
    def setHistory(self, fileHistory: jline.console.history.FileHistory) -> None: ...
    def setHistoryFull(self, boolean: bool) -> None: ...
    def setIndentSize(self, int: int) -> None: ...
    def setPackageHelper(self, packageHelper: org.codehaus.groovy.tools.shell.util.PackageHelper) -> None: ...
    def setResultHook(self, closure: groovy.lang.Closure) -> None: ...
    def setRunner(self, interactiveShellRunner: 'InteractiveShellRunner') -> None: ...
    class _closure1(groovy.lang.Closure, org.codehaus.groovy.runtime.GeneratedClosure):
        def __init__(self, object: typing.Any, object2: typing.Any): ...
        @typing.overload
        def call(self) -> typing.Any: ...
        @typing.overload
        def call(self, *object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, object: typing.Any) -> typing.Any: ...
        def doCall(self, object: typing.Any) -> typing.Any: ...
    class _closure2(groovy.lang.Closure, org.codehaus.groovy.runtime.GeneratedClosure):
        def __init__(self, object: typing.Any, object2: typing.Any): ...
        @typing.overload
        def call(self) -> typing.Any: ...
        @typing.overload
        def call(self, object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, *object: typing.Any) -> typing.Any: ...
        @typing.overload
        def call(self, throwable: java.lang.Throwable) -> typing.Any: ...
        def doCall(self, throwable: java.lang.Throwable) -> typing.Any: ...

class InteractiveShellRunner(ShellRunner, java.lang.Runnable):
    def __init__(self, groovysh: Groovysh, closure: groovy.lang.Closure): ...
    def getCompleter(self) -> CommandsMultiCompleter: ...
    def getPrompt(self) -> groovy.lang.Closure: ...
    def getReader(self) -> jline.console.ConsoleReader: ...
    def getWrappedInputStream(self) -> org.codehaus.groovy.tools.shell.util.WrappedInputStream: ...
    def run(self) -> None: ...
    def setHistory(self, fileHistory: jline.console.history.FileHistory) -> None: ...
    def setReader(self, consoleReader: jline.console.ConsoleReader) -> None: ...
    def setWrappedInputStream(self, wrappedInputStream: org.codehaus.groovy.tools.shell.util.WrappedInputStream) -> None: ...

class Interpreter(Evaluator, groovy.lang.GroovyObject):
    @typing.overload
    def __init__(self, classLoader: java.lang.ClassLoader, binding: groovy.lang.Binding): ...
    @typing.overload
    def __init__(self, classLoader: java.lang.ClassLoader, binding: groovy.lang.Binding, compilerConfiguration: org.codehaus.groovy.control.CompilerConfiguration): ...
    def evaluate(self, collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]]) -> typing.Any: ...
    def getClassLoader(self) -> groovy.lang.GroovyClassLoader: ...
    def getContext(self) -> groovy.lang.Binding: ...
    @staticmethod
    def getSCRIPT_FILENAME() -> str: ...

class RelaxedParser(Parsing, groovy.lang.GroovyObject):
    def __init__(self): ...
    def parse(self, collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]]) -> ParseStatus: ...

class RigidParser(Parsing, groovy.lang.GroovyObject):
    def __init__(self): ...
    @staticmethod
    def getSCRIPT_FILENAME() -> str: ...
    @staticmethod
    def hasUnmatchedOpenBracketOrParen(string: str) -> bool: ...
    @staticmethod
    def ignoreSyntaxErrorForLineEnding(string: str) -> bool: ...
    @staticmethod
    def isAnnotationExpression(compilationFailedException: org.codehaus.groovy.control.CompilationFailedException, string: str) -> bool: ...
    def parse(self, collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]]) -> ParseStatus: ...

class CommandAlias(CommandSupport):
    def __init__(self, groovysh: Groovysh, string: str, string2: str, string3: str): ...
    def execute(self, list: java.util.List[str]) -> typing.Any: ...
    def getDescription(self) -> str: ...
    def getHelp(self) -> str: ...
    def getHidden(self) -> bool: ...
    def getTarget(self) -> Command: ...
    def getTargetName(self) -> str: ...
    def getUsage(self) -> str: ...

class ComplexCommandSupport(CommandSupport):
    def execute(self, list: java.util.List[str]) -> typing.Any: ...
    def getDo_all(self) -> typing.Any: ...
    def setDo_all(self, object: typing.Any) -> None: ...
    class _closure1(groovy.lang.Closure, org.codehaus.groovy.runtime.GeneratedClosure):
        def __init__(self, object: typing.Any, object2: typing.Any): ...
        @typing.overload
        def doCall(self) -> typing.Any: ...
        @typing.overload
        def doCall(self, object: typing.Any) -> typing.Any: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.tools.shell")``.

    AnsiDetector: typing.Type[AnsiDetector]
    BufferManager: typing.Type[BufferManager]
    Command: typing.Type[Command]
    CommandAlias: typing.Type[CommandAlias]
    CommandException: typing.Type[CommandException]
    CommandRegistry: typing.Type[CommandRegistry]
    CommandSupport: typing.Type[CommandSupport]
    CommandsMultiCompleter: typing.Type[CommandsMultiCompleter]
    ComplexCommandSupport: typing.Type[ComplexCommandSupport]
    Evaluator: typing.Type[Evaluator]
    ExitNotification: typing.Type[ExitNotification]
    Groovysh: typing.Type[Groovysh]
    IO: typing.Type[IO]
    InteractiveShellRunner: typing.Type[InteractiveShellRunner]
    Interpreter: typing.Type[Interpreter]
    Main: typing.Type[Main]
    ParseCode: typing.Type[ParseCode]
    ParseStatus: typing.Type[ParseStatus]
    Parser: typing.Type[Parser]
    Parsing: typing.Type[Parsing]
    RelaxedParser: typing.Type[RelaxedParser]
    RigidParser: typing.Type[RigidParser]
    Shell: typing.Type[Shell]
    ShellRunner: typing.Type[ShellRunner]
    commands: org.codehaus.groovy.tools.shell.commands.__module_protocol__
    completion: org.codehaus.groovy.tools.shell.completion.__module_protocol__
    util: org.codehaus.groovy.tools.shell.util.__module_protocol__
