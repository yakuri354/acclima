
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import java.io
import java.lang
import java.net
import java.security
import java.util
import java.util.jar
import java.util.prefs
import java.util.regex
import jline.console.completer
import jpype
import jpype.protocol
import org.codehaus.groovy.antlr
import org.codehaus.groovy.antlr.parser
import org.codehaus.groovy.ast
import org.codehaus.groovy.ast.expr
import org.codehaus.groovy.classgen
import org.codehaus.groovy.control
import org.codehaus.groovy.tools.shell
import typing



class CachedPackage(groovy.lang.GroovyObject):
    def __init__(self, string: str, set: java.util.Set[java.net.URL]): ...
    def getChecked(self) -> bool: ...
    def getChildPackages(self) -> java.util.Map[str, 'CachedPackage']: ...
    def getContainsClasses(self) -> bool: ...
    def getName(self) -> str: ...
    def getSources(self) -> java.util.Set[java.net.URL]: ...
    def isChecked(self) -> bool: ...
    def isContainsClasses(self) -> bool: ...
    def setChecked(self, boolean: bool) -> None: ...
    def setChildPackages(self, map: typing.Union[java.util.Map[str, 'CachedPackage'], typing.Mapping[str, 'CachedPackage']]) -> None: ...
    def setContainsClasses(self, boolean: bool) -> None: ...
    def setName(self, string: str) -> None: ...
    def setSources(self, set: java.util.Set[java.net.URL]) -> None: ...

class CommandArgumentParser(groovy.lang.GroovyObject):
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def parseLine(string: str) -> java.util.List[str]: ...
    @typing.overload
    @staticmethod
    def parseLine(string: str, int: int) -> java.util.List[str]: ...

class CurlyCountingGroovyLexer(org.codehaus.groovy.antlr.parser.GroovyLexer, groovy.lang.GroovyObject):
    @staticmethod
    def createGroovyLexer(string: str) -> 'CurlyCountingGroovyLexer': ...
    def getParenLevel(self) -> int: ...
    def toList(self) -> java.util.List[org.codehaus.groovy.antlr.GroovySourceToken]: ...
    def uponEOF(self) -> None: ...

class DefaultCommandsRegistrar(groovy.lang.GroovyObject):
    def __init__(self, shell: org.codehaus.groovy.tools.shell.Shell): ...
    def register(self) -> None: ...

class Logger:
    io: typing.ClassVar[org.codehaus.groovy.tools.shell.IO] = ...
    name: str = ...
    @typing.overload
    @staticmethod
    def create(class_: typing.Type) -> 'Logger': ...
    @typing.overload
    @staticmethod
    def create(class_: typing.Type, string: str) -> 'Logger': ...
    @typing.overload
    def debug(self, object: typing.Any) -> None: ...
    @typing.overload
    def debug(self, object: typing.Any, throwable: java.lang.Throwable) -> None: ...
    @typing.overload
    def error(self, object: typing.Any) -> None: ...
    @typing.overload
    def error(self, object: typing.Any, throwable: java.lang.Throwable) -> None: ...
    def isDebug(self) -> bool: ...
    def isDebugEnabled(self) -> bool: ...
    @typing.overload
    def warn(self, object: typing.Any) -> None: ...
    @typing.overload
    def warn(self, object: typing.Any, throwable: java.lang.Throwable) -> None: ...

class MessageSource(groovy.lang.GroovyObjectSupport):
    @typing.overload
    def __init__(self, class_: typing.Type): ...
    @typing.overload
    def __init__(self, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, stringArray: typing.Union[typing.List[str], jpype.JArray]): ...
    def format(self, string: str, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> str: ...
    def getMessage(self, string: str) -> str: ...
    def getProperty(self, string: str) -> typing.Any: ...

class NoExitSecurityManager(java.lang.SecurityManager, groovy.lang.GroovyObject):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, securityManager: java.lang.SecurityManager): ...
    def checkExit(self, int: int) -> None: ...
    @typing.overload
    def checkPermission(self, permission: java.security.Permission, object: typing.Any) -> None: ...
    @typing.overload
    def checkPermission(self, permission: java.security.Permission) -> None: ...

class PackageHelper:
    IMPORT_COMPLETION_PREFERENCE_KEY: typing.ClassVar[str] = ...
    def getContents(self, string: str) -> java.util.Set[str]: ...
    def reset(self) -> None: ...

class Preferences:
    verbosity: typing.ClassVar[org.codehaus.groovy.tools.shell.IO.Verbosity] = ...
    VERBOSITY_KEY: typing.ClassVar[str] = ...
    SHOW_LAST_RESULT_KEY: typing.ClassVar[str] = ...
    SANITIZE_STACK_TRACE_KEY: typing.ClassVar[str] = ...
    EDITOR_KEY: typing.ClassVar[str] = ...
    PARSER_FLAVOR_KEY: typing.ClassVar[str] = ...
    PARSER_RIGID: typing.ClassVar[str] = ...
    PARSER_RELAXED: typing.ClassVar[str] = ...
    def __init__(self): ...
    @staticmethod
    def addChangeListener(preferenceChangeListener: typing.Union[java.util.prefs.PreferenceChangeListener, typing.Callable]) -> None: ...
    @staticmethod
    def clear() -> None: ...
    @typing.overload
    @staticmethod
    def get(string: str) -> str: ...
    @typing.overload
    @staticmethod
    def get(string: str, string2: str) -> str: ...
    @staticmethod
    def getEditor() -> str: ...
    @staticmethod
    def getParserFlavor() -> str: ...
    @staticmethod
    def getSanitizeStackTrace() -> bool: ...
    @staticmethod
    def getShowLastResult() -> bool: ...
    @staticmethod
    def keys() -> typing.MutableSequence[str]: ...
    @staticmethod
    def put(string: str, string2: str) -> None: ...

class ScriptVariableAnalyzer(groovy.lang.GroovyObject):
    def __init__(self): ...
    @staticmethod
    def getBoundVars(string: str, classLoader: java.lang.ClassLoader) -> java.util.Set[str]: ...
    class VariableVisitor(org.codehaus.groovy.ast.ClassCodeVisitorSupport, org.codehaus.groovy.ast.GroovyClassVisitor, groovy.lang.GroovyObject):
        def __init__(self): ...
        def getBound(self) -> java.util.Set[str]: ...
        def getUnbound(self) -> java.util.Set[str]: ...
        def setBound(self, set: java.util.Set[str]) -> None: ...
        def setUnbound(self, set: java.util.Set[str]) -> None: ...
        def visitVariableExpression(self, variableExpression: org.codehaus.groovy.ast.expr.VariableExpression) -> None: ...
    class VisitorClassLoader(groovy.lang.GroovyClassLoader, groovy.lang.GroovyObject):
        def __init__(self, groovyClassVisitor: org.codehaus.groovy.ast.GroovyClassVisitor, classLoader: java.lang.ClassLoader): ...
        def getVisitor(self) -> org.codehaus.groovy.ast.GroovyClassVisitor: ...
    class VisitorSourceOperation(org.codehaus.groovy.control.CompilationUnit.PrimaryClassNodeOperation, groovy.lang.GroovyObject):
        def __init__(self, groovyClassVisitor: org.codehaus.groovy.ast.GroovyClassVisitor): ...
        def call(self, sourceUnit: org.codehaus.groovy.control.SourceUnit, generatorContext: org.codehaus.groovy.classgen.GeneratorContext, classNode: org.codehaus.groovy.ast.ClassNode) -> None: ...
        def getVisitor(self) -> org.codehaus.groovy.ast.GroovyClassVisitor: ...

class SimpleCompletor(jline.console.completer.Completer, groovy.lang.GroovyObject):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, closure: groovy.lang.Closure): ...
    @typing.overload
    def __init__(self, *string: str): ...
    def add(self, string: str) -> None: ...
    def addCandidateString(self, string: str) -> None: ...
    def complete(self, string: str, int: int, list: java.util.List[typing.Union[java.lang.CharSequence, str]]) -> int: ...
    def getCandidates(self) -> java.util.SortedSet[str]: ...
    def getWithBlank(self) -> bool: ...
    def isWithBlank(self) -> bool: ...
    def leftShift(self, string: str) -> typing.Any: ...
    def setCandidateStrings(self, *string: str) -> None: ...
    def setCandidates(self, sortedSet: java.util.SortedSet[str]) -> None: ...
    def setWithBlank(self, boolean: bool) -> None: ...

class WrappedInputStream(java.io.InputStream, java.io.Closeable, groovy.lang.GroovyObject):
    def __init__(self, inputStream: java.io.InputStream): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def getInserted(self) -> java.io.ByteArrayInputStream: ...
    def getWrapped(self) -> java.io.InputStream: ...
    def insert(self, string: str) -> None: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, *byte: int) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int) -> int: ...
    def reset(self) -> None: ...
    def setInserted(self, byteArrayInputStream: java.io.ByteArrayInputStream) -> None: ...
    def skip(self, long: int) -> int: ...

class XmlCommandRegistrar(groovy.lang.GroovyObject):
    def __init__(self, shell: org.codehaus.groovy.tools.shell.Shell, classLoader: java.lang.ClassLoader): ...
    def register(self, uRL: java.net.URL) -> None: ...

class PackageHelperImpl(java.util.prefs.PreferenceChangeListener, PackageHelper, groovy.lang.GroovyObject):
    NAME_PATTERN: typing.ClassVar[java.util.regex.Pattern] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classLoader: java.lang.ClassLoader): ...
    @staticmethod
    def collectPackageNamesFromFolderRecursive(file: typing.Union[java.io.File, jpype.protocol.SupportsPath], string: str, set: java.util.Set[str]) -> java.util.Collection[str]: ...
    @staticmethod
    def getClassnames(set: java.util.Set[java.net.URL], string: str) -> java.util.Set[str]: ...
    def getContents(self, string: str) -> java.util.Set[str]: ...
    def getGroovyClassLoader(self) -> java.lang.ClassLoader: ...
    @staticmethod
    def getPackageNames(uRL: java.net.URL) -> java.util.Collection[str]: ...
    @staticmethod
    def getPackageNamesFromJar(jarFile: java.util.jar.JarFile) -> java.util.Collection[str]: ...
    def getRootPackages(self) -> java.util.Map[str, CachedPackage]: ...
    @staticmethod
    def mergeNewPackages(collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]], uRL: java.net.URL, map: typing.Union[java.util.Map[str, CachedPackage], typing.Mapping[str, CachedPackage]]) -> typing.Any: ...
    def preferenceChange(self, preferenceChangeEvent: java.util.prefs.PreferenceChangeEvent) -> None: ...
    def reset(self) -> None: ...
    def setRootPackages(self, map: typing.Union[java.util.Map[str, CachedPackage], typing.Mapping[str, CachedPackage]]) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.tools.shell.util")``.

    CachedPackage: typing.Type[CachedPackage]
    CommandArgumentParser: typing.Type[CommandArgumentParser]
    CurlyCountingGroovyLexer: typing.Type[CurlyCountingGroovyLexer]
    DefaultCommandsRegistrar: typing.Type[DefaultCommandsRegistrar]
    Logger: typing.Type[Logger]
    MessageSource: typing.Type[MessageSource]
    NoExitSecurityManager: typing.Type[NoExitSecurityManager]
    PackageHelper: typing.Type[PackageHelper]
    PackageHelperImpl: typing.Type[PackageHelperImpl]
    Preferences: typing.Type[Preferences]
    ScriptVariableAnalyzer: typing.Type[ScriptVariableAnalyzer]
    SimpleCompletor: typing.Type[SimpleCompletor]
    WrappedInputStream: typing.Type[WrappedInputStream]
    XmlCommandRegistrar: typing.Type[XmlCommandRegistrar]
