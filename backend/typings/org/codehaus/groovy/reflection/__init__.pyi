
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import groovyjarjarasm.asm
import java.io
import java.lang
import java.lang.ref
import java.lang.reflect
import java.util
import jpype
import org
import org.codehaus.groovy.reflection.android
import org.codehaus.groovy.reflection.stdclasses
import org.codehaus.groovy.reflection.v7
import org.codehaus.groovy.runtime.callsite
import org.codehaus.groovy.util
import typing



class CacheAccessControlException(groovy.lang.GroovyRuntimeException):
    def __init__(self, string: str, throwable: java.lang.Throwable): ...

class CachedClass:
    classInfo: 'ClassInfo' = ...
    mopMethods: typing.MutableSequence['CachedMethod'] = ...
    EMPTY_ARRAY: typing.ClassVar[typing.MutableSequence['CachedClass']] = ...
    isArray: bool = ...
    isPrimitive: bool = ...
    modifiers: int = ...
    isInterface: bool = ...
    isNumber: bool = ...
    def __init__(self, class_: typing.Type, classInfo: 'ClassInfo'): ...
    def addNewMopMethods(self, list: java.util.List[groovy.lang.MetaMethod]) -> None: ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def getCachedClass(self) -> 'CachedClass': ...
    def getCachedSuperClass(self) -> 'CachedClass': ...
    def getCallSiteLoader(self) -> org.codehaus.groovy.runtime.callsite.CallSiteClassLoader: ...
    def getConstructors(self) -> typing.MutableSequence['CachedConstructor']: ...
    def getDeclaredInterfaces(self) -> java.util.Set['CachedClass']: ...
    def getFields(self) -> typing.MutableSequence['CachedField']: ...
    def getHierarchy(self) -> java.util.Collection['ClassInfo']: ...
    def getInterfaces(self) -> java.util.Set['CachedClass']: ...
    def getMethods(self) -> typing.MutableSequence['CachedMethod']: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getNewMetaMethods(self) -> typing.MutableSequence[groovy.lang.MetaMethod]: ...
    def getSuperClassDistance(self) -> int: ...
    def getTheClass(self) -> typing.Type: ...
    def getTypeDescription(self) -> str: ...
    def hashCode(self) -> int: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...
    def isInterface(self) -> bool: ...
    def isPrimitive(self) -> bool: ...
    def isVoid(self) -> bool: ...
    def searchMethods(self, string: str, cachedClassArray: typing.Union[typing.List['CachedClass'], jpype.JArray]) -> 'CachedMethod': ...
    def setNewMopMethods(self, list: java.util.List[groovy.lang.MetaMethod]) -> None: ...
    def toString(self) -> str: ...
    class CachedMethodComparatorByName(java.util.Comparator):
        INSTANCE: typing.ClassVar[java.util.Comparator] = ...
        def __init__(self): ...
        def compare(self, object: typing.Any, object2: typing.Any) -> int: ...
    class CachedMethodComparatorWithString(java.util.Comparator):
        INSTANCE: typing.ClassVar[java.util.Comparator] = ...
        def __init__(self): ...
        def compare(self, object: typing.Any, object2: typing.Any) -> int: ...

class CachedField(groovy.lang.MetaProperty):
    field: java.lang.reflect.Field = ...
    def __init__(self, field: java.lang.reflect.Field): ...
    def getModifiers(self) -> int: ...
    def getProperty(self, object: typing.Any) -> typing.Any: ...
    def isFinal(self) -> bool: ...
    def isStatic(self) -> bool: ...
    def setProperty(self, object: typing.Any, object2: typing.Any) -> None: ...

class CachedMethod(groovy.lang.MetaMethod, java.lang.Comparable):
    EMPTY_ARRAY: typing.ClassVar[typing.MutableSequence['CachedMethod']] = ...
    cachedClass: CachedClass = ...
    @typing.overload
    def __init__(self, method: java.lang.reflect.Method): ...
    @typing.overload
    def __init__(self, cachedClass: CachedClass, method: java.lang.reflect.Method): ...
    def compareTo(self, object: typing.Any) -> int: ...
    def createPogoMetaMethodSite(self, callSite: org.codehaus.groovy.runtime.callsite.CallSite, metaClassImpl: groovy.lang.MetaClassImpl, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]) -> org.codehaus.groovy.runtime.callsite.CallSite: ...
    def createPojoMetaMethodSite(self, callSite: org.codehaus.groovy.runtime.callsite.CallSite, metaClassImpl: groovy.lang.MetaClassImpl, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]) -> org.codehaus.groovy.runtime.callsite.CallSite: ...
    def createStaticMetaMethodSite(self, callSite: org.codehaus.groovy.runtime.callsite.CallSite, metaClassImpl: groovy.lang.MetaClassImpl, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]) -> org.codehaus.groovy.runtime.callsite.CallSite: ...
    def equals(self, object: typing.Any) -> bool: ...
    @staticmethod
    def find(method: java.lang.reflect.Method) -> 'CachedMethod': ...
    def getCachedMethod(self) -> java.lang.reflect.Method: ...
    def getDeclaringClass(self) -> CachedClass: ...
    def getDescriptor(self) -> str: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getParamTypes(self) -> 'ParameterTypes': ...
    def getParamsCount(self) -> int: ...
    def getReturnType(self) -> typing.Type: ...
    def getSignature(self) -> str: ...
    def hashCode(self) -> int: ...
    def invoke(self, object: typing.Any, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.Any: ...
    def isStatic(self) -> bool: ...
    def setAccessible(self) -> java.lang.reflect.Method: ...
    def toString(self) -> str: ...

class ClassInfo(org.codehaus.groovy.util.Finalizable):
    hash: int = ...
    @staticmethod
    def clearModifiedExpandos() -> None: ...
    def finalizeReference(self) -> None: ...
    @staticmethod
    def fullSize() -> int: ...
    @staticmethod
    def getAllClassInfo() -> java.util.Collection['ClassInfo']: ...
    def getArtifactClassLoader(self) -> 'ClassLoaderForClassArtifacts': ...
    def getCachedClass(self) -> CachedClass: ...
    @staticmethod
    def getClassInfo(class_: typing.Type) -> 'ClassInfo': ...
    @typing.overload
    def getMetaClass(self) -> groovy.lang.MetaClass: ...
    @typing.overload
    def getMetaClass(self, object: typing.Any) -> groovy.lang.MetaClass: ...
    def getMetaClassForClass(self) -> groovy.lang.MetaClass: ...
    def getModifiedExpando(self) -> groovy.lang.ExpandoMetaClass: ...
    def getPerInstanceMetaClass(self, object: typing.Any) -> groovy.lang.MetaClass: ...
    def getStrongMetaClass(self) -> groovy.lang.MetaClass: ...
    def getTheClass(self) -> typing.Type[typing.Any]: ...
    def getVersion(self) -> int: ...
    def getWeakMetaClass(self) -> groovy.lang.MetaClass: ...
    def hasPerInstanceMetaClasses(self) -> bool: ...
    def incVersion(self) -> None: ...
    def lock(self) -> None: ...
    @staticmethod
    def onAllClassInfo(classInfoAction: 'ClassInfo.ClassInfoAction') -> None: ...
    @staticmethod
    def remove(class_: typing.Type[typing.Any]) -> None: ...
    def setPerInstanceMetaClass(self, object: typing.Any, metaClass: groovy.lang.MetaClass) -> None: ...
    def setStrongMetaClass(self, metaClass: groovy.lang.MetaClass) -> None: ...
    def setWeakMetaClass(self, metaClass: groovy.lang.MetaClass) -> None: ...
    @staticmethod
    def size() -> int: ...
    def unlock(self) -> None: ...
    class ClassInfoAction:
        def onClassInfo(self, classInfo: 'ClassInfo') -> None: ...

class ClassLoaderForClassArtifacts(java.lang.ClassLoader):
    klazz: java.lang.ref.SoftReference = ...
    def __init__(self, class_: typing.Type): ...
    def createClassName(self, method: java.lang.reflect.Method) -> str: ...
    def define(self, string: str, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> typing.Type: ...
    def defineClassAndGetConstructor(self, string: str, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> java.lang.reflect.Constructor: ...
    def loadClass(self, string: str) -> typing.Type: ...

_GroovyClassValue__ComputeValue__T = typing.TypeVar('_GroovyClassValue__ComputeValue__T')  # <T>
_GroovyClassValue__T = typing.TypeVar('_GroovyClassValue__T')  # <T>
class GroovyClassValue(typing.Generic[_GroovyClassValue__T]):
    def get(self, class_: typing.Type[typing.Any]) -> _GroovyClassValue__T: ...
    def remove(self, class_: typing.Type[typing.Any]) -> None: ...
    class ComputeValue(typing.Generic[_GroovyClassValue__ComputeValue__T]):
        def computeValue(self, class_: typing.Type[typing.Any]) -> _GroovyClassValue__ComputeValue__T: ...

class MixinInMetaClass(org.codehaus.groovy.util.ManagedConcurrentMap):
    def __init__(self, expandoMetaClass: groovy.lang.ExpandoMetaClass, cachedClass: CachedClass): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getInstanceClass(self) -> CachedClass: ...
    def getMixinClass(self) -> CachedClass: ...
    def getMixinInstance(self, object: typing.Any) -> typing.Any: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def mixinClassesToMetaClass(metaClass: groovy.lang.MetaClass, list: java.util.List[typing.Type]) -> None: ...
    def setMixinInstance(self, object: typing.Any, object2: typing.Any) -> None: ...

class ParameterTypes:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]): ...
    @typing.overload
    def __init__(self, stringArray: typing.Union[typing.List[str], jpype.JArray]): ...
    @typing.overload
    def __init__(self, cachedClassArray: typing.Union[typing.List[CachedClass], jpype.JArray]): ...
    def coerceArgumentsToClasses(self, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.MutableSequence[typing.Any]: ...
    def correctArguments(self, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.MutableSequence[typing.Any]: ...
    def getNativeParameterTypes(self) -> typing.MutableSequence[typing.Type]: ...
    def getParameterTypes(self) -> typing.MutableSequence[CachedClass]: ...
    @typing.overload
    def isValidExactMethod(self, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]) -> bool: ...
    @typing.overload
    def isValidExactMethod(self, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> bool: ...
    @typing.overload
    def isValidMethod(self, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]) -> bool: ...
    @typing.overload
    def isValidMethod(self, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> bool: ...
    @typing.overload
    def isVargsMethod(self) -> bool: ...
    @typing.overload
    def isVargsMethod(self, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> bool: ...

class ReflectionCache:
    OBJECT_CLASS: typing.ClassVar[CachedClass] = ...
    OBJECT_ARRAY_CLASS: typing.ClassVar[CachedClass] = ...
    def __init__(self): ...
    @staticmethod
    def autoboxType(class_: typing.Type) -> typing.Type: ...
    @staticmethod
    def getCachedClass(class_: typing.Type) -> CachedClass: ...
    @staticmethod
    def getMOPMethodName(cachedClass: CachedClass, string: str, boolean: bool) -> str: ...
    @staticmethod
    def isArray(class_: typing.Type) -> bool: ...
    @staticmethod
    def isAssignableFrom(class_: typing.Type, class2: typing.Type) -> bool: ...

class ReflectionUtils:
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def getCallingClass() -> typing.Type: ...
    @typing.overload
    @staticmethod
    def getCallingClass(int: int) -> typing.Type: ...
    @typing.overload
    @staticmethod
    def getCallingClass(int: int, collection: typing.Union[java.util.Collection[str], typing.Sequence[str], typing.Set[str]]) -> typing.Type: ...
    @staticmethod
    def isCallingClassReflectionAvailable() -> bool: ...

class SunClassLoader(java.lang.ClassLoader, groovyjarjarasm.asm.Opcodes):
    def doesKnow(self, string: str) -> typing.Type: ...

class CachedConstructor(ParameterTypes):
    cachedConstructor: java.lang.reflect.Constructor = ...
    @typing.overload
    def __init__(self, constructor: java.lang.reflect.Constructor): ...
    @typing.overload
    def __init__(self, cachedClass: CachedClass, constructor: java.lang.reflect.Constructor): ...
    def doConstructorInvoke(self, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.Any: ...
    @staticmethod
    def find(constructor: java.lang.reflect.Constructor) -> 'CachedConstructor': ...
    def getCachedClass(self) -> CachedClass: ...
    def getModifiers(self) -> int: ...
    def invoke(self, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.Any: ...

class GeneratedMetaMethod(groovy.lang.MetaMethod):
    def __init__(self, string: str, cachedClass: CachedClass, class_: typing.Type, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]): ...
    def getDeclaringClass(self) -> CachedClass: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getReturnType(self) -> typing.Type: ...
    class DgmMethodRecord(java.io.Serializable):
        className: str = ...
        methodName: str = ...
        returnType: typing.Type = ...
        parameters: typing.MutableSequence[typing.Type] = ...
        def __init__(self): ...
        @staticmethod
        def loadDgmInfo() -> java.util.List['GeneratedMetaMethod.DgmMethodRecord']: ...
        @staticmethod
        def saveDgmInfo(list: java.util.List['GeneratedMetaMethod.DgmMethodRecord'], string: str) -> None: ...
    class Proxy(org.codehaus.groovy.reflection.GeneratedMetaMethod):
        def __init__(self, string: str, string2: str, cachedClass: CachedClass, class_: typing.Type, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]): ...
        def doMethodInvoke(self, object: typing.Any, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.Any: ...
        def invoke(self, object: typing.Any, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> typing.Any: ...
        @typing.overload
        def isValidMethod(self, classArray: typing.Union[typing.List[typing.Type], jpype.JArray]) -> bool: ...
        @typing.overload
        def isValidMethod(self, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> bool: ...
        def proxy(self) -> groovy.lang.MetaMethod: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.reflection")``.

    CacheAccessControlException: typing.Type[CacheAccessControlException]
    CachedClass: typing.Type[CachedClass]
    CachedConstructor: typing.Type[CachedConstructor]
    CachedField: typing.Type[CachedField]
    CachedMethod: typing.Type[CachedMethod]
    ClassInfo: typing.Type[ClassInfo]
    ClassLoaderForClassArtifacts: typing.Type[ClassLoaderForClassArtifacts]
    GeneratedMetaMethod: typing.Type[GeneratedMetaMethod]
    GroovyClassValue: typing.Type[GroovyClassValue]
    MixinInMetaClass: typing.Type[MixinInMetaClass]
    ParameterTypes: typing.Type[ParameterTypes]
    ReflectionCache: typing.Type[ReflectionCache]
    ReflectionUtils: typing.Type[ReflectionUtils]
    SunClassLoader: typing.Type[SunClassLoader]
    android: org.codehaus.groovy.reflection.android.__module_protocol__
    stdclasses: org.codehaus.groovy.reflection.stdclasses.__module_protocol__
    v7: org.codehaus.groovy.reflection.v7.__module_protocol__
