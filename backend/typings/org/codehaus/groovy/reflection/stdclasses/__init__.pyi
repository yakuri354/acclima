
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import groovy.lang
import java.lang.reflect
import org.codehaus.groovy.reflection
import typing



class ArrayCachedClass(org.codehaus.groovy.reflection.CachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...

class BooleanCachedClass(org.codehaus.groovy.reflection.CachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo, boolean: bool): ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class CachedClosureClass(org.codehaus.groovy.reflection.CachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo): ...
    def getMaximumNumberOfParameters(self) -> int: ...
    def getParameterTypes(self) -> typing.MutableSequence[typing.Type]: ...

class CachedSAMClass(org.codehaus.groovy.reflection.CachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def coerceToSAM(closure: groovy.lang.Closure, method: java.lang.reflect.Method, class_: typing.Type) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def coerceToSAM(closure: groovy.lang.Closure, method: java.lang.reflect.Method, class_: typing.Type, boolean: bool) -> typing.Any: ...
    @staticmethod
    def getSAMMethod(class_: typing.Type[typing.Any]) -> java.lang.reflect.Method: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...

class CharacterCachedClass(org.codehaus.groovy.reflection.CachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo, boolean: bool): ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class NumberCachedClass(org.codehaus.groovy.reflection.CachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...

class ObjectCachedClass(org.codehaus.groovy.reflection.CachedClass):
    def __init__(self, classInfo: org.codehaus.groovy.reflection.ClassInfo): ...
    def getCachedSuperClass(self) -> org.codehaus.groovy.reflection.CachedClass: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...

class StringCachedClass(org.codehaus.groovy.reflection.CachedClass):
    def __init__(self, classInfo: org.codehaus.groovy.reflection.ClassInfo): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class BigIntegerCachedClass(NumberCachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo): ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class ByteCachedClass(NumberCachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo, boolean: bool): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class DoubleCachedClass(NumberCachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo, boolean: bool): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class FloatCachedClass(NumberCachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo, boolean: bool): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class IntegerCachedClass(NumberCachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo, boolean: bool): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class LongCachedClass(NumberCachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo, boolean: bool): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class ShortCachedClass(NumberCachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo, boolean: bool): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def isAssignableFrom(self, class_: typing.Type) -> bool: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...

class BigDecimalCachedClass(DoubleCachedClass):
    def __init__(self, class_: typing.Type, classInfo: org.codehaus.groovy.reflection.ClassInfo): ...
    def coerceArgument(self, object: typing.Any) -> typing.Any: ...
    def isDirectlyAssignable(self, object: typing.Any) -> bool: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.codehaus.groovy.reflection.stdclasses")``.

    ArrayCachedClass: typing.Type[ArrayCachedClass]
    BigDecimalCachedClass: typing.Type[BigDecimalCachedClass]
    BigIntegerCachedClass: typing.Type[BigIntegerCachedClass]
    BooleanCachedClass: typing.Type[BooleanCachedClass]
    ByteCachedClass: typing.Type[ByteCachedClass]
    CachedClosureClass: typing.Type[CachedClosureClass]
    CachedSAMClass: typing.Type[CachedSAMClass]
    CharacterCachedClass: typing.Type[CharacterCachedClass]
    DoubleCachedClass: typing.Type[DoubleCachedClass]
    FloatCachedClass: typing.Type[FloatCachedClass]
    IntegerCachedClass: typing.Type[IntegerCachedClass]
    LongCachedClass: typing.Type[LongCachedClass]
    NumberCachedClass: typing.Type[NumberCachedClass]
    ObjectCachedClass: typing.Type[ObjectCachedClass]
    ShortCachedClass: typing.Type[ShortCachedClass]
    StringCachedClass: typing.Type[StringCachedClass]
