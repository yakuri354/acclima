
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.util
import org.locationtech.jts.geom
import org.locationtech.jts.index
import org.locationtech.jts.index.chain
import org.locationtech.jts.noding
import typing



class GeometryNoder:
    def __init__(self, precisionModel: org.locationtech.jts.geom.PrecisionModel): ...
    def node(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> java.util.List: ...
    def setValidate(self, boolean: bool) -> None: ...

class HotPixel:
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, double: float): ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getScaleFactor(self) -> float: ...
    def getWidth(self) -> float: ...
    @typing.overload
    def intersects(self, coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @typing.overload
    def intersects(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> bool: ...
    def isNode(self) -> bool: ...
    def setToNode(self) -> None: ...
    def toString(self) -> str: ...

class MCIndexPointSnapper:
    def __init__(self, spatialIndex: org.locationtech.jts.index.SpatialIndex): ...
    def getSafeEnvelope(self, hotPixel: HotPixel) -> org.locationtech.jts.geom.Envelope: ...
    @typing.overload
    def snap(self, hotPixel: HotPixel) -> bool: ...
    @typing.overload
    def snap(self, hotPixel: HotPixel, segmentString: org.locationtech.jts.noding.SegmentString, int: int) -> bool: ...
    class HotPixelSnapAction(org.locationtech.jts.index.chain.MonotoneChainSelectAction):
        def __init__(self, hotPixel: HotPixel, segmentString: org.locationtech.jts.noding.SegmentString, int: int): ...
        def addSnappedNode(self, hotPixel: HotPixel, nodedSegmentString: org.locationtech.jts.noding.NodedSegmentString, int: int) -> bool: ...
        def isNodeAdded(self) -> bool: ...
        @typing.overload
        def select(self, lineSegment: org.locationtech.jts.geom.LineSegment) -> None: ...
        @typing.overload
        def select(self, monotoneChain: org.locationtech.jts.index.chain.MonotoneChain, int: int) -> None: ...

class MCIndexSnapRounder(org.locationtech.jts.noding.Noder):
    def __init__(self, precisionModel: org.locationtech.jts.geom.PrecisionModel): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def computeVertexSnaps(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...

class SnapRoundingIntersectionAdder(org.locationtech.jts.noding.SegmentIntersector):
    def __init__(self, double: float): ...
    def getIntersections(self) -> java.util.List[org.locationtech.jts.geom.Coordinate]: ...
    def isDone(self) -> bool: ...
    def processIntersections(self, segmentString: org.locationtech.jts.noding.SegmentString, int: int, segmentString2: org.locationtech.jts.noding.SegmentString, int2: int) -> None: ...

class SnapRoundingNoder(org.locationtech.jts.noding.Noder):
    def __init__(self, precisionModel: org.locationtech.jts.geom.PrecisionModel): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.noding.snapround")``.

    GeometryNoder: typing.Type[GeometryNoder]
    HotPixel: typing.Type[HotPixel]
    MCIndexPointSnapper: typing.Type[MCIndexPointSnapper]
    MCIndexSnapRounder: typing.Type[MCIndexSnapRounder]
    SnapRoundingIntersectionAdder: typing.Type[SnapRoundingIntersectionAdder]
    SnapRoundingNoder: typing.Type[SnapRoundingNoder]
