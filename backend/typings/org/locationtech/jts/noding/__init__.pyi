
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jpype
import org.locationtech.jts.algorithm
import org.locationtech.jts.geom
import org.locationtech.jts.index
import org.locationtech.jts.index.chain
import org.locationtech.jts.noding.snap
import org.locationtech.jts.noding.snapround
import typing



class FastNodingValidator:
    def __init__(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]): ...
    def checkValid(self) -> None: ...
    @staticmethod
    def computeIntersections(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> java.util.List: ...
    def getErrorMessage(self) -> str: ...
    def getIntersections(self) -> java.util.List: ...
    def isValid(self) -> bool: ...
    def setFindAllIntersections(self, boolean: bool) -> None: ...

class FastSegmentSetIntersectionFinder:
    def __init__(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]): ...
    def getSegmentSetIntersector(self) -> 'SegmentSetMutualIntersector': ...
    @typing.overload
    def intersects(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> bool: ...
    @typing.overload
    def intersects(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set], segmentIntersectionDetector: 'SegmentIntersectionDetector') -> bool: ...

class Noder:
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...

class NodingValidator:
    def __init__(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]): ...
    def checkValid(self) -> None: ...

class Octant:
    @typing.overload
    @staticmethod
    def octant(double: float, double2: float) -> int: ...
    @typing.overload
    @staticmethod
    def octant(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> int: ...

class OrientedCoordinateArray(java.lang.Comparable):
    def __init__(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]): ...
    def compareTo(self, object: typing.Any) -> int: ...

class SegmentIntersector:
    def isDone(self) -> bool: ...
    def processIntersections(self, segmentString: 'SegmentString', int: int, segmentString2: 'SegmentString', int2: int) -> None: ...

class SegmentNode(java.lang.Comparable):
    coord: org.locationtech.jts.geom.Coordinate = ...
    segmentIndex: int = ...
    def __init__(self, nodedSegmentString: 'NodedSegmentString', coordinate: org.locationtech.jts.geom.Coordinate, int: int, int2: int): ...
    def compareTo(self, object: typing.Any) -> int: ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def isEndPoint(self, int: int) -> bool: ...
    def isInterior(self) -> bool: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...
    def toString(self) -> str: ...

class SegmentNodeList:
    def __init__(self, nodedSegmentString: 'NodedSegmentString'): ...
    def add(self, coordinate: org.locationtech.jts.geom.Coordinate, int: int) -> SegmentNode: ...
    def addSplitEdges(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getEdge(self) -> 'NodedSegmentString': ...
    def getSplitCoordinates(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def iterator(self) -> java.util.Iterator: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...

class SegmentPointComparator:
    def __init__(self): ...
    @staticmethod
    def compare(int: int, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> int: ...
    @staticmethod
    def relativeSign(double: float, double2: float) -> int: ...

class SegmentSetMutualIntersector:
    def process(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set], segmentIntersector: SegmentIntersector) -> None: ...

class SegmentString:
    def getCoordinate(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getCoordinates(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def getData(self) -> typing.Any: ...
    def isClosed(self) -> bool: ...
    def setData(self, object: typing.Any) -> None: ...
    def size(self) -> int: ...

class SegmentStringDissolver:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, segmentStringMerger: 'SegmentStringDissolver.SegmentStringMerger'): ...
    @typing.overload
    def dissolve(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    @typing.overload
    def dissolve(self, segmentString: SegmentString) -> None: ...
    def getDissolved(self) -> java.util.Collection: ...
    class SegmentStringMerger:
        def merge(self, segmentString: SegmentString, segmentString2: SegmentString, boolean: bool) -> None: ...

class SegmentStringUtil:
    def __init__(self): ...
    @staticmethod
    def extractBasicSegmentStrings(geometry: org.locationtech.jts.geom.Geometry) -> java.util.List: ...
    @staticmethod
    def extractNodedSegmentStrings(geometry: org.locationtech.jts.geom.Geometry) -> java.util.List: ...
    @staticmethod
    def extractSegmentStrings(geometry: org.locationtech.jts.geom.Geometry) -> java.util.List: ...
    @staticmethod
    def toGeometry(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set], geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(list: java.util.List) -> str: ...

class BasicSegmentString(SegmentString):
    def __init__(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray], object: typing.Any): ...
    def getCoordinate(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getCoordinates(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def getData(self) -> typing.Any: ...
    def getSegmentOctant(self, int: int) -> int: ...
    def isClosed(self) -> bool: ...
    def setData(self, object: typing.Any) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...

class BoundaryChainNoder(Noder):
    def __init__(self): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...

class BoundarySegmentNoder(Noder):
    def __init__(self): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...

class InteriorIntersectionFinderAdder(SegmentIntersector):
    def __init__(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector): ...
    def getInteriorIntersections(self) -> java.util.List: ...
    def isDone(self) -> bool: ...
    def processIntersections(self, segmentString: SegmentString, int: int, segmentString2: SegmentString, int2: int) -> None: ...

class IntersectionAdder(SegmentIntersector):
    numIntersections: int = ...
    numInteriorIntersections: int = ...
    numProperIntersections: int = ...
    numTests: int = ...
    def __init__(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector): ...
    def getLineIntersector(self) -> org.locationtech.jts.algorithm.LineIntersector: ...
    def getProperIntersectionPoint(self) -> org.locationtech.jts.geom.Coordinate: ...
    def hasInteriorIntersection(self) -> bool: ...
    def hasIntersection(self) -> bool: ...
    def hasProperInteriorIntersection(self) -> bool: ...
    def hasProperIntersection(self) -> bool: ...
    @staticmethod
    def isAdjacentSegments(int: int, int2: int) -> bool: ...
    def isDone(self) -> bool: ...
    def processIntersections(self, segmentString: SegmentString, int: int, segmentString2: SegmentString, int2: int) -> None: ...

class IntersectionFinderAdder(SegmentIntersector):
    def __init__(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector): ...
    def getInteriorIntersections(self) -> java.util.List: ...
    def isDone(self) -> bool: ...
    def processIntersections(self, segmentString: SegmentString, int: int, segmentString2: SegmentString, int2: int) -> None: ...

class IteratedNoder(Noder):
    MAX_ITER: typing.ClassVar[int] = ...
    def __init__(self, precisionModel: org.locationtech.jts.geom.PrecisionModel): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...
    def setMaximumIterations(self, int: int) -> None: ...

class MCIndexSegmentSetMutualIntersector(SegmentSetMutualIntersector):
    def __init__(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]): ...
    def getIndex(self) -> org.locationtech.jts.index.SpatialIndex: ...
    def process(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set], segmentIntersector: SegmentIntersector) -> None: ...
    class SegmentOverlapAction(org.locationtech.jts.index.chain.MonotoneChainOverlapAction):
        def __init__(self, segmentIntersector: SegmentIntersector): ...
        @typing.overload
        def overlap(self, lineSegment: org.locationtech.jts.geom.LineSegment, lineSegment2: org.locationtech.jts.geom.LineSegment) -> None: ...
        @typing.overload
        def overlap(self, monotoneChain: org.locationtech.jts.index.chain.MonotoneChain, int: int, monotoneChain2: org.locationtech.jts.index.chain.MonotoneChain, int2: int) -> None: ...

class NodableSegmentString(SegmentString):
    def addIntersection(self, coordinate: org.locationtech.jts.geom.Coordinate, int: int) -> None: ...

class NodingIntersectionFinder(SegmentIntersector):
    def __init__(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector): ...
    def count(self) -> int: ...
    @staticmethod
    def createAllIntersectionsFinder(lineIntersector: org.locationtech.jts.algorithm.LineIntersector) -> 'NodingIntersectionFinder': ...
    @staticmethod
    def createAnyIntersectionFinder(lineIntersector: org.locationtech.jts.algorithm.LineIntersector) -> 'NodingIntersectionFinder': ...
    @staticmethod
    def createInteriorIntersectionCounter(lineIntersector: org.locationtech.jts.algorithm.LineIntersector) -> 'NodingIntersectionFinder': ...
    @staticmethod
    def createInteriorIntersectionsFinder(lineIntersector: org.locationtech.jts.algorithm.LineIntersector) -> 'NodingIntersectionFinder': ...
    @staticmethod
    def createIntersectionCounter(lineIntersector: org.locationtech.jts.algorithm.LineIntersector) -> 'NodingIntersectionFinder': ...
    def getIntersection(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getIntersectionSegments(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def getIntersections(self) -> java.util.List: ...
    def hasIntersection(self) -> bool: ...
    def isDone(self) -> bool: ...
    def processIntersections(self, segmentString: SegmentString, int: int, segmentString2: SegmentString, int2: int) -> None: ...
    def setCheckEndSegmentsOnly(self, boolean: bool) -> None: ...
    def setFindAllIntersections(self, boolean: bool) -> None: ...
    def setInteriorIntersectionsOnly(self, boolean: bool) -> None: ...
    def setKeepIntersections(self, boolean: bool) -> None: ...

class ScaledNoder(Noder):
    @typing.overload
    def __init__(self, noder: Noder, double: float): ...
    @typing.overload
    def __init__(self, noder: Noder, double: float, double2: float, double3: float): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...
    def isIntegerPrecision(self) -> bool: ...

class SegmentExtractingNoder(Noder):
    def __init__(self): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...

class SegmentIntersectionDetector(SegmentIntersector):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector): ...
    def getIntersection(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getIntersectionSegments(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def hasIntersection(self) -> bool: ...
    def hasNonProperIntersection(self) -> bool: ...
    def hasProperIntersection(self) -> bool: ...
    def isDone(self) -> bool: ...
    def processIntersections(self, segmentString: SegmentString, int: int, segmentString2: SegmentString, int2: int) -> None: ...
    def setFindAllIntersectionTypes(self, boolean: bool) -> None: ...
    def setFindProper(self, boolean: bool) -> None: ...

class SimpleSegmentSetMutualIntersector(SegmentSetMutualIntersector):
    def __init__(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]): ...
    def process(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set], segmentIntersector: SegmentIntersector) -> None: ...

class SinglePassNoder(Noder):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, segmentIntersector: SegmentIntersector): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...
    def setSegmentIntersector(self, segmentIntersector: SegmentIntersector) -> None: ...

class ValidatingNoder(Noder):
    def __init__(self, noder: Noder): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...

class MCIndexNoder(SinglePassNoder):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, segmentIntersector: SegmentIntersector): ...
    @typing.overload
    def __init__(self, segmentIntersector: SegmentIntersector, double: float): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getIndex(self) -> org.locationtech.jts.index.SpatialIndex: ...
    def getMonotoneChains(self) -> java.util.List: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...
    class SegmentOverlapAction(org.locationtech.jts.index.chain.MonotoneChainOverlapAction):
        def __init__(self, segmentIntersector: SegmentIntersector): ...
        @typing.overload
        def overlap(self, lineSegment: org.locationtech.jts.geom.LineSegment, lineSegment2: org.locationtech.jts.geom.LineSegment) -> None: ...
        @typing.overload
        def overlap(self, monotoneChain: org.locationtech.jts.index.chain.MonotoneChain, int: int, monotoneChain2: org.locationtech.jts.index.chain.MonotoneChain, int2: int) -> None: ...

class NodedSegmentString(NodableSegmentString):
    @typing.overload
    def __init__(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray], object: typing.Any): ...
    @typing.overload
    def __init__(self, segmentString: SegmentString): ...
    @typing.overload
    def addIntersection(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def addIntersection(self, coordinate: org.locationtech.jts.geom.Coordinate, int: int) -> None: ...
    def addIntersectionNode(self, coordinate: org.locationtech.jts.geom.Coordinate, int: int) -> SegmentNode: ...
    def addIntersections(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector, int: int, int2: int) -> None: ...
    def getCoordinate(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getCoordinates(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def getData(self) -> typing.Any: ...
    def getNodeList(self) -> SegmentNodeList: ...
    def getNodedCoordinates(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    @typing.overload
    @staticmethod
    def getNodedSubstrings(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> java.util.List: ...
    @typing.overload
    @staticmethod
    def getNodedSubstrings(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set], collection2: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getSegmentOctant(self, int: int) -> int: ...
    def isClosed(self) -> bool: ...
    def setData(self, object: typing.Any) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...

class SimpleNoder(SinglePassNoder):
    def __init__(self): ...
    def computeNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getNodedSubstrings(self) -> java.util.Collection: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.noding")``.

    BasicSegmentString: typing.Type[BasicSegmentString]
    BoundaryChainNoder: typing.Type[BoundaryChainNoder]
    BoundarySegmentNoder: typing.Type[BoundarySegmentNoder]
    FastNodingValidator: typing.Type[FastNodingValidator]
    FastSegmentSetIntersectionFinder: typing.Type[FastSegmentSetIntersectionFinder]
    InteriorIntersectionFinderAdder: typing.Type[InteriorIntersectionFinderAdder]
    IntersectionAdder: typing.Type[IntersectionAdder]
    IntersectionFinderAdder: typing.Type[IntersectionFinderAdder]
    IteratedNoder: typing.Type[IteratedNoder]
    MCIndexNoder: typing.Type[MCIndexNoder]
    MCIndexSegmentSetMutualIntersector: typing.Type[MCIndexSegmentSetMutualIntersector]
    NodableSegmentString: typing.Type[NodableSegmentString]
    NodedSegmentString: typing.Type[NodedSegmentString]
    Noder: typing.Type[Noder]
    NodingIntersectionFinder: typing.Type[NodingIntersectionFinder]
    NodingValidator: typing.Type[NodingValidator]
    Octant: typing.Type[Octant]
    OrientedCoordinateArray: typing.Type[OrientedCoordinateArray]
    ScaledNoder: typing.Type[ScaledNoder]
    SegmentExtractingNoder: typing.Type[SegmentExtractingNoder]
    SegmentIntersectionDetector: typing.Type[SegmentIntersectionDetector]
    SegmentIntersector: typing.Type[SegmentIntersector]
    SegmentNode: typing.Type[SegmentNode]
    SegmentNodeList: typing.Type[SegmentNodeList]
    SegmentPointComparator: typing.Type[SegmentPointComparator]
    SegmentSetMutualIntersector: typing.Type[SegmentSetMutualIntersector]
    SegmentString: typing.Type[SegmentString]
    SegmentStringDissolver: typing.Type[SegmentStringDissolver]
    SegmentStringUtil: typing.Type[SegmentStringUtil]
    SimpleNoder: typing.Type[SimpleNoder]
    SimpleSegmentSetMutualIntersector: typing.Type[SimpleSegmentSetMutualIntersector]
    SinglePassNoder: typing.Type[SinglePassNoder]
    ValidatingNoder: typing.Type[ValidatingNoder]
    snap: org.locationtech.jts.noding.snap.__module_protocol__
    snapround: org.locationtech.jts.noding.snapround.__module_protocol__
