
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.util
import jpype
import org.locationtech.jts.geom
import typing



class Tri:
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate): ...
    @staticmethod
    def area(list: java.util.List['Tri']) -> float: ...
    @typing.overload
    @staticmethod
    def create(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> 'Tri': ...
    @typing.overload
    @staticmethod
    def create(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> 'Tri': ...
    def degree(self, int: int, list: java.util.List['Tri']) -> int: ...
    def flip(self, int: int) -> None: ...
    def getAdjacent(self, int: int) -> 'Tri': ...
    def getArea(self) -> float: ...
    def getCoordinate(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    def getIndex(self, coordinate: org.locationtech.jts.geom.Coordinate) -> int: ...
    @typing.overload
    def getIndex(self, tri: 'Tri') -> int: ...
    @typing.overload
    def getLength(self) -> float: ...
    @typing.overload
    def getLength(self, int: int) -> float: ...
    @typing.overload
    def hasAdjacent(self) -> bool: ...
    @typing.overload
    def hasAdjacent(self, int: int) -> bool: ...
    def isAdjacent(self, tri: 'Tri') -> bool: ...
    def isBorder(self) -> bool: ...
    def isBoundary(self, int: int) -> bool: ...
    def isInteriorVertex(self, int: int) -> bool: ...
    def midpoint(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    @staticmethod
    def next(int: int) -> int: ...
    def numAdjacent(self) -> int: ...
    @staticmethod
    def oppEdge(int: int) -> int: ...
    @staticmethod
    def oppVertex(int: int) -> int: ...
    @staticmethod
    def prev(int: int) -> int: ...
    @typing.overload
    def remove(self) -> None: ...
    @typing.overload
    def remove(self, list: java.util.List['Tri']) -> None: ...
    @typing.overload
    def setAdjacent(self, coordinate: org.locationtech.jts.geom.Coordinate, tri: 'Tri') -> None: ...
    @typing.overload
    def setAdjacent(self, tri: 'Tri', tri2: 'Tri', tri3: 'Tri') -> None: ...
    def setTri(self, int: int, tri: 'Tri') -> None: ...
    def split(self, coordinate: org.locationtech.jts.geom.Coordinate) -> 'Tri': ...
    @staticmethod
    def toGeometry(collection: typing.Union[java.util.Collection['Tri'], typing.Sequence['Tri'], typing.Set['Tri']], geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    def toPolygon(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Polygon: ...
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def validate(list: java.util.List['Tri']) -> None: ...
    @typing.overload
    def validate(self) -> None: ...
    def validateAdjacent(self, int: int) -> None: ...

class TriangulationBuilder:
    @staticmethod
    def build(list: java.util.List[Tri]) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.triangulate.tri")``.

    Tri: typing.Type[Tri]
    TriangulationBuilder: typing.Type[TriangulationBuilder]
