
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jpype
import org.locationtech.jts.geom
import org.locationtech.jts.math
import typing



class EdgeConnectedTriangleTraversal:
    def __init__(self): ...
    @typing.overload
    def init(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    @typing.overload
    def init(self, quadEdgeTriangle: 'QuadEdgeTriangle') -> None: ...
    def visitAll(self, traversalVisitor: 'TraversalVisitor') -> None: ...

class LocateFailureException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, lineSegment: org.locationtech.jts.geom.LineSegment): ...
    @typing.overload
    def __init__(self, lineSegment: org.locationtech.jts.geom.LineSegment): ...
    def getSegment(self) -> org.locationtech.jts.geom.LineSegment: ...

class QuadEdge:
    @staticmethod
    def connect(quadEdge: 'QuadEdge', quadEdge2: 'QuadEdge') -> 'QuadEdge': ...
    def dNext(self) -> 'QuadEdge': ...
    def dPrev(self) -> 'QuadEdge': ...
    def delete(self) -> None: ...
    def dest(self) -> 'Vertex': ...
    def equalsNonOriented(self, quadEdge: 'QuadEdge') -> bool: ...
    def equalsOriented(self, quadEdge: 'QuadEdge') -> bool: ...
    def getData(self) -> typing.Any: ...
    def getLength(self) -> float: ...
    def getPrimary(self) -> 'QuadEdge': ...
    def invRot(self) -> 'QuadEdge': ...
    def isLive(self) -> bool: ...
    def lNext(self) -> 'QuadEdge': ...
    def lPrev(self) -> 'QuadEdge': ...
    @staticmethod
    def makeEdge(vertex: 'Vertex', vertex2: 'Vertex') -> 'QuadEdge': ...
    def oNext(self) -> 'QuadEdge': ...
    def oPrev(self) -> 'QuadEdge': ...
    def orig(self) -> 'Vertex': ...
    def rNext(self) -> 'QuadEdge': ...
    def rPrev(self) -> 'QuadEdge': ...
    def rot(self) -> 'QuadEdge': ...
    def setData(self, object: typing.Any) -> None: ...
    def setNext(self, quadEdge: 'QuadEdge') -> None: ...
    @staticmethod
    def splice(quadEdge: 'QuadEdge', quadEdge2: 'QuadEdge') -> None: ...
    @staticmethod
    def swap(quadEdge: 'QuadEdge') -> None: ...
    def sym(self) -> 'QuadEdge': ...
    def toLineSegment(self) -> org.locationtech.jts.geom.LineSegment: ...
    def toString(self) -> str: ...

class QuadEdgeLocator:
    def locate(self, vertex: 'Vertex') -> QuadEdge: ...

class QuadEdgeSubdivision:
    def __init__(self, envelope: org.locationtech.jts.geom.Envelope, double: float): ...
    def connect(self, quadEdge: QuadEdge, quadEdge2: QuadEdge) -> QuadEdge: ...
    def delete(self, quadEdge: QuadEdge) -> None: ...
    @typing.overload
    def getEdges(self) -> java.util.Collection: ...
    @typing.overload
    def getEdges(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    def getEnvelope(self) -> org.locationtech.jts.geom.Envelope: ...
    def getPrimaryEdges(self, boolean: bool) -> java.util.List: ...
    def getTolerance(self) -> float: ...
    def getTriangleCoordinates(self, boolean: bool) -> java.util.List: ...
    @typing.overload
    def getTriangleEdges(self, boolean: bool) -> java.util.List: ...
    @typing.overload
    @staticmethod
    def getTriangleEdges(quadEdge: QuadEdge, quadEdgeArray: typing.Union[typing.List[QuadEdge], jpype.JArray]) -> None: ...
    def getTriangleVertices(self, boolean: bool) -> java.util.List: ...
    def getTriangles(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    def getVertexUniqueEdges(self, boolean: bool) -> java.util.List: ...
    def getVertices(self, boolean: bool) -> java.util.Collection: ...
    def getVoronoiCellPolygon(self, quadEdge: QuadEdge, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Polygon: ...
    def getVoronoiCellPolygons(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> java.util.List: ...
    def getVoronoiDiagram(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    def insertSite(self, vertex: 'Vertex') -> QuadEdge: ...
    def isFrameBorderEdge(self, quadEdge: QuadEdge) -> bool: ...
    def isFrameEdge(self, quadEdge: QuadEdge) -> bool: ...
    def isFrameVertex(self, vertex: 'Vertex') -> bool: ...
    def isOnEdge(self, quadEdge: QuadEdge, coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    def isVertexOfEdge(self, quadEdge: QuadEdge, vertex: 'Vertex') -> bool: ...
    @typing.overload
    def locate(self, coordinate: org.locationtech.jts.geom.Coordinate) -> QuadEdge: ...
    @typing.overload
    def locate(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> QuadEdge: ...
    @typing.overload
    def locate(self, vertex: 'Vertex') -> QuadEdge: ...
    def locateFromEdge(self, vertex: 'Vertex', quadEdge: QuadEdge) -> QuadEdge: ...
    def makeEdge(self, vertex: 'Vertex', vertex2: 'Vertex') -> QuadEdge: ...
    def setLocator(self, quadEdgeLocator: QuadEdgeLocator) -> None: ...
    def visitTriangles(self, triangleVisitor: 'TriangleVisitor', boolean: bool) -> None: ...

class QuadEdgeTriangle:
    def __init__(self, quadEdgeArray: typing.Union[typing.List[QuadEdge], jpype.JArray]): ...
    @typing.overload
    def contains(self, coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @typing.overload
    @staticmethod
    def contains(quadEdgeArray: typing.Union[typing.List[QuadEdge], jpype.JArray], coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @typing.overload
    @staticmethod
    def contains(vertexArray: typing.Union[typing.List['Vertex'], jpype.JArray], coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def createOn(quadEdgeSubdivision: QuadEdgeSubdivision) -> java.util.List: ...
    def getAdjacentTriangleAcrossEdge(self, int: int) -> 'QuadEdgeTriangle': ...
    def getAdjacentTriangleEdgeIndex(self, int: int) -> int: ...
    def getCoordinate(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getCoordinates(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def getData(self) -> typing.Any: ...
    def getEdge(self, int: int) -> QuadEdge: ...
    @typing.overload
    def getEdgeIndex(self, quadEdge: QuadEdge) -> int: ...
    @typing.overload
    def getEdgeIndex(self, vertex: 'Vertex') -> int: ...
    def getEdgeSegment(self, int: int, lineSegment: org.locationtech.jts.geom.LineSegment) -> None: ...
    def getEdges(self) -> typing.MutableSequence[QuadEdge]: ...
    def getGeometry(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Polygon: ...
    def getNeighbours(self) -> typing.MutableSequence['QuadEdgeTriangle']: ...
    def getTrianglesAdjacentToVertex(self, int: int) -> java.util.List: ...
    def getVertex(self, int: int) -> 'Vertex': ...
    def getVertices(self) -> typing.MutableSequence['Vertex']: ...
    @typing.overload
    def isBorder(self) -> bool: ...
    @typing.overload
    def isBorder(self, int: int) -> bool: ...
    def isLive(self) -> bool: ...
    def kill(self) -> None: ...
    @staticmethod
    def nextIndex(int: int) -> int: ...
    def setData(self, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def toPolygon(quadEdgeArray: typing.Union[typing.List[QuadEdge], jpype.JArray]) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def toPolygon(vertexArray: typing.Union[typing.List['Vertex'], jpype.JArray]) -> org.locationtech.jts.geom.Geometry: ...
    def toString(self) -> str: ...

class QuadEdgeUtil:
    def __init__(self): ...
    @staticmethod
    def findEdgesIncidentOnOrigin(quadEdge: QuadEdge) -> java.util.List: ...

class TraversalVisitor:
    def visit(self, quadEdgeTriangle: QuadEdgeTriangle, int: int, quadEdgeTriangle2: QuadEdgeTriangle) -> bool: ...

class TrianglePredicate:
    def __init__(self): ...
    @staticmethod
    def isInCircleCC(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def isInCircleDDFast(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def isInCircleDDNormalized(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def isInCircleDDSlow(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def isInCircleNonRobust(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def isInCircleNormalized(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def isInCircleRobust(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def triAreaDDFast(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.math.DD: ...
    @staticmethod
    def triAreaDDSlow(dD: org.locationtech.jts.math.DD, dD2: org.locationtech.jts.math.DD, dD3: org.locationtech.jts.math.DD, dD4: org.locationtech.jts.math.DD, dD5: org.locationtech.jts.math.DD, dD6: org.locationtech.jts.math.DD) -> org.locationtech.jts.math.DD: ...

class TriangleVisitor:
    def visit(self, quadEdgeArray: typing.Union[typing.List[QuadEdge], jpype.JArray]) -> None: ...

class Vertex:
    LEFT: typing.ClassVar[int] = ...
    RIGHT: typing.ClassVar[int] = ...
    BEYOND: typing.ClassVar[int] = ...
    BEHIND: typing.ClassVar[int] = ...
    BETWEEN: typing.ClassVar[int] = ...
    ORIGIN: typing.ClassVar[int] = ...
    DESTINATION: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate): ...
    def circleCenter(self, vertex: 'Vertex', vertex2: 'Vertex') -> 'Vertex': ...
    def circumRadiusRatio(self, vertex: 'Vertex', vertex2: 'Vertex') -> float: ...
    def classify(self, vertex: 'Vertex', vertex2: 'Vertex') -> int: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, vertex: 'Vertex') -> bool: ...
    @typing.overload
    def equals(self, vertex: 'Vertex', double: float) -> bool: ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def getZ(self) -> float: ...
    @typing.overload
    @staticmethod
    def interpolateZ(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @typing.overload
    @staticmethod
    def interpolateZ(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> float: ...
    def interpolateZValue(self, vertex: 'Vertex', vertex2: 'Vertex', vertex3: 'Vertex') -> float: ...
    def isCCW(self, vertex: 'Vertex', vertex2: 'Vertex') -> bool: ...
    def isInCircle(self, vertex: 'Vertex', vertex2: 'Vertex', vertex3: 'Vertex') -> bool: ...
    def leftOf(self, quadEdge: QuadEdge) -> bool: ...
    def midPoint(self, vertex: 'Vertex') -> 'Vertex': ...
    def rightOf(self, quadEdge: QuadEdge) -> bool: ...
    def setZ(self, double: float) -> None: ...
    def toString(self) -> str: ...

class LastFoundQuadEdgeLocator(QuadEdgeLocator):
    def __init__(self, quadEdgeSubdivision: QuadEdgeSubdivision): ...
    def locate(self, vertex: Vertex) -> QuadEdge: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.triangulate.quadedge")``.

    EdgeConnectedTriangleTraversal: typing.Type[EdgeConnectedTriangleTraversal]
    LastFoundQuadEdgeLocator: typing.Type[LastFoundQuadEdgeLocator]
    LocateFailureException: typing.Type[LocateFailureException]
    QuadEdge: typing.Type[QuadEdge]
    QuadEdgeLocator: typing.Type[QuadEdgeLocator]
    QuadEdgeSubdivision: typing.Type[QuadEdgeSubdivision]
    QuadEdgeTriangle: typing.Type[QuadEdgeTriangle]
    QuadEdgeUtil: typing.Type[QuadEdgeUtil]
    TraversalVisitor: typing.Type[TraversalVisitor]
    TrianglePredicate: typing.Type[TrianglePredicate]
    TriangleVisitor: typing.Type[TriangleVisitor]
    Vertex: typing.Type[Vertex]
