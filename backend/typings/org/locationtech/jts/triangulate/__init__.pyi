
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jpype
import org.locationtech.jts.geom
import org.locationtech.jts.index.kdtree
import org.locationtech.jts.triangulate.polygon
import org.locationtech.jts.triangulate.quadedge
import org.locationtech.jts.triangulate.tri
import typing



class ConformingDelaunayTriangulationBuilder:
    def __init__(self): ...
    def getEdges(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    def getSubdivision(self) -> org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision: ...
    def getTriangles(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    def setConstraints(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    def setSites(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    def setTolerance(self, double: float) -> None: ...

class ConformingDelaunayTriangulator:
    def __init__(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set], double: float): ...
    def enforceConstraints(self) -> None: ...
    def formInitialDelaunay(self) -> None: ...
    def getConstraintSegments(self) -> java.util.Collection: ...
    def getConvexHull(self) -> org.locationtech.jts.geom.Geometry: ...
    def getInitialVertices(self) -> java.util.List: ...
    def getKDT(self) -> org.locationtech.jts.index.kdtree.KdTree: ...
    def getSubdivision(self) -> org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision: ...
    def getTolerance(self) -> float: ...
    def getVertexFactory(self) -> 'ConstraintVertexFactory': ...
    def insertSite(self, coordinate: org.locationtech.jts.geom.Coordinate) -> None: ...
    def setConstraints(self, list: java.util.List, list2: java.util.List) -> None: ...
    def setSplitPointFinder(self, constraintSplitPointFinder: 'ConstraintSplitPointFinder') -> None: ...
    def setVertexFactory(self, constraintVertexFactory: 'ConstraintVertexFactory') -> None: ...

class ConstraintEnforcementException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, coordinate: org.locationtech.jts.geom.Coordinate): ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...

class ConstraintSplitPointFinder:
    def findSplitPoint(self, segment: 'Segment', coordinate: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...

class ConstraintVertex(org.locationtech.jts.triangulate.quadedge.Vertex):
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate): ...
    def getConstraint(self) -> typing.Any: ...
    def isOnConstraint(self) -> bool: ...
    def setConstraint(self, object: typing.Any) -> None: ...
    def setOnConstraint(self, boolean: bool) -> None: ...

class ConstraintVertexFactory:
    def createVertex(self, coordinate: org.locationtech.jts.geom.Coordinate, segment: 'Segment') -> ConstraintVertex: ...

class DelaunayTriangulationBuilder:
    def __init__(self): ...
    @staticmethod
    def envelope(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> org.locationtech.jts.geom.Envelope: ...
    @staticmethod
    def extractUniqueCoordinates(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.CoordinateList: ...
    def getEdges(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    def getSubdivision(self) -> org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision: ...
    def getTriangles(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    def setSites(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    @typing.overload
    def setSites(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    def setTolerance(self, double: float) -> None: ...
    @staticmethod
    def toVertices(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> java.util.List: ...
    @staticmethod
    def unique(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> org.locationtech.jts.geom.CoordinateList: ...

class IncrementalDelaunayTriangulator:
    def __init__(self, quadEdgeSubdivision: org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision): ...
    def insertSite(self, vertex: org.locationtech.jts.triangulate.quadedge.Vertex) -> org.locationtech.jts.triangulate.quadedge.QuadEdge: ...
    def insertSites(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...

class Segment:
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float, object: typing.Any): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, object: typing.Any): ...
    def equalsTopo(self, segment: 'Segment') -> bool: ...
    def getData(self) -> typing.Any: ...
    def getEnd(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getEndX(self) -> float: ...
    def getEndY(self) -> float: ...
    def getEndZ(self) -> float: ...
    def getLineSegment(self) -> org.locationtech.jts.geom.LineSegment: ...
    def getStart(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getStartX(self) -> float: ...
    def getStartY(self) -> float: ...
    def getStartZ(self) -> float: ...
    def intersection(self, segment: 'Segment') -> org.locationtech.jts.geom.Coordinate: ...
    def setData(self, object: typing.Any) -> None: ...
    def toString(self) -> str: ...

class SplitSegment:
    def __init__(self, lineSegment: org.locationtech.jts.geom.LineSegment): ...
    def getSplitPoint(self) -> org.locationtech.jts.geom.Coordinate: ...
    def setMinimumLength(self, double: float) -> None: ...
    @typing.overload
    def splitAt(self, double: float, coordinate: org.locationtech.jts.geom.Coordinate) -> None: ...
    @typing.overload
    def splitAt(self, coordinate: org.locationtech.jts.geom.Coordinate) -> None: ...

class VertexTaggedGeometryDataMapper:
    def __init__(self): ...
    def getCoordinates(self) -> java.util.List: ...
    @typing.overload
    def loadSourceGeometries(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    @typing.overload
    def loadSourceGeometries(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    def transferData(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...

class VoronoiDiagramBuilder:
    def __init__(self): ...
    def getDiagram(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    def getSubdivision(self) -> org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision: ...
    def setClipEnvelope(self, envelope: org.locationtech.jts.geom.Envelope) -> None: ...
    @typing.overload
    def setSites(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    @typing.overload
    def setSites(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    def setTolerance(self, double: float) -> None: ...

class MidpointSplitPointFinder(ConstraintSplitPointFinder):
    def __init__(self): ...
    def findSplitPoint(self, segment: Segment, coordinate: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...

class NonEncroachingSplitPointFinder(ConstraintSplitPointFinder):
    def __init__(self): ...
    def findSplitPoint(self, segment: Segment, coordinate: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...
    @staticmethod
    def projectedSplitPoint(segment: Segment, coordinate: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.triangulate")``.

    ConformingDelaunayTriangulationBuilder: typing.Type[ConformingDelaunayTriangulationBuilder]
    ConformingDelaunayTriangulator: typing.Type[ConformingDelaunayTriangulator]
    ConstraintEnforcementException: typing.Type[ConstraintEnforcementException]
    ConstraintSplitPointFinder: typing.Type[ConstraintSplitPointFinder]
    ConstraintVertex: typing.Type[ConstraintVertex]
    ConstraintVertexFactory: typing.Type[ConstraintVertexFactory]
    DelaunayTriangulationBuilder: typing.Type[DelaunayTriangulationBuilder]
    IncrementalDelaunayTriangulator: typing.Type[IncrementalDelaunayTriangulator]
    MidpointSplitPointFinder: typing.Type[MidpointSplitPointFinder]
    NonEncroachingSplitPointFinder: typing.Type[NonEncroachingSplitPointFinder]
    Segment: typing.Type[Segment]
    SplitSegment: typing.Type[SplitSegment]
    VertexTaggedGeometryDataMapper: typing.Type[VertexTaggedGeometryDataMapper]
    VoronoiDiagramBuilder: typing.Type[VoronoiDiagramBuilder]
    polygon: org.locationtech.jts.triangulate.polygon.__module_protocol__
    quadedge: org.locationtech.jts.triangulate.quadedge.__module_protocol__
    tri: org.locationtech.jts.triangulate.tri.__module_protocol__
