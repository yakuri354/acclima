
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import org.locationtech.jts.geom
import typing



class LengthIndexedLine:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    def clampIndex(self, double: float) -> float: ...
    def extractLine(self, double: float, double2: float) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    def extractPoint(self, double: float) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    def extractPoint(self, double: float, double2: float) -> org.locationtech.jts.geom.Coordinate: ...
    def getEndIndex(self) -> float: ...
    def getStartIndex(self) -> float: ...
    def indexOf(self, coordinate: org.locationtech.jts.geom.Coordinate) -> float: ...
    def indexOfAfter(self, coordinate: org.locationtech.jts.geom.Coordinate, double: float) -> float: ...
    def indicesOf(self, geometry: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence[float]: ...
    def isValidIndex(self, double: float) -> bool: ...
    def project(self, coordinate: org.locationtech.jts.geom.Coordinate) -> float: ...

class LengthLocationMap:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def getLength(self, linearLocation: 'LinearLocation') -> float: ...
    @typing.overload
    @staticmethod
    def getLength(geometry: org.locationtech.jts.geom.Geometry, linearLocation: 'LinearLocation') -> float: ...
    @typing.overload
    def getLocation(self, double: float) -> 'LinearLocation': ...
    @typing.overload
    def getLocation(self, double: float, boolean: bool) -> 'LinearLocation': ...
    @typing.overload
    @staticmethod
    def getLocation(geometry: org.locationtech.jts.geom.Geometry, double: float) -> 'LinearLocation': ...
    @typing.overload
    @staticmethod
    def getLocation(geometry: org.locationtech.jts.geom.Geometry, double: float, boolean: bool) -> 'LinearLocation': ...

class LinearGeometryBuilder:
    def __init__(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory): ...
    @typing.overload
    def add(self, coordinate: org.locationtech.jts.geom.Coordinate) -> None: ...
    @typing.overload
    def add(self, coordinate: org.locationtech.jts.geom.Coordinate, boolean: bool) -> None: ...
    def endLine(self) -> None: ...
    def getGeometry(self) -> org.locationtech.jts.geom.Geometry: ...
    def getLastCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def setFixInvalidLines(self, boolean: bool) -> None: ...
    def setIgnoreInvalidLines(self, boolean: bool) -> None: ...

class LinearIterator:
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, int: int, int2: int): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, linearLocation: 'LinearLocation'): ...
    def getComponentIndex(self) -> int: ...
    def getLine(self) -> org.locationtech.jts.geom.LineString: ...
    def getSegmentEnd(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getSegmentStart(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getVertexIndex(self) -> int: ...
    def hasNext(self) -> bool: ...
    def isEndOfLine(self) -> bool: ...
    def next(self) -> None: ...

class LinearLocation(java.lang.Comparable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, int2: int, double: float): ...
    @typing.overload
    def __init__(self, linearLocation: 'LinearLocation'): ...
    def clamp(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def compareLocationValues(self, int: int, int2: int, double: float) -> int: ...
    @typing.overload
    @staticmethod
    def compareLocationValues(int: int, int2: int, double: float, int3: int, int4: int, double2: float) -> int: ...
    def compareTo(self, object: typing.Any) -> int: ...
    def copy(self) -> 'LinearLocation': ...
    def getComponentIndex(self) -> int: ...
    def getCoordinate(self, geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Coordinate: ...
    @staticmethod
    def getEndLocation(geometry: org.locationtech.jts.geom.Geometry) -> 'LinearLocation': ...
    def getSegment(self, geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.LineSegment: ...
    def getSegmentFraction(self) -> float: ...
    def getSegmentIndex(self) -> int: ...
    def getSegmentLength(self, geometry: org.locationtech.jts.geom.Geometry) -> float: ...
    def isEndpoint(self, geometry: org.locationtech.jts.geom.Geometry) -> bool: ...
    def isOnSameSegment(self, linearLocation: 'LinearLocation') -> bool: ...
    def isValid(self, geometry: org.locationtech.jts.geom.Geometry) -> bool: ...
    def isVertex(self) -> bool: ...
    @staticmethod
    def pointAlongSegmentByFraction(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, double: float) -> org.locationtech.jts.geom.Coordinate: ...
    def setToEnd(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    def snapToVertex(self, geometry: org.locationtech.jts.geom.Geometry, double: float) -> None: ...
    def toLowest(self, geometry: org.locationtech.jts.geom.Geometry) -> 'LinearLocation': ...
    def toString(self) -> str: ...

class LocationIndexedLine:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    def clampIndex(self, linearLocation: LinearLocation) -> LinearLocation: ...
    def extractLine(self, linearLocation: LinearLocation, linearLocation2: LinearLocation) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    def extractPoint(self, linearLocation: LinearLocation) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    def extractPoint(self, linearLocation: LinearLocation, double: float) -> org.locationtech.jts.geom.Coordinate: ...
    def getEndIndex(self) -> LinearLocation: ...
    def getStartIndex(self) -> LinearLocation: ...
    def indexOf(self, coordinate: org.locationtech.jts.geom.Coordinate) -> LinearLocation: ...
    def indexOfAfter(self, coordinate: org.locationtech.jts.geom.Coordinate, linearLocation: LinearLocation) -> LinearLocation: ...
    def indicesOf(self, geometry: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence[LinearLocation]: ...
    def isValidIndex(self, linearLocation: LinearLocation) -> bool: ...
    def project(self, coordinate: org.locationtech.jts.geom.Coordinate) -> LinearLocation: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.linearref")``.

    LengthIndexedLine: typing.Type[LengthIndexedLine]
    LengthLocationMap: typing.Type[LengthLocationMap]
    LinearGeometryBuilder: typing.Type[LinearGeometryBuilder]
    LinearIterator: typing.Type[LinearIterator]
    LinearLocation: typing.Type[LinearLocation]
    LocationIndexedLine: typing.Type[LocationIndexedLine]
