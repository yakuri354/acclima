
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import jpype
import org
import org.locationtech.jts.algorithm.construct
import org.locationtech.jts.algorithm.distance
import org.locationtech.jts.algorithm.hull
import org.locationtech.jts.algorithm.locate
import org.locationtech.jts.algorithm.match
import org.locationtech.jts.geom
import org.locationtech.jts.math
import typing



class Angle:
    PI_TIMES_2: typing.ClassVar[float] = ...
    PI_OVER_2: typing.ClassVar[float] = ...
    PI_OVER_4: typing.ClassVar[float] = ...
    COUNTERCLOCKWISE: typing.ClassVar[int] = ...
    CLOCKWISE: typing.ClassVar[int] = ...
    NONE: typing.ClassVar[int] = ...
    @typing.overload
    @staticmethod
    def angle(coordinate: org.locationtech.jts.geom.Coordinate) -> float: ...
    @typing.overload
    @staticmethod
    def angle(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def angleBetween(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def angleBetweenOriented(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def bisector(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def diff(double: float, double2: float) -> float: ...
    @staticmethod
    def getTurn(double: float, double2: float) -> int: ...
    @staticmethod
    def interiorAngle(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def isAcute(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def isObtuse(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @staticmethod
    def normalize(double: float) -> float: ...
    @staticmethod
    def normalizePositive(double: float) -> float: ...
    @staticmethod
    def project(coordinate: org.locationtech.jts.geom.Coordinate, double: float, double2: float) -> org.locationtech.jts.geom.Coordinate: ...
    @staticmethod
    def toDegrees(double: float) -> float: ...
    @staticmethod
    def toRadians(double: float) -> float: ...

class Area:
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def ofRing(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> float: ...
    @typing.overload
    @staticmethod
    def ofRing(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def ofRingSigned(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> float: ...
    @typing.overload
    @staticmethod
    def ofRingSigned(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> float: ...

class CGAlgorithms:
    CLOCKWISE: typing.ClassVar[int] = ...
    RIGHT: typing.ClassVar[int] = ...
    COUNTERCLOCKWISE: typing.ClassVar[int] = ...
    LEFT: typing.ClassVar[int] = ...
    COLLINEAR: typing.ClassVar[int] = ...
    STRAIGHT: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def computeOrientation(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> int: ...
    @staticmethod
    def distanceLineLine(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> float: ...
    @typing.overload
    @staticmethod
    def distancePointLine(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @typing.overload
    @staticmethod
    def distancePointLine(coordinate: org.locationtech.jts.geom.Coordinate, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> float: ...
    @staticmethod
    def distancePointLinePerpendicular(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def isCCW(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> bool: ...
    @staticmethod
    def isOnLine(coordinate: org.locationtech.jts.geom.Coordinate, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> bool: ...
    @staticmethod
    def isPointInRing(coordinate: org.locationtech.jts.geom.Coordinate, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> bool: ...
    @staticmethod
    def length(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> float: ...
    @staticmethod
    def locatePointInRing(coordinate: org.locationtech.jts.geom.Coordinate, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> int: ...
    @staticmethod
    def orientationIndex(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> int: ...
    @typing.overload
    @staticmethod
    def signedArea(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> float: ...
    @typing.overload
    @staticmethod
    def signedArea(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> float: ...

class CGAlgorithms3D:
    @staticmethod
    def distance(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def distancePointSegment(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def distanceSegmentSegment(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> float: ...

class CGAlgorithmsDD:
    @staticmethod
    def intersection(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    @staticmethod
    def orientationIndex(double: float, double2: float, double3: float, double4: float, double5: float, double6: float) -> int: ...
    @typing.overload
    @staticmethod
    def orientationIndex(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> int: ...
    @typing.overload
    @staticmethod
    def signOfDet2x2(double: float, double2: float, double3: float, double4: float) -> int: ...
    @typing.overload
    @staticmethod
    def signOfDet2x2(dD: org.locationtech.jts.math.DD, dD2: org.locationtech.jts.math.DD, dD3: org.locationtech.jts.math.DD, dD4: org.locationtech.jts.math.DD) -> int: ...

class Centroid:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def getCentroid(self) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    @staticmethod
    def getCentroid(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Coordinate: ...

class ConvexHull:
    @typing.overload
    def __init__(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray], geometryFactory: org.locationtech.jts.geom.GeometryFactory): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    def getConvexHull(self) -> org.locationtech.jts.geom.Geometry: ...

class Distance:
    def __init__(self): ...
    @staticmethod
    def pointToLinePerpendicular(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def pointToSegment(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @staticmethod
    def pointToSegmentString(coordinate: org.locationtech.jts.geom.Coordinate, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> float: ...
    @staticmethod
    def segmentToSegment(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> float: ...

class HCoordinate:
    x: float = ...
    y: float = ...
    w: float = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, hCoordinate: 'HCoordinate', hCoordinate2: 'HCoordinate'): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate): ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    @staticmethod
    def intersection(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...

class InteriorPoint:
    def __init__(self): ...
    @staticmethod
    def getInteriorPoint(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Coordinate: ...

class InteriorPointArea:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def getInteriorPoint(self) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    @staticmethod
    def getInteriorPoint(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Coordinate: ...

class InteriorPointLine:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def getInteriorPoint(self) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    @staticmethod
    def getInteriorPoint(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Coordinate: ...

class InteriorPointPoint:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def getInteriorPoint(self) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    @staticmethod
    def getInteriorPoint(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Coordinate: ...

class Intersection:
    def __init__(self): ...
    @staticmethod
    def intersection(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...
    @staticmethod
    def lineSegment(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...

class Length:
    def __init__(self): ...
    @staticmethod
    def ofLine(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> float: ...

class LineIntersector:
    DONT_INTERSECT: typing.ClassVar[int] = ...
    DO_INTERSECT: typing.ClassVar[int] = ...
    COLLINEAR: typing.ClassVar[int] = ...
    NO_INTERSECTION: typing.ClassVar[int] = ...
    POINT_INTERSECTION: typing.ClassVar[int] = ...
    COLLINEAR_INTERSECTION: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def computeEdgeDistance(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    @typing.overload
    def computeIntersection(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> None: ...
    @typing.overload
    def computeIntersection(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> None: ...
    def getEdgeDistance(self, int: int, int2: int) -> float: ...
    def getEndpoint(self, int: int, int2: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getIndexAlongSegment(self, int: int, int2: int) -> int: ...
    def getIntersection(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getIntersectionAlongSegment(self, int: int, int2: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getIntersectionNum(self) -> int: ...
    def hasIntersection(self) -> bool: ...
    @typing.overload
    def isInteriorIntersection(self) -> bool: ...
    @typing.overload
    def isInteriorIntersection(self, int: int) -> bool: ...
    def isIntersection(self, coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    def isProper(self) -> bool: ...
    @staticmethod
    def nonRobustComputeEdgeDistance(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> float: ...
    def setMakePrecise(self, precisionModel: org.locationtech.jts.geom.PrecisionModel) -> None: ...
    def setPrecisionModel(self, precisionModel: org.locationtech.jts.geom.PrecisionModel) -> None: ...
    def toString(self) -> str: ...

class MinimumBoundingCircle:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    def getCentre(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getCircle(self) -> org.locationtech.jts.geom.Geometry: ...
    def getDiameter(self) -> org.locationtech.jts.geom.Geometry: ...
    def getExtremalPoints(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def getFarthestPoints(self) -> org.locationtech.jts.geom.Geometry: ...
    def getMaximumDiameter(self) -> org.locationtech.jts.geom.Geometry: ...
    def getRadius(self) -> float: ...

class MinimumDiameter:
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, boolean: bool): ...
    def getDiameter(self) -> org.locationtech.jts.geom.LineString: ...
    def getLength(self) -> float: ...
    @staticmethod
    def getMinimumDiameter(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    def getMinimumRectangle(self) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def getMinimumRectangle(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Geometry: ...
    def getSupportingSegment(self) -> org.locationtech.jts.geom.LineString: ...
    def getWidthCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...

class NotRepresentableException(java.lang.Exception):
    def __init__(self): ...

class Orientation:
    CLOCKWISE: typing.ClassVar[int] = ...
    RIGHT: typing.ClassVar[int] = ...
    COUNTERCLOCKWISE: typing.ClassVar[int] = ...
    LEFT: typing.ClassVar[int] = ...
    COLLINEAR: typing.ClassVar[int] = ...
    STRAIGHT: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def index(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> int: ...
    @typing.overload
    @staticmethod
    def isCCW(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> bool: ...
    @typing.overload
    @staticmethod
    def isCCW(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> bool: ...
    @staticmethod
    def isCCWArea(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> bool: ...

class PointLocation:
    def __init__(self): ...
    @staticmethod
    def isInRing(coordinate: org.locationtech.jts.geom.Coordinate, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def isOnLine(coordinate: org.locationtech.jts.geom.Coordinate, coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> bool: ...
    @typing.overload
    @staticmethod
    def isOnLine(coordinate: org.locationtech.jts.geom.Coordinate, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> bool: ...
    @staticmethod
    def locateInRing(coordinate: org.locationtech.jts.geom.Coordinate, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> int: ...

class PointLocator:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boundaryNodeRule: 'BoundaryNodeRule'): ...
    def intersects(self, coordinate: org.locationtech.jts.geom.Coordinate, geometry: org.locationtech.jts.geom.Geometry) -> bool: ...
    def locate(self, coordinate: org.locationtech.jts.geom.Coordinate, geometry: org.locationtech.jts.geom.Geometry) -> int: ...

class RayCrossingCounter:
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate): ...
    def countSegment(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> None: ...
    def getLocation(self) -> int: ...
    def isOnSegment(self) -> bool: ...
    def isPointInPolygon(self) -> bool: ...
    @typing.overload
    @staticmethod
    def locatePointInRing(coordinate: org.locationtech.jts.geom.Coordinate, coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> int: ...
    @typing.overload
    @staticmethod
    def locatePointInRing(coordinate: org.locationtech.jts.geom.Coordinate, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> int: ...

class RectangleLineIntersector:
    def __init__(self, envelope: org.locationtech.jts.geom.Envelope): ...
    def intersects(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> bool: ...

class RobustDeterminant:
    def __init__(self): ...
    @staticmethod
    def orientationIndex(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> int: ...
    @staticmethod
    def signOfDet2x2(double: float, double2: float, double3: float, double4: float) -> int: ...

class RobustLineIntersector(LineIntersector):
    def __init__(self): ...
    @typing.overload
    def computeIntersection(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> None: ...
    @typing.overload
    def computeIntersection(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate) -> None: ...

class BoundaryNodeRule:
    MOD2_BOUNDARY_RULE: typing.ClassVar['BoundaryNodeRule'] = ...
    ENDPOINT_BOUNDARY_RULE: typing.ClassVar['BoundaryNodeRule'] = ...
    MULTIVALENT_ENDPOINT_BOUNDARY_RULE: typing.ClassVar['BoundaryNodeRule'] = ...
    MONOVALENT_ENDPOINT_BOUNDARY_RULE: typing.ClassVar['BoundaryNodeRule'] = ...
    OGC_SFS_BOUNDARY_RULE: typing.ClassVar['BoundaryNodeRule'] = ...
    def isInBoundary(self, int: int) -> bool: ...
    class EndPointBoundaryNodeRule(org.locationtech.jts.algorithm.BoundaryNodeRule):
        def __init__(self): ...
        def isInBoundary(self, int: int) -> bool: ...
    class Mod2BoundaryNodeRule(org.locationtech.jts.algorithm.BoundaryNodeRule):
        def __init__(self): ...
        def isInBoundary(self, int: int) -> bool: ...
    class MonoValentEndPointBoundaryNodeRule(org.locationtech.jts.algorithm.BoundaryNodeRule):
        def __init__(self): ...
        def isInBoundary(self, int: int) -> bool: ...
    class MultiValentEndPointBoundaryNodeRule(org.locationtech.jts.algorithm.BoundaryNodeRule):
        def __init__(self): ...
        def isInBoundary(self, int: int) -> bool: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.algorithm")``.

    Angle: typing.Type[Angle]
    Area: typing.Type[Area]
    BoundaryNodeRule: typing.Type[BoundaryNodeRule]
    CGAlgorithms: typing.Type[CGAlgorithms]
    CGAlgorithms3D: typing.Type[CGAlgorithms3D]
    CGAlgorithmsDD: typing.Type[CGAlgorithmsDD]
    Centroid: typing.Type[Centroid]
    ConvexHull: typing.Type[ConvexHull]
    Distance: typing.Type[Distance]
    HCoordinate: typing.Type[HCoordinate]
    InteriorPoint: typing.Type[InteriorPoint]
    InteriorPointArea: typing.Type[InteriorPointArea]
    InteriorPointLine: typing.Type[InteriorPointLine]
    InteriorPointPoint: typing.Type[InteriorPointPoint]
    Intersection: typing.Type[Intersection]
    Length: typing.Type[Length]
    LineIntersector: typing.Type[LineIntersector]
    MinimumBoundingCircle: typing.Type[MinimumBoundingCircle]
    MinimumDiameter: typing.Type[MinimumDiameter]
    NotRepresentableException: typing.Type[NotRepresentableException]
    Orientation: typing.Type[Orientation]
    PointLocation: typing.Type[PointLocation]
    PointLocator: typing.Type[PointLocator]
    RayCrossingCounter: typing.Type[RayCrossingCounter]
    RectangleLineIntersector: typing.Type[RectangleLineIntersector]
    RobustDeterminant: typing.Type[RobustDeterminant]
    RobustLineIntersector: typing.Type[RobustLineIntersector]
    construct: org.locationtech.jts.algorithm.construct.__module_protocol__
    distance: org.locationtech.jts.algorithm.distance.__module_protocol__
    hull: org.locationtech.jts.algorithm.hull.__module_protocol__
    locate: org.locationtech.jts.algorithm.locate.__module_protocol__
    match: org.locationtech.jts.algorithm.match.__module_protocol__
