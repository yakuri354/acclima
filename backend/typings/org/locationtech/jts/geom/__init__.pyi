
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jpype
import org.locationtech.jts.algorithm
import org.locationtech.jts.geom.impl
import org.locationtech.jts.geom.prep
import org.locationtech.jts.geom.util
import typing



class Coordinate(java.lang.Comparable['Coordinate'], java.lang.Cloneable, java.io.Serializable):
    NULL_ORDINATE: typing.ClassVar[float] = ...
    X: typing.ClassVar[int] = ...
    Y: typing.ClassVar[int] = ...
    Z: typing.ClassVar[int] = ...
    M: typing.ClassVar[int] = ...
    x: float = ...
    y: float = ...
    z: float = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, coordinate: 'Coordinate'): ...
    def clone(self) -> typing.Any: ...
    def compareTo(self, coordinate: 'Coordinate') -> int: ...
    def copy(self) -> 'Coordinate': ...
    def create(self) -> 'Coordinate': ...
    def distance(self, coordinate: 'Coordinate') -> float: ...
    def distance3D(self, coordinate: 'Coordinate') -> float: ...
    def equalInZ(self, coordinate: 'Coordinate', double: float) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def equals2D(self, coordinate: 'Coordinate') -> bool: ...
    @typing.overload
    def equals2D(self, coordinate: 'Coordinate', double: float) -> bool: ...
    def equals3D(self, coordinate: 'Coordinate') -> bool: ...
    def getM(self) -> float: ...
    def getOrdinate(self, int: int) -> float: ...
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def getZ(self) -> float: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(double: float) -> int: ...
    def isValid(self) -> bool: ...
    def setCoordinate(self, coordinate: 'Coordinate') -> None: ...
    def setM(self, double: float) -> None: ...
    def setOrdinate(self, int: int, double: float) -> None: ...
    def setX(self, double: float) -> None: ...
    def setY(self, double: float) -> None: ...
    def setZ(self, double: float) -> None: ...
    def toString(self) -> str: ...
    class DimensionalComparator(java.util.Comparator['Coordinate']):
        @typing.overload
        def __init__(self): ...
        @typing.overload
        def __init__(self, int: int): ...
        @typing.overload
        def compare(self, coordinate: 'Coordinate', coordinate2: 'Coordinate') -> int: ...
        @typing.overload
        @staticmethod
        def compare(double: float, double2: float) -> int: ...

class CoordinateArrays:
    @staticmethod
    def atLeastNCoordinatesOrNothing(int: int, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> typing.MutableSequence[Coordinate]: ...
    @staticmethod
    def compare(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], coordinateArray2: typing.Union[typing.List[Coordinate], jpype.JArray]) -> int: ...
    @typing.overload
    @staticmethod
    def copyDeep(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> typing.MutableSequence[Coordinate]: ...
    @typing.overload
    @staticmethod
    def copyDeep(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], int: int, coordinateArray2: typing.Union[typing.List[Coordinate], jpype.JArray], int2: int, int3: int) -> None: ...
    @staticmethod
    def dimension(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> int: ...
    @typing.overload
    @staticmethod
    def enforceConsistency(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], int: int, int2: int) -> typing.MutableSequence[Coordinate]: ...
    @typing.overload
    @staticmethod
    def enforceConsistency(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> None: ...
    @staticmethod
    def envelope(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> 'Envelope': ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], coordinateArray2: typing.Union[typing.List[Coordinate], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], coordinateArray2: typing.Union[typing.List[Coordinate], jpype.JArray], comparator: typing.Union[java.util.Comparator, typing.Callable]) -> bool: ...
    @staticmethod
    def extract(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], int: int, int2: int) -> typing.MutableSequence[Coordinate]: ...
    @staticmethod
    def hasRepeatedOrInvalidPoints(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> bool: ...
    @staticmethod
    def hasRepeatedPoints(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> bool: ...
    @staticmethod
    def increasingDirection(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> int: ...
    @staticmethod
    def indexOf(coordinate: Coordinate, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> int: ...
    @staticmethod
    def intersection(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], envelope: 'Envelope') -> typing.MutableSequence[Coordinate]: ...
    @staticmethod
    def isRing(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> bool: ...
    @staticmethod
    def measures(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> int: ...
    @staticmethod
    def minCoordinate(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> Coordinate: ...
    @staticmethod
    def ptNotInList(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], coordinateArray2: typing.Union[typing.List[Coordinate], jpype.JArray]) -> Coordinate: ...
    @staticmethod
    def removeNull(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> typing.MutableSequence[Coordinate]: ...
    @staticmethod
    def removeRepeatedOrInvalidPoints(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> typing.MutableSequence[Coordinate]: ...
    @staticmethod
    def removeRepeatedPoints(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> typing.MutableSequence[Coordinate]: ...
    @staticmethod
    def reverse(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> None: ...
    @typing.overload
    @staticmethod
    def scroll(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], int: int) -> None: ...
    @typing.overload
    @staticmethod
    def scroll(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], int: int, boolean: bool) -> None: ...
    @typing.overload
    @staticmethod
    def scroll(coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], coordinate2: Coordinate) -> None: ...
    @staticmethod
    def toCoordinateArray(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> typing.MutableSequence[Coordinate]: ...
    class BidirectionalComparator(java.util.Comparator):
        def __init__(self): ...
        def OLDcompare(self, object: typing.Any, object2: typing.Any) -> int: ...
        def compare(self, object: typing.Any, object2: typing.Any) -> int: ...
    class ForwardComparator(java.util.Comparator):
        def __init__(self): ...
        def compare(self, object: typing.Any, object2: typing.Any) -> int: ...

class CoordinateFilter:
    def filter(self, coordinate: Coordinate) -> None: ...

class CoordinateList(java.util.ArrayList[Coordinate]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]): ...
    @typing.overload
    def __init__(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], boolean: bool): ...
    @typing.overload
    def add(self, e: typing.Any) -> bool: ...
    @typing.overload
    def add(self, object: typing.Any, boolean: bool) -> bool: ...
    @typing.overload
    def add(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], boolean: bool) -> bool: ...
    @typing.overload
    def add(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], boolean: bool, boolean2: bool) -> bool: ...
    @typing.overload
    def add(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], boolean: bool, int: int, int2: int) -> bool: ...
    @typing.overload
    def add(self, int: int, e: typing.Any) -> None: ...
    @typing.overload
    def add(self, int: int, coordinate: Coordinate, boolean: bool) -> None: ...
    @typing.overload
    def add(self, coordinate: Coordinate, boolean: bool) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[java.util.Collection[Coordinate], typing.Sequence[Coordinate], typing.Set[Coordinate]], boolean: bool) -> bool: ...
    def clone(self) -> typing.Any: ...
    def closeRing(self) -> None: ...
    def getCoordinate(self, int: int) -> Coordinate: ...
    @typing.overload
    def toCoordinateArray(self) -> typing.MutableSequence[Coordinate]: ...
    @typing.overload
    def toCoordinateArray(self, boolean: bool) -> typing.MutableSequence[Coordinate]: ...

class CoordinateSequence(java.lang.Cloneable):
    X: typing.ClassVar[int] = ...
    Y: typing.ClassVar[int] = ...
    Z: typing.ClassVar[int] = ...
    M: typing.ClassVar[int] = ...
    def clone(self) -> typing.Any: ...
    def copy(self) -> 'CoordinateSequence': ...
    def createCoordinate(self) -> Coordinate: ...
    def expandEnvelope(self, envelope: 'Envelope') -> 'Envelope': ...
    @typing.overload
    def getCoordinate(self, int: int) -> Coordinate: ...
    @typing.overload
    def getCoordinate(self, int: int, coordinate: Coordinate) -> None: ...
    def getCoordinateCopy(self, int: int) -> Coordinate: ...
    def getDimension(self) -> int: ...
    def getM(self, int: int) -> float: ...
    def getMeasures(self) -> int: ...
    def getOrdinate(self, int: int, int2: int) -> float: ...
    def getX(self, int: int) -> float: ...
    def getY(self, int: int) -> float: ...
    def getZ(self, int: int) -> float: ...
    def hasM(self) -> bool: ...
    def hasZ(self) -> bool: ...
    def setOrdinate(self, int: int, int2: int, double: float) -> None: ...
    def size(self) -> int: ...
    def toCoordinateArray(self) -> typing.MutableSequence[Coordinate]: ...

class CoordinateSequenceComparator(java.util.Comparator):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def compare(self, object: typing.Any, object2: typing.Any) -> int: ...
    @typing.overload
    @staticmethod
    def compare(double: float, double2: float) -> int: ...

class CoordinateSequenceFactory:
    @typing.overload
    def create(self, int: int, int2: int) -> CoordinateSequence: ...
    @typing.overload
    def create(self, coordinateSequence: CoordinateSequence) -> CoordinateSequence: ...
    @typing.overload
    def create(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> CoordinateSequence: ...
    @typing.overload
    def create(self, int: int, int2: int, int3: int) -> CoordinateSequence: ...

class CoordinateSequenceFilter:
    def filter(self, coordinateSequence: CoordinateSequence, int: int) -> None: ...
    def isDone(self) -> bool: ...
    def isGeometryChanged(self) -> bool: ...

class CoordinateSequences:
    def __init__(self): ...
    @staticmethod
    def copy(coordinateSequence: CoordinateSequence, int: int, coordinateSequence2: CoordinateSequence, int2: int, int3: int) -> None: ...
    @staticmethod
    def copyCoord(coordinateSequence: CoordinateSequence, int: int, coordinateSequence2: CoordinateSequence, int2: int) -> None: ...
    @staticmethod
    def ensureValidRing(coordinateSequenceFactory: CoordinateSequenceFactory, coordinateSequence2: CoordinateSequence) -> CoordinateSequence: ...
    @staticmethod
    def extend(coordinateSequenceFactory: CoordinateSequenceFactory, coordinateSequence2: CoordinateSequence, int: int) -> CoordinateSequence: ...
    @staticmethod
    def indexOf(coordinate: Coordinate, coordinateSequence: CoordinateSequence) -> int: ...
    @staticmethod
    def isEqual(coordinateSequence: CoordinateSequence, coordinateSequence2: CoordinateSequence) -> bool: ...
    @staticmethod
    def isRing(coordinateSequence: CoordinateSequence) -> bool: ...
    @staticmethod
    def minCoordinate(coordinateSequence: CoordinateSequence) -> Coordinate: ...
    @typing.overload
    @staticmethod
    def minCoordinateIndex(coordinateSequence: CoordinateSequence) -> int: ...
    @typing.overload
    @staticmethod
    def minCoordinateIndex(coordinateSequence: CoordinateSequence, int: int, int2: int) -> int: ...
    @staticmethod
    def reverse(coordinateSequence: CoordinateSequence) -> None: ...
    @typing.overload
    @staticmethod
    def scroll(coordinateSequence: CoordinateSequence, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def scroll(coordinateSequence: CoordinateSequence, int: int, boolean: bool) -> None: ...
    @typing.overload
    @staticmethod
    def scroll(coordinateSequence: CoordinateSequence, coordinate2: Coordinate) -> None: ...
    @staticmethod
    def swap(coordinateSequence: CoordinateSequence, int: int, int2: int) -> None: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(coordinateSequence: CoordinateSequence) -> str: ...

class Coordinates:
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def create(int: int) -> Coordinate: ...
    @typing.overload
    @staticmethod
    def create(int: int, int2: int) -> Coordinate: ...
    @staticmethod
    def dimension(coordinate: Coordinate) -> int: ...
    @staticmethod
    def measures(coordinate: Coordinate) -> int: ...

class Dimension:
    P: typing.ClassVar[int] = ...
    L: typing.ClassVar[int] = ...
    A: typing.ClassVar[int] = ...
    FALSE: typing.ClassVar[int] = ...
    TRUE: typing.ClassVar[int] = ...
    DONTCARE: typing.ClassVar[int] = ...
    SYM_FALSE: typing.ClassVar[str] = ...
    SYM_TRUE: typing.ClassVar[str] = ...
    SYM_DONTCARE: typing.ClassVar[str] = ...
    SYM_P: typing.ClassVar[str] = ...
    SYM_L: typing.ClassVar[str] = ...
    SYM_A: typing.ClassVar[str] = ...
    def __init__(self): ...
    @staticmethod
    def toDimensionSymbol(int: int) -> str: ...
    @staticmethod
    def toDimensionValue(char: str) -> int: ...

class Envelope(java.lang.Comparable, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, coordinate: Coordinate): ...
    @typing.overload
    def __init__(self, coordinate: Coordinate, coordinate2: Coordinate): ...
    @typing.overload
    def __init__(self, envelope: 'Envelope'): ...
    def centre(self) -> Coordinate: ...
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def contains(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def contains(self, coordinate: Coordinate) -> bool: ...
    @typing.overload
    def contains(self, envelope: 'Envelope') -> bool: ...
    def copy(self) -> 'Envelope': ...
    @typing.overload
    def covers(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def covers(self, coordinate: Coordinate) -> bool: ...
    @typing.overload
    def covers(self, envelope: 'Envelope') -> bool: ...
    def disjoint(self, envelope: 'Envelope') -> bool: ...
    def distance(self, envelope: 'Envelope') -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def expandBy(self, double: float) -> None: ...
    @typing.overload
    def expandBy(self, double: float, double2: float) -> None: ...
    @typing.overload
    def expandToInclude(self, double: float, double2: float) -> None: ...
    @typing.overload
    def expandToInclude(self, coordinate: Coordinate) -> None: ...
    @typing.overload
    def expandToInclude(self, envelope: 'Envelope') -> None: ...
    def getArea(self) -> float: ...
    def getDiameter(self) -> float: ...
    def getHeight(self) -> float: ...
    def getMaxX(self) -> float: ...
    def getMaxY(self) -> float: ...
    def getMinX(self) -> float: ...
    def getMinY(self) -> float: ...
    def getWidth(self) -> float: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def init(self) -> None: ...
    @typing.overload
    def init(self, double: float, double2: float, double3: float, double4: float) -> None: ...
    @typing.overload
    def init(self, coordinate: Coordinate) -> None: ...
    @typing.overload
    def init(self, coordinate: Coordinate, coordinate2: Coordinate) -> None: ...
    @typing.overload
    def init(self, envelope: 'Envelope') -> None: ...
    def intersection(self, envelope: 'Envelope') -> 'Envelope': ...
    @typing.overload
    def intersects(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def intersects(self, coordinate: Coordinate) -> bool: ...
    @typing.overload
    def intersects(self, coordinate: Coordinate, coordinate2: Coordinate) -> bool: ...
    @typing.overload
    def intersects(self, envelope: 'Envelope') -> bool: ...
    @typing.overload
    @staticmethod
    def intersects(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> bool: ...
    @typing.overload
    @staticmethod
    def intersects(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate, coordinate4: Coordinate) -> bool: ...
    def isNull(self) -> bool: ...
    def maxExtent(self) -> float: ...
    def minExtent(self) -> float: ...
    @typing.overload
    def overlaps(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def overlaps(self, coordinate: Coordinate) -> bool: ...
    @typing.overload
    def overlaps(self, envelope: 'Envelope') -> bool: ...
    def setToNull(self) -> None: ...
    def toString(self) -> str: ...
    def translate(self, double: float, double2: float) -> None: ...

class Geometry(java.lang.Cloneable, java.lang.Comparable, java.io.Serializable):
    TYPENAME_POINT: typing.ClassVar[str] = ...
    TYPENAME_MULTIPOINT: typing.ClassVar[str] = ...
    TYPENAME_LINESTRING: typing.ClassVar[str] = ...
    TYPENAME_LINEARRING: typing.ClassVar[str] = ...
    TYPENAME_MULTILINESTRING: typing.ClassVar[str] = ...
    TYPENAME_POLYGON: typing.ClassVar[str] = ...
    TYPENAME_MULTIPOLYGON: typing.ClassVar[str] = ...
    TYPENAME_GEOMETRYCOLLECTION: typing.ClassVar[str] = ...
    def __init__(self, geometryFactory: 'GeometryFactory'): ...
    @typing.overload
    def apply(self, coordinateFilter: CoordinateFilter) -> None: ...
    @typing.overload
    def apply(self, coordinateSequenceFilter: CoordinateSequenceFilter) -> None: ...
    @typing.overload
    def apply(self, geometryComponentFilter: 'GeometryComponentFilter') -> None: ...
    @typing.overload
    def apply(self, geometryFilter: 'GeometryFilter') -> None: ...
    @typing.overload
    def buffer(self, double: float) -> 'Geometry': ...
    @typing.overload
    def buffer(self, double: float, int: int) -> 'Geometry': ...
    @typing.overload
    def buffer(self, double: float, int: int, int2: int) -> 'Geometry': ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def compareTo(self, object: typing.Any, coordinateSequenceComparator: CoordinateSequenceComparator) -> int: ...
    def contains(self, geometry: 'Geometry') -> bool: ...
    def convexHull(self) -> 'Geometry': ...
    def copy(self) -> 'Geometry': ...
    def coveredBy(self, geometry: 'Geometry') -> bool: ...
    def covers(self, geometry: 'Geometry') -> bool: ...
    def crosses(self, geometry: 'Geometry') -> bool: ...
    def difference(self, geometry: 'Geometry') -> 'Geometry': ...
    def disjoint(self, geometry: 'Geometry') -> bool: ...
    def distance(self, geometry: 'Geometry') -> float: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, geometry: 'Geometry') -> bool: ...
    @typing.overload
    def equalsExact(self, geometry: 'Geometry', double: float) -> bool: ...
    @typing.overload
    def equalsExact(self, geometry: 'Geometry') -> bool: ...
    def equalsNorm(self, geometry: 'Geometry') -> bool: ...
    def equalsTopo(self, geometry: 'Geometry') -> bool: ...
    def geometryChanged(self) -> None: ...
    def getArea(self) -> float: ...
    def getBoundary(self) -> 'Geometry': ...
    def getBoundaryDimension(self) -> int: ...
    def getCentroid(self) -> 'Point': ...
    def getCoordinate(self) -> Coordinate: ...
    def getCoordinates(self) -> typing.MutableSequence[Coordinate]: ...
    def getDimension(self) -> int: ...
    def getEnvelope(self) -> 'Geometry': ...
    def getEnvelopeInternal(self) -> Envelope: ...
    def getFactory(self) -> 'GeometryFactory': ...
    def getGeometryN(self, int: int) -> 'Geometry': ...
    def getGeometryType(self) -> str: ...
    def getInteriorPoint(self) -> 'Point': ...
    def getLength(self) -> float: ...
    def getNumGeometries(self) -> int: ...
    def getNumPoints(self) -> int: ...
    def getPrecisionModel(self) -> 'PrecisionModel': ...
    def getSRID(self) -> int: ...
    def getUserData(self) -> typing.Any: ...
    def hashCode(self) -> int: ...
    def intersection(self, geometry: 'Geometry') -> 'Geometry': ...
    def intersects(self, geometry: 'Geometry') -> bool: ...
    def isEmpty(self) -> bool: ...
    def isRectangle(self) -> bool: ...
    def isSimple(self) -> bool: ...
    def isValid(self) -> bool: ...
    def isWithinDistance(self, geometry: 'Geometry', double: float) -> bool: ...
    def norm(self) -> 'Geometry': ...
    def normalize(self) -> None: ...
    def overlaps(self, geometry: 'Geometry') -> bool: ...
    @typing.overload
    def relate(self, geometry: 'Geometry', string: str) -> bool: ...
    @typing.overload
    def relate(self, geometry: 'Geometry') -> 'IntersectionMatrix': ...
    def reverse(self) -> 'Geometry': ...
    def setSRID(self, int: int) -> None: ...
    def setUserData(self, object: typing.Any) -> None: ...
    def symDifference(self, geometry: 'Geometry') -> 'Geometry': ...
    def toString(self) -> str: ...
    def toText(self) -> str: ...
    def touches(self, geometry: 'Geometry') -> bool: ...
    @typing.overload
    def union(self) -> 'Geometry': ...
    @typing.overload
    def union(self, geometry: 'Geometry') -> 'Geometry': ...
    def within(self, geometry: 'Geometry') -> bool: ...

class GeometryCollectionIterator(java.util.Iterator):
    def __init__(self, geometry: Geometry): ...
    def hasNext(self) -> bool: ...
    def next(self) -> typing.Any: ...
    def remove(self) -> None: ...

class GeometryComponentFilter:
    def filter(self, geometry: Geometry) -> None: ...

class GeometryFactory(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, coordinateSequenceFactory: CoordinateSequenceFactory): ...
    @typing.overload
    def __init__(self, precisionModel: 'PrecisionModel'): ...
    @typing.overload
    def __init__(self, precisionModel: 'PrecisionModel', int: int): ...
    @typing.overload
    def __init__(self, precisionModel: 'PrecisionModel', int: int, coordinateSequenceFactory: CoordinateSequenceFactory): ...
    def buildGeometry(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> Geometry: ...
    def createEmpty(self, int: int) -> Geometry: ...
    def createGeometry(self, geometry: Geometry) -> Geometry: ...
    @typing.overload
    def createGeometryCollection(self) -> 'GeometryCollection': ...
    @typing.overload
    def createGeometryCollection(self, geometryArray: typing.Union[typing.List[Geometry], jpype.JArray]) -> 'GeometryCollection': ...
    @typing.overload
    def createLineString(self) -> 'LineString': ...
    @typing.overload
    def createLineString(self, coordinateSequence: CoordinateSequence) -> 'LineString': ...
    @typing.overload
    def createLineString(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> 'LineString': ...
    @typing.overload
    def createLinearRing(self) -> 'LinearRing': ...
    @typing.overload
    def createLinearRing(self, coordinateSequence: CoordinateSequence) -> 'LinearRing': ...
    @typing.overload
    def createLinearRing(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> 'LinearRing': ...
    @typing.overload
    def createMultiLineString(self) -> 'MultiLineString': ...
    @typing.overload
    def createMultiLineString(self, lineStringArray: typing.Union[typing.List['LineString'], jpype.JArray]) -> 'MultiLineString': ...
    @typing.overload
    def createMultiPoint(self) -> 'MultiPoint': ...
    @typing.overload
    def createMultiPoint(self, coordinateSequence: CoordinateSequence) -> 'MultiPoint': ...
    @typing.overload
    def createMultiPoint(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> 'MultiPoint': ...
    @typing.overload
    def createMultiPoint(self, pointArray: typing.Union[typing.List['Point'], jpype.JArray]) -> 'MultiPoint': ...
    def createMultiPointFromCoords(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> 'MultiPoint': ...
    @typing.overload
    def createMultiPolygon(self) -> 'MultiPolygon': ...
    @typing.overload
    def createMultiPolygon(self, polygonArray: typing.Union[typing.List['Polygon'], jpype.JArray]) -> 'MultiPolygon': ...
    @typing.overload
    def createPoint(self) -> 'Point': ...
    @typing.overload
    def createPoint(self, coordinate: Coordinate) -> 'Point': ...
    @typing.overload
    def createPoint(self, coordinateSequence: CoordinateSequence) -> 'Point': ...
    @staticmethod
    def createPointFromInternalCoord(coordinate: Coordinate, geometry: Geometry) -> 'Point': ...
    @typing.overload
    def createPolygon(self) -> 'Polygon': ...
    @typing.overload
    def createPolygon(self, coordinateSequence: CoordinateSequence) -> 'Polygon': ...
    @typing.overload
    def createPolygon(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray]) -> 'Polygon': ...
    @typing.overload
    def createPolygon(self, linearRing: 'LinearRing') -> 'Polygon': ...
    @typing.overload
    def createPolygon(self, linearRing: 'LinearRing', linearRingArray: typing.Union[typing.List['LinearRing'], jpype.JArray]) -> 'Polygon': ...
    def getCoordinateSequenceFactory(self) -> CoordinateSequenceFactory: ...
    def getPrecisionModel(self) -> 'PrecisionModel': ...
    def getSRID(self) -> int: ...
    def toGeometry(self, envelope: Envelope) -> Geometry: ...
    @staticmethod
    def toGeometryArray(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> typing.MutableSequence[Geometry]: ...
    @staticmethod
    def toLineStringArray(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> typing.MutableSequence['LineString']: ...
    @staticmethod
    def toLinearRingArray(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> typing.MutableSequence['LinearRing']: ...
    @staticmethod
    def toMultiLineStringArray(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> typing.MutableSequence['MultiLineString']: ...
    @staticmethod
    def toMultiPointArray(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> typing.MutableSequence['MultiPoint']: ...
    @staticmethod
    def toMultiPolygonArray(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> typing.MutableSequence['MultiPolygon']: ...
    @staticmethod
    def toPointArray(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> typing.MutableSequence['Point']: ...
    @staticmethod
    def toPolygonArray(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> typing.MutableSequence['Polygon']: ...

class GeometryFilter:
    def filter(self, geometry: Geometry) -> None: ...

class IntersectionMatrix(java.lang.Cloneable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, intersectionMatrix: 'IntersectionMatrix'): ...
    def add(self, intersectionMatrix: 'IntersectionMatrix') -> None: ...
    def get(self, int: int, int2: int) -> int: ...
    def isContains(self) -> bool: ...
    def isCoveredBy(self) -> bool: ...
    def isCovers(self) -> bool: ...
    def isCrosses(self, int: int, int2: int) -> bool: ...
    def isDisjoint(self) -> bool: ...
    def isEquals(self, int: int, int2: int) -> bool: ...
    def isIntersects(self) -> bool: ...
    def isOverlaps(self, int: int, int2: int) -> bool: ...
    def isTouches(self, int: int, int2: int) -> bool: ...
    @staticmethod
    def isTrue(int: int) -> bool: ...
    def isWithin(self) -> bool: ...
    @typing.overload
    def matches(self, string: str) -> bool: ...
    @typing.overload
    @staticmethod
    def matches(int: int, char: str) -> bool: ...
    @typing.overload
    @staticmethod
    def matches(string: str, string2: str) -> bool: ...
    @typing.overload
    def set(self, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def set(self, string: str) -> None: ...
    def setAll(self, int: int) -> None: ...
    @typing.overload
    def setAtLeast(self, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def setAtLeast(self, string: str) -> None: ...
    def setAtLeastIfValid(self, int: int, int2: int, int3: int) -> None: ...
    def toString(self) -> str: ...
    def transpose(self) -> 'IntersectionMatrix': ...

class LineSegment(java.lang.Comparable, java.io.Serializable):
    p0: Coordinate = ...
    p1: Coordinate = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, coordinate: Coordinate, coordinate2: Coordinate): ...
    @typing.overload
    def __init__(self, lineSegment: 'LineSegment'): ...
    def OLDhashCode(self) -> int: ...
    def angle(self) -> float: ...
    def closestPoint(self, coordinate: Coordinate) -> Coordinate: ...
    def closestPoints(self, lineSegment: 'LineSegment') -> typing.MutableSequence[Coordinate]: ...
    def compareTo(self, object: typing.Any) -> int: ...
    @typing.overload
    def distance(self, coordinate: Coordinate) -> float: ...
    @typing.overload
    def distance(self, lineSegment: 'LineSegment') -> float: ...
    def distancePerpendicular(self, coordinate: Coordinate) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def equalsTopo(self, lineSegment: 'LineSegment') -> bool: ...
    def getCoordinate(self, int: int) -> Coordinate: ...
    def getLength(self) -> float: ...
    def hashCode(self) -> int: ...
    def intersection(self, lineSegment: 'LineSegment') -> Coordinate: ...
    def isHorizontal(self) -> bool: ...
    def isVertical(self) -> bool: ...
    def lineIntersection(self, lineSegment: 'LineSegment') -> Coordinate: ...
    def maxX(self) -> float: ...
    def maxY(self) -> float: ...
    @typing.overload
    def midPoint(self) -> Coordinate: ...
    @typing.overload
    @staticmethod
    def midPoint(coordinate: Coordinate, coordinate2: Coordinate) -> Coordinate: ...
    def minX(self) -> float: ...
    def minY(self) -> float: ...
    def normalize(self) -> None: ...
    def offset(self, double: float) -> 'LineSegment': ...
    @typing.overload
    def orientationIndex(self, coordinate: Coordinate) -> int: ...
    @typing.overload
    def orientationIndex(self, lineSegment: 'LineSegment') -> int: ...
    def pointAlong(self, double: float) -> Coordinate: ...
    def pointAlongOffset(self, double: float, double2: float) -> Coordinate: ...
    @typing.overload
    def project(self, coordinate: Coordinate) -> Coordinate: ...
    @typing.overload
    def project(self, lineSegment: 'LineSegment') -> 'LineSegment': ...
    def projectionFactor(self, coordinate: Coordinate) -> float: ...
    def reflect(self, coordinate: Coordinate) -> Coordinate: ...
    def reverse(self) -> None: ...
    def segmentFraction(self, coordinate: Coordinate) -> float: ...
    @typing.overload
    def setCoordinates(self, coordinate: Coordinate, coordinate2: Coordinate) -> None: ...
    @typing.overload
    def setCoordinates(self, lineSegment: 'LineSegment') -> None: ...
    def toGeometry(self, geometryFactory: GeometryFactory) -> 'LineString': ...
    def toString(self) -> str: ...

class Lineal: ...

class Location:
    INTERIOR: typing.ClassVar[int] = ...
    BOUNDARY: typing.ClassVar[int] = ...
    EXTERIOR: typing.ClassVar[int] = ...
    NONE: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def toLocationSymbol(int: int) -> str: ...

class OctagonalEnvelope:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, coordinate: Coordinate): ...
    @typing.overload
    def __init__(self, coordinate: Coordinate, coordinate2: Coordinate): ...
    @typing.overload
    def __init__(self, envelope: Envelope): ...
    @typing.overload
    def __init__(self, geometry: Geometry): ...
    @typing.overload
    def __init__(self, octagonalEnvelope: 'OctagonalEnvelope'): ...
    def contains(self, octagonalEnvelope: 'OctagonalEnvelope') -> bool: ...
    def expandBy(self, double: float) -> None: ...
    @typing.overload
    def expandToInclude(self, double: float, double2: float) -> 'OctagonalEnvelope': ...
    @typing.overload
    def expandToInclude(self, coordinate: Coordinate) -> 'OctagonalEnvelope': ...
    @typing.overload
    def expandToInclude(self, coordinateSequence: CoordinateSequence) -> 'OctagonalEnvelope': ...
    @typing.overload
    def expandToInclude(self, envelope: Envelope) -> 'OctagonalEnvelope': ...
    @typing.overload
    def expandToInclude(self, octagonalEnvelope: 'OctagonalEnvelope') -> 'OctagonalEnvelope': ...
    @typing.overload
    def expandToInclude(self, geometry: Geometry) -> None: ...
    def getMaxA(self) -> float: ...
    def getMaxB(self) -> float: ...
    def getMaxX(self) -> float: ...
    def getMaxY(self) -> float: ...
    def getMinA(self) -> float: ...
    def getMinB(self) -> float: ...
    def getMinX(self) -> float: ...
    def getMinY(self) -> float: ...
    @typing.overload
    def intersects(self, coordinate: Coordinate) -> bool: ...
    @typing.overload
    def intersects(self, octagonalEnvelope: 'OctagonalEnvelope') -> bool: ...
    def isNull(self) -> bool: ...
    @staticmethod
    def octagonalEnvelope(geometry: Geometry) -> Geometry: ...
    def setToNull(self) -> None: ...
    def toGeometry(self, geometryFactory: GeometryFactory) -> Geometry: ...

class Polygonal: ...

class Position:
    ON: typing.ClassVar[int] = ...
    LEFT: typing.ClassVar[int] = ...
    RIGHT: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def opposite(int: int) -> int: ...

class PrecisionModel(java.io.Serializable, java.lang.Comparable):
    FIXED: typing.ClassVar['PrecisionModel.Type'] = ...
    FLOATING: typing.ClassVar['PrecisionModel.Type'] = ...
    FLOATING_SINGLE: typing.ClassVar['PrecisionModel.Type'] = ...
    maximumPreciseValue: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, type: 'PrecisionModel.Type'): ...
    @typing.overload
    def __init__(self, precisionModel: 'PrecisionModel'): ...
    def compareTo(self, object: typing.Any) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getMaximumSignificantDigits(self) -> int: ...
    def getOffsetX(self) -> float: ...
    def getOffsetY(self) -> float: ...
    def getScale(self) -> float: ...
    def getType(self) -> 'PrecisionModel.Type': ...
    def gridSize(self) -> float: ...
    def hashCode(self) -> int: ...
    def isFloating(self) -> bool: ...
    @typing.overload
    def makePrecise(self, double: float) -> float: ...
    @typing.overload
    def makePrecise(self, coordinate: Coordinate) -> None: ...
    @staticmethod
    def mostPrecise(precisionModel: 'PrecisionModel', precisionModel2: 'PrecisionModel') -> 'PrecisionModel': ...
    @typing.overload
    def toExternal(self, coordinate: Coordinate) -> Coordinate: ...
    @typing.overload
    def toExternal(self, coordinate: Coordinate, coordinate2: Coordinate) -> None: ...
    @typing.overload
    def toInternal(self, coordinate: Coordinate) -> Coordinate: ...
    @typing.overload
    def toInternal(self, coordinate: Coordinate, coordinate2: Coordinate) -> None: ...
    def toString(self) -> str: ...
    class Type(java.io.Serializable):
        def __init__(self, string: str): ...
        def toString(self) -> str: ...

class Puntal: ...

class Quadrant:
    NE: typing.ClassVar[int] = ...
    NW: typing.ClassVar[int] = ...
    SW: typing.ClassVar[int] = ...
    SE: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def commonHalfPlane(int: int, int2: int) -> int: ...
    @staticmethod
    def isInHalfPlane(int: int, int2: int) -> bool: ...
    @staticmethod
    def isNorthern(int: int) -> bool: ...
    @staticmethod
    def isOpposite(int: int, int2: int) -> bool: ...
    @typing.overload
    @staticmethod
    def quadrant(double: float, double2: float) -> int: ...
    @typing.overload
    @staticmethod
    def quadrant(coordinate: Coordinate, coordinate2: Coordinate) -> int: ...

class TopologyException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, coordinate: Coordinate): ...
    def getCoordinate(self) -> Coordinate: ...

class Triangle:
    p0: Coordinate = ...
    p1: Coordinate = ...
    p2: Coordinate = ...
    def __init__(self, coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate): ...
    @staticmethod
    def angleBisector(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> Coordinate: ...
    @typing.overload
    def area(self) -> float: ...
    @typing.overload
    @staticmethod
    def area(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> float: ...
    @typing.overload
    def area3D(self) -> float: ...
    @typing.overload
    @staticmethod
    def area3D(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> float: ...
    @typing.overload
    def centroid(self) -> Coordinate: ...
    @typing.overload
    @staticmethod
    def centroid(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> Coordinate: ...
    @typing.overload
    def circumcentre(self) -> Coordinate: ...
    @typing.overload
    @staticmethod
    def circumcentre(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> Coordinate: ...
    @staticmethod
    def circumcentreDD(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> Coordinate: ...
    @typing.overload
    def inCentre(self) -> Coordinate: ...
    @typing.overload
    @staticmethod
    def inCentre(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> Coordinate: ...
    @typing.overload
    def interpolateZ(self, coordinate: Coordinate) -> float: ...
    @typing.overload
    @staticmethod
    def interpolateZ(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate, coordinate4: Coordinate) -> float: ...
    @staticmethod
    def intersects(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate, coordinate4: Coordinate) -> bool: ...
    @typing.overload
    def isAcute(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isAcute(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> bool: ...
    @typing.overload
    def isCCW(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isCCW(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> bool: ...
    @typing.overload
    def length(self) -> float: ...
    @typing.overload
    @staticmethod
    def length(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> float: ...
    @typing.overload
    def longestSideLength(self) -> float: ...
    @typing.overload
    @staticmethod
    def longestSideLength(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> float: ...
    @staticmethod
    def perpendicularBisector(coordinate: Coordinate, coordinate2: Coordinate) -> org.locationtech.jts.algorithm.HCoordinate: ...
    @typing.overload
    def signedArea(self) -> float: ...
    @typing.overload
    @staticmethod
    def signedArea(coordinate: Coordinate, coordinate2: Coordinate, coordinate3: Coordinate) -> float: ...

class CoordinateXY(Coordinate):
    X: typing.ClassVar[int] = ...
    Y: typing.ClassVar[int] = ...
    Z: typing.ClassVar[int] = ...
    M: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, coordinate: Coordinate): ...
    @typing.overload
    def __init__(self, coordinateXY: 'CoordinateXY'): ...
    def copy(self) -> 'CoordinateXY': ...
    def create(self) -> Coordinate: ...
    def getOrdinate(self, int: int) -> float: ...
    def getZ(self) -> float: ...
    def setCoordinate(self, coordinate: Coordinate) -> None: ...
    def setOrdinate(self, int: int, double: float) -> None: ...
    def setZ(self, double: float) -> None: ...
    def toString(self) -> str: ...

class CoordinateXYM(Coordinate):
    X: typing.ClassVar[int] = ...
    Y: typing.ClassVar[int] = ...
    Z: typing.ClassVar[int] = ...
    M: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, coordinate: Coordinate): ...
    @typing.overload
    def __init__(self, coordinateXYM: 'CoordinateXYM'): ...
    def copy(self) -> 'CoordinateXYM': ...
    def create(self) -> Coordinate: ...
    def getM(self) -> float: ...
    def getOrdinate(self, int: int) -> float: ...
    def getZ(self) -> float: ...
    def setCoordinate(self, coordinate: Coordinate) -> None: ...
    def setM(self, double: float) -> None: ...
    def setOrdinate(self, int: int, double: float) -> None: ...
    def setZ(self, double: float) -> None: ...
    def toString(self) -> str: ...

class CoordinateXYZM(Coordinate):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, coordinate: Coordinate): ...
    @typing.overload
    def __init__(self, coordinateXYZM: 'CoordinateXYZM'): ...
    def copy(self) -> 'CoordinateXYZM': ...
    def create(self) -> Coordinate: ...
    def getM(self) -> float: ...
    def getOrdinate(self, int: int) -> float: ...
    def setCoordinate(self, coordinate: Coordinate) -> None: ...
    def setM(self, double: float) -> None: ...
    def setOrdinate(self, int: int, double: float) -> None: ...
    def toString(self) -> str: ...

class GeometryCollection(Geometry):
    @typing.overload
    def __init__(self, geometryArray: typing.Union[typing.List[Geometry], jpype.JArray], geometryFactory: GeometryFactory): ...
    @typing.overload
    def __init__(self, geometryArray: typing.Union[typing.List[Geometry], jpype.JArray], precisionModel: PrecisionModel, int: int): ...
    @typing.overload
    def apply(self, coordinateFilter: CoordinateFilter) -> None: ...
    @typing.overload
    def apply(self, coordinateSequenceFilter: CoordinateSequenceFilter) -> None: ...
    @typing.overload
    def apply(self, geometryComponentFilter: GeometryComponentFilter) -> None: ...
    @typing.overload
    def apply(self, geometryFilter: GeometryFilter) -> None: ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry) -> bool: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry, double: float) -> bool: ...
    def getArea(self) -> float: ...
    def getBoundary(self) -> Geometry: ...
    def getBoundaryDimension(self) -> int: ...
    def getCoordinate(self) -> Coordinate: ...
    def getCoordinates(self) -> typing.MutableSequence[Coordinate]: ...
    def getDimension(self) -> int: ...
    def getGeometryN(self, int: int) -> Geometry: ...
    def getGeometryType(self) -> str: ...
    def getLength(self) -> float: ...
    def getNumGeometries(self) -> int: ...
    def getNumPoints(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def normalize(self) -> None: ...
    def reverse(self) -> 'GeometryCollection': ...

class LineString(Geometry, Lineal):
    MINIMUM_VALID_SIZE: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, coordinateSequence: CoordinateSequence, geometryFactory: GeometryFactory): ...
    @typing.overload
    def __init__(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], precisionModel: PrecisionModel, int: int): ...
    @typing.overload
    def apply(self, coordinateFilter: CoordinateFilter) -> None: ...
    @typing.overload
    def apply(self, coordinateSequenceFilter: CoordinateSequenceFilter) -> None: ...
    @typing.overload
    def apply(self, geometryComponentFilter: GeometryComponentFilter) -> None: ...
    @typing.overload
    def apply(self, geometryFilter: GeometryFilter) -> None: ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry) -> bool: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry, double: float) -> bool: ...
    def getBoundary(self) -> Geometry: ...
    def getBoundaryDimension(self) -> int: ...
    def getCoordinate(self) -> Coordinate: ...
    def getCoordinateN(self, int: int) -> Coordinate: ...
    def getCoordinateSequence(self) -> CoordinateSequence: ...
    def getCoordinates(self) -> typing.MutableSequence[Coordinate]: ...
    def getDimension(self) -> int: ...
    def getEndPoint(self) -> 'Point': ...
    def getGeometryType(self) -> str: ...
    def getLength(self) -> float: ...
    def getNumPoints(self) -> int: ...
    def getPointN(self, int: int) -> 'Point': ...
    def getStartPoint(self) -> 'Point': ...
    def isClosed(self) -> bool: ...
    def isCoordinate(self, coordinate: Coordinate) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isRing(self) -> bool: ...
    def normalize(self) -> None: ...
    def reverse(self) -> 'LineString': ...

class Point(Geometry, Puntal):
    @typing.overload
    def __init__(self, coordinate: Coordinate, precisionModel: PrecisionModel, int: int): ...
    @typing.overload
    def __init__(self, coordinateSequence: CoordinateSequence, geometryFactory: GeometryFactory): ...
    @typing.overload
    def apply(self, coordinateFilter: CoordinateFilter) -> None: ...
    @typing.overload
    def apply(self, coordinateSequenceFilter: CoordinateSequenceFilter) -> None: ...
    @typing.overload
    def apply(self, geometryComponentFilter: GeometryComponentFilter) -> None: ...
    @typing.overload
    def apply(self, geometryFilter: GeometryFilter) -> None: ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry) -> bool: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry, double: float) -> bool: ...
    def getBoundary(self) -> Geometry: ...
    def getBoundaryDimension(self) -> int: ...
    def getCoordinate(self) -> Coordinate: ...
    def getCoordinateSequence(self) -> CoordinateSequence: ...
    def getCoordinates(self) -> typing.MutableSequence[Coordinate]: ...
    def getDimension(self) -> int: ...
    def getGeometryType(self) -> str: ...
    def getNumPoints(self) -> int: ...
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def isEmpty(self) -> bool: ...
    def isSimple(self) -> bool: ...
    def normalize(self) -> None: ...
    def reverse(self) -> 'Point': ...

class Polygon(Geometry, Polygonal):
    @typing.overload
    def __init__(self, linearRing: 'LinearRing', linearRingArray: typing.Union[typing.List['LinearRing'], jpype.JArray], geometryFactory: GeometryFactory): ...
    @typing.overload
    def __init__(self, linearRing: 'LinearRing', linearRingArray: typing.Union[typing.List['LinearRing'], jpype.JArray], precisionModel: PrecisionModel, int: int): ...
    @typing.overload
    def __init__(self, linearRing: 'LinearRing', precisionModel: PrecisionModel, int: int): ...
    @typing.overload
    def apply(self, coordinateFilter: CoordinateFilter) -> None: ...
    @typing.overload
    def apply(self, coordinateSequenceFilter: CoordinateSequenceFilter) -> None: ...
    @typing.overload
    def apply(self, geometryComponentFilter: GeometryComponentFilter) -> None: ...
    @typing.overload
    def apply(self, geometryFilter: GeometryFilter) -> None: ...
    def clone(self) -> typing.Any: ...
    def convexHull(self) -> Geometry: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry) -> bool: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry, double: float) -> bool: ...
    def getArea(self) -> float: ...
    def getBoundary(self) -> Geometry: ...
    def getBoundaryDimension(self) -> int: ...
    def getCoordinate(self) -> Coordinate: ...
    def getCoordinates(self) -> typing.MutableSequence[Coordinate]: ...
    def getDimension(self) -> int: ...
    def getExteriorRing(self) -> 'LinearRing': ...
    def getGeometryType(self) -> str: ...
    def getInteriorRingN(self, int: int) -> 'LinearRing': ...
    def getLength(self) -> float: ...
    def getNumInteriorRing(self) -> int: ...
    def getNumPoints(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def isRectangle(self) -> bool: ...
    def normalize(self) -> None: ...
    def reverse(self) -> 'Polygon': ...

class LinearRing(LineString):
    MINIMUM_VALID_SIZE: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, coordinateSequence: CoordinateSequence, geometryFactory: GeometryFactory): ...
    @typing.overload
    def __init__(self, coordinateArray: typing.Union[typing.List[Coordinate], jpype.JArray], precisionModel: PrecisionModel, int: int): ...
    def getBoundaryDimension(self) -> int: ...
    def getGeometryType(self) -> str: ...
    def isClosed(self) -> bool: ...
    def reverse(self) -> 'LinearRing': ...
    def reverseInternal(self) -> 'LinearRing': ...

class MultiLineString(GeometryCollection, Lineal):
    @typing.overload
    def __init__(self, lineStringArray: typing.Union[typing.List[LineString], jpype.JArray], geometryFactory: GeometryFactory): ...
    @typing.overload
    def __init__(self, lineStringArray: typing.Union[typing.List[LineString], jpype.JArray], precisionModel: PrecisionModel, int: int): ...
    @typing.overload
    def equalsExact(self, geometry: Geometry) -> bool: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry, double: float) -> bool: ...
    def getBoundary(self) -> Geometry: ...
    def getBoundaryDimension(self) -> int: ...
    def getDimension(self) -> int: ...
    def getGeometryType(self) -> str: ...
    def isClosed(self) -> bool: ...
    def reverse(self) -> 'MultiLineString': ...

class MultiPoint(GeometryCollection, Puntal):
    @typing.overload
    def __init__(self, pointArray: typing.Union[typing.List[Point], jpype.JArray], geometryFactory: GeometryFactory): ...
    @typing.overload
    def __init__(self, pointArray: typing.Union[typing.List[Point], jpype.JArray], precisionModel: PrecisionModel, int: int): ...
    @typing.overload
    def equalsExact(self, geometry: Geometry) -> bool: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry, double: float) -> bool: ...
    def getBoundary(self) -> Geometry: ...
    def getBoundaryDimension(self) -> int: ...
    def getDimension(self) -> int: ...
    def getGeometryType(self) -> str: ...
    def reverse(self) -> 'MultiPoint': ...

class MultiPolygon(GeometryCollection, Polygonal):
    @typing.overload
    def __init__(self, polygonArray: typing.Union[typing.List[Polygon], jpype.JArray], geometryFactory: GeometryFactory): ...
    @typing.overload
    def __init__(self, polygonArray: typing.Union[typing.List[Polygon], jpype.JArray], precisionModel: PrecisionModel, int: int): ...
    @typing.overload
    def equalsExact(self, geometry: Geometry) -> bool: ...
    @typing.overload
    def equalsExact(self, geometry: Geometry, double: float) -> bool: ...
    def getBoundary(self) -> Geometry: ...
    def getBoundaryDimension(self) -> int: ...
    def getDimension(self) -> int: ...
    def getGeometryType(self) -> str: ...
    def reverse(self) -> 'MultiPolygon': ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.geom")``.

    Coordinate: typing.Type[Coordinate]
    CoordinateArrays: typing.Type[CoordinateArrays]
    CoordinateFilter: typing.Type[CoordinateFilter]
    CoordinateList: typing.Type[CoordinateList]
    CoordinateSequence: typing.Type[CoordinateSequence]
    CoordinateSequenceComparator: typing.Type[CoordinateSequenceComparator]
    CoordinateSequenceFactory: typing.Type[CoordinateSequenceFactory]
    CoordinateSequenceFilter: typing.Type[CoordinateSequenceFilter]
    CoordinateSequences: typing.Type[CoordinateSequences]
    CoordinateXY: typing.Type[CoordinateXY]
    CoordinateXYM: typing.Type[CoordinateXYM]
    CoordinateXYZM: typing.Type[CoordinateXYZM]
    Coordinates: typing.Type[Coordinates]
    Dimension: typing.Type[Dimension]
    Envelope: typing.Type[Envelope]
    Geometry: typing.Type[Geometry]
    GeometryCollection: typing.Type[GeometryCollection]
    GeometryCollectionIterator: typing.Type[GeometryCollectionIterator]
    GeometryComponentFilter: typing.Type[GeometryComponentFilter]
    GeometryFactory: typing.Type[GeometryFactory]
    GeometryFilter: typing.Type[GeometryFilter]
    IntersectionMatrix: typing.Type[IntersectionMatrix]
    LineSegment: typing.Type[LineSegment]
    LineString: typing.Type[LineString]
    Lineal: typing.Type[Lineal]
    LinearRing: typing.Type[LinearRing]
    Location: typing.Type[Location]
    MultiLineString: typing.Type[MultiLineString]
    MultiPoint: typing.Type[MultiPoint]
    MultiPolygon: typing.Type[MultiPolygon]
    OctagonalEnvelope: typing.Type[OctagonalEnvelope]
    Point: typing.Type[Point]
    Polygon: typing.Type[Polygon]
    Polygonal: typing.Type[Polygonal]
    Position: typing.Type[Position]
    PrecisionModel: typing.Type[PrecisionModel]
    Puntal: typing.Type[Puntal]
    Quadrant: typing.Type[Quadrant]
    TopologyException: typing.Type[TopologyException]
    Triangle: typing.Type[Triangle]
    impl: org.locationtech.jts.geom.impl.__module_protocol__
    prep: org.locationtech.jts.geom.prep.__module_protocol__
    util: org.locationtech.jts.geom.util.__module_protocol__
