
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jpype
import org.locationtech.jts.algorithm
import org.locationtech.jts.geom
import org.locationtech.jts.geomgraph.index
import typing



class Depth:
    def __init__(self): ...
    @typing.overload
    def add(self, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def add(self, label: 'Label') -> None: ...
    @staticmethod
    def depthAtLocation(int: int) -> int: ...
    def getDelta(self, int: int) -> int: ...
    def getDepth(self, int: int, int2: int) -> int: ...
    def getLocation(self, int: int, int2: int) -> int: ...
    @typing.overload
    def isNull(self) -> bool: ...
    @typing.overload
    def isNull(self, int: int) -> bool: ...
    @typing.overload
    def isNull(self, int: int, int2: int) -> bool: ...
    def normalize(self) -> None: ...
    def setDepth(self, int: int, int2: int, int3: int) -> None: ...
    def toString(self) -> str: ...

class EdgeEnd(java.lang.Comparable):
    @typing.overload
    def __init__(self, edge: 'Edge', coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate): ...
    @typing.overload
    def __init__(self, edge: 'Edge', coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, label: 'Label'): ...
    def compareDirection(self, edgeEnd: 'EdgeEnd') -> int: ...
    def compareTo(self, object: typing.Any) -> int: ...
    def computeLabel(self, boundaryNodeRule: org.locationtech.jts.algorithm.BoundaryNodeRule) -> None: ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getDirectedCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getDx(self) -> float: ...
    def getDy(self) -> float: ...
    def getEdge(self) -> 'Edge': ...
    def getLabel(self) -> 'Label': ...
    def getNode(self) -> 'Node': ...
    def getQuadrant(self) -> int: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...
    def setNode(self, node: 'Node') -> None: ...
    def toString(self) -> str: ...

class EdgeEndStar:
    def __init__(self): ...
    def computeLabelling(self, geometryGraphArray: typing.Union[typing.List['GeometryGraph'], jpype.JArray]) -> None: ...
    def findIndex(self, edgeEnd: EdgeEnd) -> int: ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getDegree(self) -> int: ...
    def getEdges(self) -> java.util.List: ...
    def getNextCW(self, edgeEnd: EdgeEnd) -> EdgeEnd: ...
    def insert(self, edgeEnd: EdgeEnd) -> None: ...
    def isAreaLabelsConsistent(self, geometryGraph: 'GeometryGraph') -> bool: ...
    def iterator(self) -> java.util.Iterator: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...
    def toString(self) -> str: ...

class EdgeIntersection(java.lang.Comparable):
    coord: org.locationtech.jts.geom.Coordinate = ...
    segmentIndex: int = ...
    dist: float = ...
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, int: int, double: float): ...
    def compare(self, int: int, double: float) -> int: ...
    def compareTo(self, object: typing.Any) -> int: ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getDistance(self) -> float: ...
    def getSegmentIndex(self) -> int: ...
    def isEndPoint(self, int: int) -> bool: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...
    def toString(self) -> str: ...

class EdgeIntersectionList:
    def __init__(self, edge: 'Edge'): ...
    def add(self, coordinate: org.locationtech.jts.geom.Coordinate, int: int, double: float) -> EdgeIntersection: ...
    def addEndpoints(self) -> None: ...
    def addSplitEdges(self, list: java.util.List) -> None: ...
    def isIntersection(self, coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    def iterator(self) -> java.util.Iterator: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...

class EdgeList:
    def __init__(self): ...
    def add(self, edge: 'Edge') -> None: ...
    def addAll(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def findEdgeIndex(self, edge: 'Edge') -> int: ...
    def findEqualEdge(self, edge: 'Edge') -> 'Edge': ...
    def get(self, int: int) -> 'Edge': ...
    def getEdges(self) -> java.util.List: ...
    def iterator(self) -> java.util.Iterator: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...

class EdgeNodingValidator:
    def __init__(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]): ...
    @typing.overload
    @staticmethod
    def checkValid(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    @typing.overload
    def checkValid(self) -> None: ...
    @staticmethod
    def toSegmentStrings(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> java.util.Collection: ...

class EdgeRing:
    def __init__(self, directedEdge: 'DirectedEdge', geometryFactory: org.locationtech.jts.geom.GeometryFactory): ...
    def addHole(self, edgeRing: 'EdgeRing') -> None: ...
    def computeRing(self) -> None: ...
    def containsPoint(self, coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    def getCoordinate(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getEdges(self) -> java.util.List: ...
    def getLabel(self) -> 'Label': ...
    def getLinearRing(self) -> org.locationtech.jts.geom.LinearRing: ...
    def getMaxNodeDegree(self) -> int: ...
    def getNext(self, directedEdge: 'DirectedEdge') -> 'DirectedEdge': ...
    def getShell(self) -> 'EdgeRing': ...
    def isHole(self) -> bool: ...
    def isIsolated(self) -> bool: ...
    def isShell(self) -> bool: ...
    def setEdgeRing(self, directedEdge: 'DirectedEdge', edgeRing: 'EdgeRing') -> None: ...
    def setInResult(self) -> None: ...
    def setShell(self, edgeRing: 'EdgeRing') -> None: ...
    def toPolygon(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Polygon: ...

class GraphComponent:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, label: 'Label'): ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getLabel(self) -> 'Label': ...
    def isCovered(self) -> bool: ...
    def isCoveredSet(self) -> bool: ...
    def isInResult(self) -> bool: ...
    def isIsolated(self) -> bool: ...
    def isVisited(self) -> bool: ...
    def setCovered(self, boolean: bool) -> None: ...
    def setInResult(self, boolean: bool) -> None: ...
    def setLabel(self, label: 'Label') -> None: ...
    def setVisited(self, boolean: bool) -> None: ...
    def updateIM(self, intersectionMatrix: org.locationtech.jts.geom.IntersectionMatrix) -> None: ...

class Label:
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int): ...
    @typing.overload
    def __init__(self, label: 'Label'): ...
    def allPositionsEqual(self, int: int, int2: int) -> bool: ...
    def flip(self) -> None: ...
    def getGeometryCount(self) -> int: ...
    @typing.overload
    def getLocation(self, int: int) -> int: ...
    @typing.overload
    def getLocation(self, int: int, int2: int) -> int: ...
    def isAnyNull(self, int: int) -> bool: ...
    @typing.overload
    def isArea(self) -> bool: ...
    @typing.overload
    def isArea(self, int: int) -> bool: ...
    def isEqualOnSide(self, label: 'Label', int: int) -> bool: ...
    def isLine(self, int: int) -> bool: ...
    def isNull(self, int: int) -> bool: ...
    def merge(self, label: 'Label') -> None: ...
    def setAllLocations(self, int: int, int2: int) -> None: ...
    @typing.overload
    def setAllLocationsIfNull(self, int: int) -> None: ...
    @typing.overload
    def setAllLocationsIfNull(self, int: int, int2: int) -> None: ...
    @typing.overload
    def setLocation(self, int: int, int2: int) -> None: ...
    @typing.overload
    def setLocation(self, int: int, int2: int, int3: int) -> None: ...
    def toLine(self, int: int) -> None: ...
    @staticmethod
    def toLineLabel(label: 'Label') -> 'Label': ...
    def toString(self) -> str: ...

class NodeFactory:
    def __init__(self): ...
    def createNode(self, coordinate: org.locationtech.jts.geom.Coordinate) -> 'Node': ...

class NodeMap:
    def __init__(self, nodeFactory: NodeFactory): ...
    def add(self, edgeEnd: EdgeEnd) -> None: ...
    @typing.overload
    def addNode(self, coordinate: org.locationtech.jts.geom.Coordinate) -> 'Node': ...
    @typing.overload
    def addNode(self, node: 'Node') -> 'Node': ...
    def find(self, coordinate: org.locationtech.jts.geom.Coordinate) -> 'Node': ...
    def getBoundaryNodes(self, int: int) -> java.util.Collection: ...
    def iterator(self) -> java.util.Iterator: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...
    def values(self) -> java.util.Collection: ...

class PlanarGraph:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, nodeFactory: NodeFactory): ...
    def add(self, edgeEnd: EdgeEnd) -> None: ...
    def addEdges(self, list: java.util.List) -> None: ...
    @typing.overload
    def addNode(self, coordinate: org.locationtech.jts.geom.Coordinate) -> 'Node': ...
    @typing.overload
    def addNode(self, node: 'Node') -> 'Node': ...
    def find(self, coordinate: org.locationtech.jts.geom.Coordinate) -> 'Node': ...
    def findEdge(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> 'Edge': ...
    def findEdgeEnd(self, edge: 'Edge') -> EdgeEnd: ...
    def findEdgeInSameDirection(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> 'Edge': ...
    def getEdgeEnds(self) -> java.util.Collection: ...
    def getEdgeIterator(self) -> java.util.Iterator: ...
    def getNodeIterator(self) -> java.util.Iterator: ...
    def getNodes(self) -> java.util.Collection: ...
    def isBoundaryNode(self, int: int, coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    def linkAllDirectedEdges(self) -> None: ...
    @typing.overload
    @staticmethod
    def linkResultDirectedEdges(collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    @typing.overload
    def linkResultDirectedEdges(self) -> None: ...
    def printEdges(self, printStream: java.io.PrintStream) -> None: ...

class TopologyLocation:
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, intArray: typing.Union[typing.List[int], jpype.JArray]): ...
    @typing.overload
    def __init__(self, topologyLocation: 'TopologyLocation'): ...
    def allPositionsEqual(self, int: int) -> bool: ...
    def flip(self) -> None: ...
    def get(self, int: int) -> int: ...
    def getLocations(self) -> typing.MutableSequence[int]: ...
    def isAnyNull(self) -> bool: ...
    def isArea(self) -> bool: ...
    def isEqualOnSide(self, topologyLocation: 'TopologyLocation', int: int) -> bool: ...
    def isLine(self) -> bool: ...
    def isNull(self) -> bool: ...
    def merge(self, topologyLocation: 'TopologyLocation') -> None: ...
    def setAllLocations(self, int: int) -> None: ...
    def setAllLocationsIfNull(self, int: int) -> None: ...
    @typing.overload
    def setLocation(self, int: int) -> None: ...
    @typing.overload
    def setLocation(self, int: int, int2: int) -> None: ...
    def setLocations(self, int: int, int2: int, int3: int) -> None: ...
    def toString(self) -> str: ...

class DirectedEdge(EdgeEnd):
    def __init__(self, edge: 'Edge', boolean: bool): ...
    @staticmethod
    def depthFactor(int: int, int2: int) -> int: ...
    def getDepth(self, int: int) -> int: ...
    def getDepthDelta(self) -> int: ...
    def getEdge(self) -> 'Edge': ...
    def getEdgeRing(self) -> EdgeRing: ...
    def getMinEdgeRing(self) -> EdgeRing: ...
    def getNext(self) -> 'DirectedEdge': ...
    def getNextMin(self) -> 'DirectedEdge': ...
    def getSym(self) -> 'DirectedEdge': ...
    def isForward(self) -> bool: ...
    def isInResult(self) -> bool: ...
    def isInteriorAreaEdge(self) -> bool: ...
    def isLineEdge(self) -> bool: ...
    def isVisited(self) -> bool: ...
    def printEdge(self, printStream: java.io.PrintStream) -> None: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...
    def setDepth(self, int: int, int2: int) -> None: ...
    def setEdgeDepths(self, int: int, int2: int) -> None: ...
    def setEdgeRing(self, edgeRing: EdgeRing) -> None: ...
    def setInResult(self, boolean: bool) -> None: ...
    def setMinEdgeRing(self, edgeRing: EdgeRing) -> None: ...
    def setNext(self, directedEdge: 'DirectedEdge') -> None: ...
    def setNextMin(self, directedEdge: 'DirectedEdge') -> None: ...
    def setSym(self, directedEdge: 'DirectedEdge') -> None: ...
    def setVisited(self, boolean: bool) -> None: ...
    def setVisitedEdge(self, boolean: bool) -> None: ...

class DirectedEdgeStar(EdgeEndStar):
    def __init__(self): ...
    def computeDepths(self, directedEdge: DirectedEdge) -> None: ...
    def computeLabelling(self, geometryGraphArray: typing.Union[typing.List['GeometryGraph'], jpype.JArray]) -> None: ...
    def findCoveredLineEdges(self) -> None: ...
    def getLabel(self) -> Label: ...
    @typing.overload
    def getOutgoingDegree(self) -> int: ...
    @typing.overload
    def getOutgoingDegree(self, edgeRing: EdgeRing) -> int: ...
    def getRightmostEdge(self) -> DirectedEdge: ...
    def insert(self, edgeEnd: EdgeEnd) -> None: ...
    def linkAllDirectedEdges(self) -> None: ...
    def linkMinimalDirectedEdges(self, edgeRing: EdgeRing) -> None: ...
    def linkResultDirectedEdges(self) -> None: ...
    def mergeSymLabels(self) -> None: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...
    def updateLabelling(self, label: Label) -> None: ...

class Edge(GraphComponent):
    @typing.overload
    def __init__(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]): ...
    @typing.overload
    def __init__(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray], label: Label): ...
    def addIntersection(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector, int: int, int2: int, int3: int) -> None: ...
    def addIntersections(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector, int: int, int2: int) -> None: ...
    def computeIM(self, intersectionMatrix: org.locationtech.jts.geom.IntersectionMatrix) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCollapsedEdge(self) -> 'Edge': ...
    @typing.overload
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    def getCoordinate(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getCoordinates(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def getDepth(self) -> Depth: ...
    def getDepthDelta(self) -> int: ...
    def getEdgeIntersectionList(self) -> EdgeIntersectionList: ...
    def getEnvelope(self) -> org.locationtech.jts.geom.Envelope: ...
    def getMaximumSegmentIndex(self) -> int: ...
    def getMonotoneChainEdge(self) -> org.locationtech.jts.geomgraph.index.MonotoneChainEdge: ...
    def getNumPoints(self) -> int: ...
    def hashCode(self) -> int: ...
    def isClosed(self) -> bool: ...
    def isCollapsed(self) -> bool: ...
    def isIsolated(self) -> bool: ...
    def isPointwiseEqual(self, edge: 'Edge') -> bool: ...
    def printReverse(self, printStream: java.io.PrintStream) -> None: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...
    def setDepthDelta(self, int: int) -> None: ...
    def setIsolated(self, boolean: bool) -> None: ...
    def setName(self, string: str) -> None: ...
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def updateIM(label: Label, intersectionMatrix: org.locationtech.jts.geom.IntersectionMatrix) -> None: ...
    @typing.overload
    def updateIM(self, intersectionMatrix: org.locationtech.jts.geom.IntersectionMatrix) -> None: ...

class GeometryGraph(PlanarGraph):
    @typing.overload
    def __init__(self, int: int, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def __init__(self, int: int, geometry: org.locationtech.jts.geom.Geometry, boundaryNodeRule: org.locationtech.jts.algorithm.BoundaryNodeRule): ...
    def addEdge(self, edge: Edge) -> None: ...
    def addPoint(self, coordinate: org.locationtech.jts.geom.Coordinate) -> None: ...
    def computeEdgeIntersections(self, geometryGraph: 'GeometryGraph', lineIntersector: org.locationtech.jts.algorithm.LineIntersector, boolean: bool) -> org.locationtech.jts.geomgraph.index.SegmentIntersector: ...
    def computeSelfNodes(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector, boolean: bool) -> org.locationtech.jts.geomgraph.index.SegmentIntersector: ...
    def computeSplitEdges(self, list: java.util.List) -> None: ...
    @staticmethod
    def determineBoundary(boundaryNodeRule: org.locationtech.jts.algorithm.BoundaryNodeRule, int: int) -> int: ...
    @typing.overload
    def findEdge(self, lineString: org.locationtech.jts.geom.LineString) -> Edge: ...
    @typing.overload
    def findEdge(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> Edge: ...
    def getBoundaryNodeRule(self) -> org.locationtech.jts.algorithm.BoundaryNodeRule: ...
    def getBoundaryNodes(self) -> java.util.Collection: ...
    def getBoundaryPoints(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def getGeometry(self) -> org.locationtech.jts.geom.Geometry: ...
    def getInvalidPoint(self) -> org.locationtech.jts.geom.Coordinate: ...
    def hasTooFewPoints(self) -> bool: ...
    def locate(self, coordinate: org.locationtech.jts.geom.Coordinate) -> int: ...

class Node(GraphComponent):
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, edgeEndStar: EdgeEndStar): ...
    def add(self, edgeEnd: EdgeEnd) -> None: ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getEdges(self) -> EdgeEndStar: ...
    def isIncidentEdgeInResult(self) -> bool: ...
    def isIsolated(self) -> bool: ...
    @typing.overload
    def mergeLabel(self, label: Label) -> None: ...
    @typing.overload
    def mergeLabel(self, node: 'Node') -> None: ...
    def print_(self, printStream: java.io.PrintStream) -> None: ...
    @typing.overload
    def setLabel(self, label: Label) -> None: ...
    @typing.overload
    def setLabel(self, int: int, int2: int) -> None: ...
    def setLabelBoundary(self, int: int) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.geomgraph")``.

    Depth: typing.Type[Depth]
    DirectedEdge: typing.Type[DirectedEdge]
    DirectedEdgeStar: typing.Type[DirectedEdgeStar]
    Edge: typing.Type[Edge]
    EdgeEnd: typing.Type[EdgeEnd]
    EdgeEndStar: typing.Type[EdgeEndStar]
    EdgeIntersection: typing.Type[EdgeIntersection]
    EdgeIntersectionList: typing.Type[EdgeIntersectionList]
    EdgeList: typing.Type[EdgeList]
    EdgeNodingValidator: typing.Type[EdgeNodingValidator]
    EdgeRing: typing.Type[EdgeRing]
    GeometryGraph: typing.Type[GeometryGraph]
    GraphComponent: typing.Type[GraphComponent]
    Label: typing.Type[Label]
    Node: typing.Type[Node]
    NodeFactory: typing.Type[NodeFactory]
    NodeMap: typing.Type[NodeMap]
    PlanarGraph: typing.Type[PlanarGraph]
    TopologyLocation: typing.Type[TopologyLocation]
    index: org.locationtech.jts.geomgraph.index.__module_protocol__
