
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jpype
import org.locationtech.jts.algorithm
import org.locationtech.jts.geom
import org.locationtech.jts.geomgraph
import typing



class EdgeSetIntersector:
    def __init__(self): ...
    @typing.overload
    def computeIntersections(self, list: java.util.List, list2: java.util.List, segmentIntersector: 'SegmentIntersector') -> None: ...
    @typing.overload
    def computeIntersections(self, list: java.util.List, segmentIntersector: 'SegmentIntersector', boolean: bool) -> None: ...

class MonotoneChain:
    def __init__(self, monotoneChainEdge: 'MonotoneChainEdge', int: int): ...
    def computeIntersections(self, monotoneChain: 'MonotoneChain', segmentIntersector: 'SegmentIntersector') -> None: ...

class MonotoneChainEdge:
    def __init__(self, edge: org.locationtech.jts.geomgraph.Edge): ...
    def computeIntersects(self, monotoneChainEdge: 'MonotoneChainEdge', segmentIntersector: 'SegmentIntersector') -> None: ...
    def computeIntersectsForChain(self, int: int, monotoneChainEdge: 'MonotoneChainEdge', int2: int, segmentIntersector: 'SegmentIntersector') -> None: ...
    def getCoordinates(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    def getMaxX(self, int: int) -> float: ...
    def getMinX(self, int: int) -> float: ...
    def getStartIndexes(self) -> typing.MutableSequence[int]: ...

class MonotoneChainIndexer:
    def __init__(self): ...
    def OLDgetChainStartIndices(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> typing.MutableSequence[int]: ...
    def getChainStartIndices(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> typing.MutableSequence[int]: ...
    @staticmethod
    def toIntArray(list: java.util.List) -> typing.MutableSequence[int]: ...

class SegmentIntersector:
    numTests: int = ...
    def __init__(self, lineIntersector: org.locationtech.jts.algorithm.LineIntersector, boolean: bool, boolean2: bool): ...
    def addIntersections(self, edge: org.locationtech.jts.geomgraph.Edge, int: int, edge2: org.locationtech.jts.geomgraph.Edge, int2: int) -> None: ...
    def getProperIntersectionPoint(self) -> org.locationtech.jts.geom.Coordinate: ...
    def hasIntersection(self) -> bool: ...
    def hasProperInteriorIntersection(self) -> bool: ...
    def hasProperIntersection(self) -> bool: ...
    @staticmethod
    def isAdjacentSegments(int: int, int2: int) -> bool: ...
    def isDone(self) -> bool: ...
    def setBoundaryNodes(self, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set], collection2: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...

class SweepLineEvent(java.lang.Comparable):
    @typing.overload
    def __init__(self, double: float, sweepLineEvent: 'SweepLineEvent'): ...
    @typing.overload
    def __init__(self, object: typing.Any, double: float, object2: typing.Any): ...
    def compareTo(self, object: typing.Any) -> int: ...
    def getDeleteEventIndex(self) -> int: ...
    def getInsertEvent(self) -> 'SweepLineEvent': ...
    def getObject(self) -> typing.Any: ...
    def isDelete(self) -> bool: ...
    def isInsert(self) -> bool: ...
    def isSameLabel(self, sweepLineEvent: 'SweepLineEvent') -> bool: ...
    def setDeleteEventIndex(self, int: int) -> None: ...

class SweepLineSegment:
    def __init__(self, edge: org.locationtech.jts.geomgraph.Edge, int: int): ...
    def computeIntersections(self, sweepLineSegment: 'SweepLineSegment', segmentIntersector: SegmentIntersector) -> None: ...
    def getMaxX(self) -> float: ...
    def getMinX(self) -> float: ...

class SimpleEdgeSetIntersector(EdgeSetIntersector):
    def __init__(self): ...
    @typing.overload
    def computeIntersections(self, list: java.util.List, list2: java.util.List, segmentIntersector: SegmentIntersector) -> None: ...
    @typing.overload
    def computeIntersections(self, list: java.util.List, segmentIntersector: SegmentIntersector, boolean: bool) -> None: ...

class SimpleMCSweepLineIntersector(EdgeSetIntersector):
    def __init__(self): ...
    @typing.overload
    def computeIntersections(self, list: java.util.List, list2: java.util.List, segmentIntersector: SegmentIntersector) -> None: ...
    @typing.overload
    def computeIntersections(self, list: java.util.List, segmentIntersector: SegmentIntersector, boolean: bool) -> None: ...

class SimpleSweepLineIntersector(EdgeSetIntersector):
    def __init__(self): ...
    @typing.overload
    def computeIntersections(self, list: java.util.List, list2: java.util.List, segmentIntersector: SegmentIntersector) -> None: ...
    @typing.overload
    def computeIntersections(self, list: java.util.List, segmentIntersector: SegmentIntersector, boolean: bool) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.geomgraph.index")``.

    EdgeSetIntersector: typing.Type[EdgeSetIntersector]
    MonotoneChain: typing.Type[MonotoneChain]
    MonotoneChainEdge: typing.Type[MonotoneChainEdge]
    MonotoneChainIndexer: typing.Type[MonotoneChainIndexer]
    SegmentIntersector: typing.Type[SegmentIntersector]
    SimpleEdgeSetIntersector: typing.Type[SimpleEdgeSetIntersector]
    SimpleMCSweepLineIntersector: typing.Type[SimpleMCSweepLineIntersector]
    SimpleSweepLineIntersector: typing.Type[SimpleSweepLineIntersector]
    SweepLineEvent: typing.Type[SweepLineEvent]
    SweepLineSegment: typing.Type[SweepLineSegment]
