
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import jpype
import org.locationtech.jts.geom
import typing



class DD(java.io.Serializable, java.lang.Comparable, java.lang.Cloneable):
    PI: typing.ClassVar['DD'] = ...
    TWO_PI: typing.ClassVar['DD'] = ...
    PI_2: typing.ClassVar['DD'] = ...
    E: typing.ClassVar['DD'] = ...
    NaN: typing.ClassVar['DD'] = ...
    EPS: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, dD: 'DD'): ...
    def abs(self) -> 'DD': ...
    @typing.overload
    def add(self, double: float) -> 'DD': ...
    @typing.overload
    def add(self, dD: 'DD') -> 'DD': ...
    def ceil(self) -> 'DD': ...
    def clone(self) -> typing.Any: ...
    def compareTo(self, object: typing.Any) -> int: ...
    @staticmethod
    def copy(dD: 'DD') -> 'DD': ...
    @typing.overload
    @staticmethod
    def determinant(double: float, double2: float, double3: float, double4: float) -> 'DD': ...
    @typing.overload
    @staticmethod
    def determinant(dD: 'DD', dD2: 'DD', dD3: 'DD', dD4: 'DD') -> 'DD': ...
    @typing.overload
    def divide(self, double: float) -> 'DD': ...
    @typing.overload
    def divide(self, dD: 'DD') -> 'DD': ...
    def doubleValue(self) -> float: ...
    def dump(self) -> str: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, dD: 'DD') -> bool: ...
    def floor(self) -> 'DD': ...
    def ge(self, dD: 'DD') -> bool: ...
    def gt(self, dD: 'DD') -> bool: ...
    def intValue(self) -> int: ...
    def isNaN(self) -> bool: ...
    def isNegative(self) -> bool: ...
    def isPositive(self) -> bool: ...
    def isZero(self) -> bool: ...
    def le(self, dD: 'DD') -> bool: ...
    def lt(self, dD: 'DD') -> bool: ...
    def max(self, dD: 'DD') -> 'DD': ...
    def min(self, dD: 'DD') -> 'DD': ...
    @typing.overload
    def multiply(self, double: float) -> 'DD': ...
    @typing.overload
    def multiply(self, dD: 'DD') -> 'DD': ...
    def negate(self) -> 'DD': ...
    @staticmethod
    def parse(string: str) -> 'DD': ...
    def pow(self, int: int) -> 'DD': ...
    def reciprocal(self) -> 'DD': ...
    def rint(self) -> 'DD': ...
    @typing.overload
    def selfAdd(self, double: float) -> 'DD': ...
    @typing.overload
    def selfAdd(self, dD: 'DD') -> 'DD': ...
    @typing.overload
    def selfDivide(self, double: float) -> 'DD': ...
    @typing.overload
    def selfDivide(self, dD: 'DD') -> 'DD': ...
    @typing.overload
    def selfMultiply(self, double: float) -> 'DD': ...
    @typing.overload
    def selfMultiply(self, dD: 'DD') -> 'DD': ...
    def selfSqr(self) -> 'DD': ...
    @typing.overload
    def selfSubtract(self, double: float) -> 'DD': ...
    @typing.overload
    def selfSubtract(self, dD: 'DD') -> 'DD': ...
    @typing.overload
    def setValue(self, double: float) -> 'DD': ...
    @typing.overload
    def setValue(self, dD: 'DD') -> 'DD': ...
    def signum(self) -> int: ...
    @typing.overload
    @staticmethod
    def sqr(double: float) -> 'DD': ...
    @typing.overload
    def sqr(self) -> 'DD': ...
    @typing.overload
    @staticmethod
    def sqrt(double: float) -> 'DD': ...
    @typing.overload
    def sqrt(self) -> 'DD': ...
    @typing.overload
    def subtract(self, double: float) -> 'DD': ...
    @typing.overload
    def subtract(self, dD: 'DD') -> 'DD': ...
    def toSciNotation(self) -> str: ...
    def toStandardNotation(self) -> str: ...
    def toString(self) -> str: ...
    def trunc(self) -> 'DD': ...
    @typing.overload
    @staticmethod
    def valueOf(double: float) -> 'DD': ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'DD': ...

class MathUtil:
    PHI_INV: typing.ClassVar[float] = ...
    def __init__(self): ...
    @staticmethod
    def average(double: float, double2: float) -> float: ...
    @staticmethod
    def ceil(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def clamp(double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    @staticmethod
    def clamp(int: int, int2: int, int3: int) -> int: ...
    @staticmethod
    def clampMax(int: int, int2: int) -> int: ...
    @staticmethod
    def log10(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def max(double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    @staticmethod
    def max(double: float, double2: float, double3: float, double4: float) -> float: ...
    @staticmethod
    def min(double: float, double2: float, double3: float, double4: float) -> float: ...
    @typing.overload
    @staticmethod
    def quasirandom(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def quasirandom(double: float, double2: float) -> float: ...
    @staticmethod
    def wrap(int: int, int2: int) -> int: ...

class Matrix:
    def __init__(self): ...
    @staticmethod
    def solve(doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...

class Plane3D:
    XY_PLANE: typing.ClassVar[int] = ...
    YZ_PLANE: typing.ClassVar[int] = ...
    XZ_PLANE: typing.ClassVar[int] = ...
    def __init__(self, vector3D: 'Vector3D', coordinate: org.locationtech.jts.geom.Coordinate): ...
    def closestAxisPlane(self) -> int: ...
    def orientedDistance(self, coordinate: org.locationtech.jts.geom.Coordinate) -> float: ...

class Vector2D:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate): ...
    @typing.overload
    def __init__(self, vector2D: 'Vector2D'): ...
    def add(self, vector2D: 'Vector2D') -> 'Vector2D': ...
    @typing.overload
    def angle(self) -> float: ...
    @typing.overload
    def angle(self, vector2D: 'Vector2D') -> float: ...
    def angleTo(self, vector2D: 'Vector2D') -> float: ...
    def average(self, vector2D: 'Vector2D') -> 'Vector2D': ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def create(double: float, double2: float) -> 'Vector2D': ...
    @typing.overload
    @staticmethod
    def create(coordinate: org.locationtech.jts.geom.Coordinate) -> 'Vector2D': ...
    @typing.overload
    @staticmethod
    def create(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> 'Vector2D': ...
    @typing.overload
    @staticmethod
    def create(vector2D: 'Vector2D') -> 'Vector2D': ...
    def distance(self, vector2D: 'Vector2D') -> float: ...
    def divide(self, double: float) -> 'Vector2D': ...
    def dot(self, vector2D: 'Vector2D') -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getComponent(self, int: int) -> float: ...
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def hashCode(self) -> int: ...
    def isParallel(self, vector2D: 'Vector2D') -> bool: ...
    def length(self) -> float: ...
    def lengthSquared(self) -> float: ...
    def multiply(self, double: float) -> 'Vector2D': ...
    def negate(self) -> 'Vector2D': ...
    def normalize(self) -> 'Vector2D': ...
    def rotate(self, double: float) -> 'Vector2D': ...
    def rotateByQuarterCircle(self, int: int) -> 'Vector2D': ...
    def subtract(self, vector2D: 'Vector2D') -> 'Vector2D': ...
    def toCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def toString(self) -> str: ...
    def translate(self, coordinate: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...
    def weightedSum(self, vector2D: 'Vector2D', double: float) -> 'Vector2D': ...

class Vector3D:
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate): ...
    @typing.overload
    def __init__(self, coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate): ...
    def add(self, vector3D: 'Vector3D') -> 'Vector3D': ...
    @typing.overload
    @staticmethod
    def create(double: float, double2: float, double3: float) -> 'Vector3D': ...
    @typing.overload
    @staticmethod
    def create(coordinate: org.locationtech.jts.geom.Coordinate) -> 'Vector3D': ...
    def divide(self, double: float) -> 'Vector3D': ...
    @typing.overload
    def dot(self, vector3D: 'Vector3D') -> float: ...
    @typing.overload
    @staticmethod
    def dot(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> float: ...
    @typing.overload
    @staticmethod
    def dot(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate, coordinate3: org.locationtech.jts.geom.Coordinate, coordinate4: org.locationtech.jts.geom.Coordinate) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def getZ(self) -> float: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def length(self) -> float: ...
    @typing.overload
    @staticmethod
    def length(coordinate: org.locationtech.jts.geom.Coordinate) -> float: ...
    @typing.overload
    def normalize(self) -> 'Vector3D': ...
    @typing.overload
    @staticmethod
    def normalize(coordinate: org.locationtech.jts.geom.Coordinate) -> org.locationtech.jts.geom.Coordinate: ...
    def subtract(self, vector3D: 'Vector3D') -> 'Vector3D': ...
    def toString(self) -> str: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.math")``.

    DD: typing.Type[DD]
    MathUtil: typing.Type[MathUtil]
    Matrix: typing.Type[Matrix]
    Plane3D: typing.Type[Plane3D]
    Vector2D: typing.Type[Vector2D]
    Vector3D: typing.Type[Vector3D]
