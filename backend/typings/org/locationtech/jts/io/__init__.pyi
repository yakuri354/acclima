
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jpype
import jpype.protocol
import org.locationtech.jts.geom
import org.locationtech.jts.io.gml2
import org.locationtech.jts.io.kml
import typing



class ByteOrderDataInStream:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, inStream: 'InStream'): ...
    def getCount(self) -> int: ...
    def getData(self) -> typing.MutableSequence[int]: ...
    def readByte(self) -> int: ...
    def readDouble(self) -> float: ...
    def readInt(self) -> int: ...
    def readLong(self) -> int: ...
    def setInStream(self, inStream: 'InStream') -> None: ...
    def setOrder(self, int: int) -> None: ...

class ByteOrderValues:
    BIG_ENDIAN: typing.ClassVar[int] = ...
    LITTLE_ENDIAN: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def getDouble(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int) -> float: ...
    @staticmethod
    def getInt(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int) -> int: ...
    @staticmethod
    def getLong(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int) -> int: ...
    @staticmethod
    def putDouble(double: float, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int) -> None: ...
    @staticmethod
    def putInt(int: int, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int2: int) -> None: ...
    @staticmethod
    def putLong(long: int, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int) -> None: ...

class InStream:
    def read(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> int: ...

class Ordinate(java.lang.Enum['Ordinate']):
    X: typing.ClassVar['Ordinate'] = ...
    Y: typing.ClassVar['Ordinate'] = ...
    Z: typing.ClassVar['Ordinate'] = ...
    M: typing.ClassVar['Ordinate'] = ...
    @staticmethod
    def createXY() -> java.util.EnumSet['Ordinate']: ...
    @staticmethod
    def createXYM() -> java.util.EnumSet['Ordinate']: ...
    @staticmethod
    def createXYZ() -> java.util.EnumSet['Ordinate']: ...
    @staticmethod
    def createXYZM() -> java.util.EnumSet['Ordinate']: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Ordinate': ...
    @staticmethod
    def values() -> typing.MutableSequence['Ordinate']: ...

class OrdinateFormat:
    REP_POS_INF: typing.ClassVar[str] = ...
    REP_NEG_INF: typing.ClassVar[str] = ...
    REP_NAN: typing.ClassVar[str] = ...
    MAX_FRACTION_DIGITS: typing.ClassVar[int] = ...
    DEFAULT: typing.ClassVar['OrdinateFormat'] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @staticmethod
    def create(int: int) -> 'OrdinateFormat': ...
    def format(self, double: float) -> str: ...

class OutStream:
    def write(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int) -> None: ...

class ParseException(java.lang.Exception):
    @typing.overload
    def __init__(self, exception: java.lang.Exception): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...

class WKBConstants:
    wkbXDR: typing.ClassVar[int] = ...
    wkbNDR: typing.ClassVar[int] = ...
    wkbPoint: typing.ClassVar[int] = ...
    wkbLineString: typing.ClassVar[int] = ...
    wkbPolygon: typing.ClassVar[int] = ...
    wkbMultiPoint: typing.ClassVar[int] = ...
    wkbMultiLineString: typing.ClassVar[int] = ...
    wkbMultiPolygon: typing.ClassVar[int] = ...
    wkbGeometryCollection: typing.ClassVar[int] = ...

class WKBHexFileReader:
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath], wKBReader: 'WKBReader'): ...
    @typing.overload
    def __init__(self, reader: java.io.Reader, wKBReader: 'WKBReader'): ...
    @typing.overload
    def __init__(self, string: str, wKBReader: 'WKBReader'): ...
    def read(self) -> java.util.List: ...
    def setLimit(self, int: int) -> None: ...
    def setOffset(self, int: int) -> None: ...

class WKBReader:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory): ...
    @staticmethod
    def hexToBytes(string: str) -> typing.MutableSequence[int]: ...
    @typing.overload
    def read(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    def read(self, inStream: InStream) -> org.locationtech.jts.geom.Geometry: ...

class WKBWriter:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, boolean: bool): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, boolean: bool): ...
    @staticmethod
    def bytesToHex(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> str: ...
    @staticmethod
    def toHex(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> str: ...
    @typing.overload
    def write(self, geometry: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence[int]: ...
    @typing.overload
    def write(self, geometry: org.locationtech.jts.geom.Geometry, outStream: OutStream) -> None: ...

class WKTConstants:
    GEOMETRYCOLLECTION: typing.ClassVar[str] = ...
    LINEARRING: typing.ClassVar[str] = ...
    LINESTRING: typing.ClassVar[str] = ...
    MULTIPOLYGON: typing.ClassVar[str] = ...
    MULTILINESTRING: typing.ClassVar[str] = ...
    MULTIPOINT: typing.ClassVar[str] = ...
    POINT: typing.ClassVar[str] = ...
    POLYGON: typing.ClassVar[str] = ...
    EMPTY: typing.ClassVar[str] = ...
    M: typing.ClassVar[str] = ...
    Z: typing.ClassVar[str] = ...
    ZM: typing.ClassVar[str] = ...
    def __init__(self): ...

class WKTFileReader:
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath], wKTReader: 'WKTReader'): ...
    @typing.overload
    def __init__(self, reader: java.io.Reader, wKTReader: 'WKTReader'): ...
    @typing.overload
    def __init__(self, string: str, wKTReader: 'WKTReader'): ...
    def read(self) -> java.util.List: ...
    def setLimit(self, int: int) -> None: ...
    def setOffset(self, int: int) -> None: ...
    def setStrictParsing(self, boolean: bool) -> None: ...

class WKTReader:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, geometryFactory: org.locationtech.jts.geom.GeometryFactory): ...
    @typing.overload
    def read(self, reader: java.io.Reader) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    def read(self, string: str) -> org.locationtech.jts.geom.Geometry: ...
    def setFixStructure(self, boolean: bool) -> None: ...
    def setIsOldJtsCoordinateSyntaxAllowed(self, boolean: bool) -> None: ...
    def setIsOldJtsMultiPointSyntaxAllowed(self, boolean: bool) -> None: ...

class WKTWriter:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @staticmethod
    def format(coordinate: org.locationtech.jts.geom.Coordinate) -> str: ...
    def getOutputOrdinates(self) -> java.util.EnumSet[Ordinate]: ...
    def setFormatted(self, boolean: bool) -> None: ...
    def setMaxCoordinatesPerLine(self, int: int) -> None: ...
    def setOutputOrdinates(self, enumSet: java.util.EnumSet[Ordinate]) -> None: ...
    def setPrecisionModel(self, precisionModel: org.locationtech.jts.geom.PrecisionModel) -> None: ...
    def setTab(self, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def toLineString(coordinate: org.locationtech.jts.geom.Coordinate, coordinate2: org.locationtech.jts.geom.Coordinate) -> str: ...
    @typing.overload
    @staticmethod
    def toLineString(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> str: ...
    @typing.overload
    @staticmethod
    def toLineString(coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> str: ...
    @staticmethod
    def toPoint(coordinate: org.locationtech.jts.geom.Coordinate) -> str: ...
    @typing.overload
    def write(self, geometry: org.locationtech.jts.geom.Geometry) -> str: ...
    @typing.overload
    def write(self, geometry: org.locationtech.jts.geom.Geometry, writer: java.io.Writer) -> None: ...
    @typing.overload
    def writeFormatted(self, geometry: org.locationtech.jts.geom.Geometry) -> str: ...
    @typing.overload
    def writeFormatted(self, geometry: org.locationtech.jts.geom.Geometry, writer: java.io.Writer) -> None: ...

class ByteArrayInStream(InStream):
    def __init__(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]): ...
    def read(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> int: ...
    def setBytes(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...

class InputStreamInStream(InStream):
    def __init__(self, inputStream: java.io.InputStream): ...
    def read(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> int: ...

class OutputStreamOutStream(OutStream):
    def __init__(self, outputStream: java.io.OutputStream): ...
    def write(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.io")``.

    ByteArrayInStream: typing.Type[ByteArrayInStream]
    ByteOrderDataInStream: typing.Type[ByteOrderDataInStream]
    ByteOrderValues: typing.Type[ByteOrderValues]
    InStream: typing.Type[InStream]
    InputStreamInStream: typing.Type[InputStreamInStream]
    Ordinate: typing.Type[Ordinate]
    OrdinateFormat: typing.Type[OrdinateFormat]
    OutStream: typing.Type[OutStream]
    OutputStreamOutStream: typing.Type[OutputStreamOutStream]
    ParseException: typing.Type[ParseException]
    WKBConstants: typing.Type[WKBConstants]
    WKBHexFileReader: typing.Type[WKBHexFileReader]
    WKBReader: typing.Type[WKBReader]
    WKBWriter: typing.Type[WKBWriter]
    WKTConstants: typing.Type[WKTConstants]
    WKTFileReader: typing.Type[WKTFileReader]
    WKTReader: typing.Type[WKTReader]
    WKTWriter: typing.Type[WKTWriter]
    gml2: org.locationtech.jts.io.gml2.__module_protocol__
    kml: org.locationtech.jts.io.kml.__module_protocol__
