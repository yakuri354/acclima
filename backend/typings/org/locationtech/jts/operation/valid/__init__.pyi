
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.util
import jpype
import org.locationtech.jts.algorithm
import org.locationtech.jts.geom
import typing



class IsSimpleOp:
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, boundaryNodeRule: org.locationtech.jts.algorithm.BoundaryNodeRule): ...
    @typing.overload
    def getNonSimpleLocation(self) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    @staticmethod
    def getNonSimpleLocation(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Coordinate: ...
    def getNonSimpleLocations(self) -> java.util.List[org.locationtech.jts.geom.Coordinate]: ...
    @typing.overload
    def isSimple(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isSimple(geometry: org.locationtech.jts.geom.Geometry) -> bool: ...
    def setFindAllLocations(self, boolean: bool) -> None: ...

class IsValidOp:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    def getValidationError(self) -> 'TopologyValidationError': ...
    @typing.overload
    def isValid(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isValid(coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @typing.overload
    @staticmethod
    def isValid(geometry: org.locationtech.jts.geom.Geometry) -> bool: ...
    def setSelfTouchingRingFormingHoleValid(self, boolean: bool) -> None: ...

class RepeatedPointTester:
    def __init__(self): ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    def hasRepeatedPoint(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> bool: ...
    @typing.overload
    def hasRepeatedPoint(self, geometry: org.locationtech.jts.geom.Geometry) -> bool: ...

class TopologyValidationError:
    ERROR: typing.ClassVar[int] = ...
    REPEATED_POINT: typing.ClassVar[int] = ...
    HOLE_OUTSIDE_SHELL: typing.ClassVar[int] = ...
    NESTED_HOLES: typing.ClassVar[int] = ...
    DISCONNECTED_INTERIOR: typing.ClassVar[int] = ...
    SELF_INTERSECTION: typing.ClassVar[int] = ...
    RING_SELF_INTERSECTION: typing.ClassVar[int] = ...
    NESTED_SHELLS: typing.ClassVar[int] = ...
    DUPLICATE_RINGS: typing.ClassVar[int] = ...
    TOO_FEW_POINTS: typing.ClassVar[int] = ...
    INVALID_COORDINATE: typing.ClassVar[int] = ...
    RING_NOT_CLOSED: typing.ClassVar[int] = ...
    errMsg: typing.ClassVar[typing.MutableSequence[str]] = ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, coordinate: org.locationtech.jts.geom.Coordinate): ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getErrorType(self) -> int: ...
    def getMessage(self) -> str: ...
    def toString(self) -> str: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.operation.valid")``.

    IsSimpleOp: typing.Type[IsSimpleOp]
    IsValidOp: typing.Type[IsValidOp]
    RepeatedPointTester: typing.Type[RepeatedPointTester]
    TopologyValidationError: typing.Type[TopologyValidationError]
