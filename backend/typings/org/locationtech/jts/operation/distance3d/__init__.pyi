
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import org.locationtech.jts.geom
import org.locationtech.jts.math
import org.locationtech.jts.operation.distance
import typing



class AxisPlaneCoordinateSequence(org.locationtech.jts.geom.CoordinateSequence):
    def clone(self) -> typing.Any: ...
    def copy(self) -> 'AxisPlaneCoordinateSequence': ...
    def expandEnvelope(self, envelope: org.locationtech.jts.geom.Envelope) -> org.locationtech.jts.geom.Envelope: ...
    @typing.overload
    def getCoordinate(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    @typing.overload
    def getCoordinate(self, int: int, coordinate: org.locationtech.jts.geom.Coordinate) -> None: ...
    def getCoordinateCopy(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getDimension(self) -> int: ...
    def getOrdinate(self, int: int, int2: int) -> float: ...
    def getX(self, int: int) -> float: ...
    def getY(self, int: int) -> float: ...
    def getZ(self, int: int) -> float: ...
    @staticmethod
    def projectToXY(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> org.locationtech.jts.geom.CoordinateSequence: ...
    @staticmethod
    def projectToXZ(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> org.locationtech.jts.geom.CoordinateSequence: ...
    @staticmethod
    def projectToYZ(coordinateSequence: org.locationtech.jts.geom.CoordinateSequence) -> org.locationtech.jts.geom.CoordinateSequence: ...
    def setOrdinate(self, int: int, int2: int, double: float) -> None: ...
    def size(self) -> int: ...
    def toCoordinateArray(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...

class Distance3DOp:
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, double: float): ...
    @typing.overload
    def distance(self) -> float: ...
    @typing.overload
    @staticmethod
    def distance(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> float: ...
    @staticmethod
    def isWithinDistance(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, double: float) -> bool: ...
    def nearestLocations(self) -> typing.MutableSequence[org.locationtech.jts.operation.distance.GeometryLocation]: ...
    @typing.overload
    def nearestPoints(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    @typing.overload
    @staticmethod
    def nearestPoints(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...

class PlanarPolygon3D:
    def __init__(self, polygon: org.locationtech.jts.geom.Polygon): ...
    def getPlane(self) -> org.locationtech.jts.math.Plane3D: ...
    def getPolygon(self) -> org.locationtech.jts.geom.Polygon: ...
    @typing.overload
    def intersects(self, coordinate: org.locationtech.jts.geom.Coordinate) -> bool: ...
    @typing.overload
    def intersects(self, coordinate: org.locationtech.jts.geom.Coordinate, lineString: org.locationtech.jts.geom.LineString) -> bool: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.operation.distance3d")``.

    AxisPlaneCoordinateSequence: typing.Type[AxisPlaneCoordinateSequence]
    Distance3DOp: typing.Type[Distance3DOp]
    PlanarPolygon3D: typing.Type[PlanarPolygon3D]
