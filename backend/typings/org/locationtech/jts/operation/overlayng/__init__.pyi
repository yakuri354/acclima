
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.util
import jpype
import org.locationtech.jts.geom
import org.locationtech.jts.noding
import typing



class CoverageUnion:
    @staticmethod
    def union(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Geometry: ...

class FastOverlayFilter:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    def overlay(self, geometry: org.locationtech.jts.geom.Geometry, int: int) -> org.locationtech.jts.geom.Geometry: ...

class LineLimiter:
    def __init__(self, envelope: org.locationtech.jts.geom.Envelope): ...
    def limit(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> java.util.List[typing.MutableSequence[org.locationtech.jts.geom.Coordinate]]: ...

class OverlayNG:
    INTERSECTION: typing.ClassVar[int] = ...
    UNION: typing.ClassVar[int] = ...
    DIFFERENCE: typing.ClassVar[int] = ...
    SYMDIFFERENCE: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, int: int): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, precisionModel: org.locationtech.jts.geom.PrecisionModel, int: int): ...
    def getResult(self) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def overlay(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, int: int) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def overlay(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, int: int, precisionModel: org.locationtech.jts.geom.PrecisionModel) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def overlay(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, int: int, precisionModel: org.locationtech.jts.geom.PrecisionModel, noder: org.locationtech.jts.noding.Noder) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def overlay(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, int: int, noder: org.locationtech.jts.noding.Noder) -> org.locationtech.jts.geom.Geometry: ...
    def setOptimized(self, boolean: bool) -> None: ...
    def setOutputEdges(self, boolean: bool) -> None: ...
    def setOutputNodedEdges(self, boolean: bool) -> None: ...
    def setOutputResultEdges(self, boolean: bool) -> None: ...
    def setStrictMode(self, boolean: bool) -> None: ...

class OverlayNGRobust:
    def __init__(self): ...
    @staticmethod
    def overlay(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, int: int) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def union(collection: typing.Union[java.util.Collection[org.locationtech.jts.geom.Geometry], typing.Sequence[org.locationtech.jts.geom.Geometry], typing.Set[org.locationtech.jts.geom.Geometry]]) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def union(collection: typing.Union[java.util.Collection[org.locationtech.jts.geom.Geometry], typing.Sequence[org.locationtech.jts.geom.Geometry], typing.Set[org.locationtech.jts.geom.Geometry]], geometryFactory: org.locationtech.jts.geom.GeometryFactory) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def union(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.Geometry: ...

class PrecisionReducer:
    @staticmethod
    def reducePrecision(geometry: org.locationtech.jts.geom.Geometry, precisionModel: org.locationtech.jts.geom.PrecisionModel) -> org.locationtech.jts.geom.Geometry: ...

class PrecisionUtil:
    MAX_ROBUST_DP_DIGITS: typing.ClassVar[int] = ...
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def inherentScale(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def inherentScale(geometry: org.locationtech.jts.geom.Geometry) -> float: ...
    @typing.overload
    @staticmethod
    def inherentScale(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> float: ...
    @typing.overload
    @staticmethod
    def robustPM(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.PrecisionModel: ...
    @typing.overload
    @staticmethod
    def robustPM(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.geom.PrecisionModel: ...
    @typing.overload
    @staticmethod
    def robustScale(geometry: org.locationtech.jts.geom.Geometry) -> float: ...
    @typing.overload
    @staticmethod
    def robustScale(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> float: ...
    @typing.overload
    @staticmethod
    def safeScale(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def safeScale(geometry: org.locationtech.jts.geom.Geometry) -> float: ...
    @typing.overload
    @staticmethod
    def safeScale(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> float: ...

class RingClipper:
    def __init__(self, envelope: org.locationtech.jts.geom.Envelope): ...
    def clip(self, coordinateArray: typing.Union[typing.List[org.locationtech.jts.geom.Coordinate], jpype.JArray]) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...

class UnaryUnionNG:
    @typing.overload
    @staticmethod
    def union(collection: typing.Union[java.util.Collection[org.locationtech.jts.geom.Geometry], typing.Sequence[org.locationtech.jts.geom.Geometry], typing.Set[org.locationtech.jts.geom.Geometry]], geometryFactory: org.locationtech.jts.geom.GeometryFactory, precisionModel: org.locationtech.jts.geom.PrecisionModel) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def union(collection: typing.Union[java.util.Collection[org.locationtech.jts.geom.Geometry], typing.Sequence[org.locationtech.jts.geom.Geometry], typing.Set[org.locationtech.jts.geom.Geometry]], precisionModel: org.locationtech.jts.geom.PrecisionModel) -> org.locationtech.jts.geom.Geometry: ...
    @typing.overload
    @staticmethod
    def union(geometry: org.locationtech.jts.geom.Geometry, precisionModel: org.locationtech.jts.geom.PrecisionModel) -> org.locationtech.jts.geom.Geometry: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.operation.overlayng")``.

    CoverageUnion: typing.Type[CoverageUnion]
    FastOverlayFilter: typing.Type[FastOverlayFilter]
    LineLimiter: typing.Type[LineLimiter]
    OverlayNG: typing.Type[OverlayNG]
    OverlayNGRobust: typing.Type[OverlayNGRobust]
    PrecisionReducer: typing.Type[PrecisionReducer]
    PrecisionUtil: typing.Type[PrecisionUtil]
    RingClipper: typing.Type[RingClipper]
    UnaryUnionNG: typing.Type[UnaryUnionNG]
