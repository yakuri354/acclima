
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.util
import org.locationtech.jts.geom
import org.locationtech.jts.index.strtree
import typing



class ConnectedElementLocationFilter(org.locationtech.jts.geom.GeometryFilter):
    def filter(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    @staticmethod
    def getLocations(geometry: org.locationtech.jts.geom.Geometry) -> java.util.List: ...

class ConnectedElementPointFilter(org.locationtech.jts.geom.GeometryFilter):
    def filter(self, geometry: org.locationtech.jts.geom.Geometry) -> None: ...
    @staticmethod
    def getCoordinates(geometry: org.locationtech.jts.geom.Geometry) -> java.util.List: ...

class DistanceOp:
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, double: float): ...
    def closestLocations(self) -> typing.MutableSequence['GeometryLocation']: ...
    @typing.overload
    def closestPoints(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    @typing.overload
    @staticmethod
    def closestPoints(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    @typing.overload
    def distance(self) -> float: ...
    @typing.overload
    @staticmethod
    def distance(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> float: ...
    @staticmethod
    def isWithinDistance(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, double: float) -> bool: ...
    def nearestLocations(self) -> typing.MutableSequence['GeometryLocation']: ...
    @typing.overload
    def nearestPoints(self) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    @typing.overload
    @staticmethod
    def nearestPoints(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...

class FacetSequence:
    @typing.overload
    def __init__(self, coordinateSequence: org.locationtech.jts.geom.CoordinateSequence, int: int): ...
    @typing.overload
    def __init__(self, coordinateSequence: org.locationtech.jts.geom.CoordinateSequence, int: int, int2: int): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, coordinateSequence: org.locationtech.jts.geom.CoordinateSequence, int: int, int2: int): ...
    def distance(self, facetSequence: 'FacetSequence') -> float: ...
    def getCoordinate(self, int: int) -> org.locationtech.jts.geom.Coordinate: ...
    def getEnvelope(self) -> org.locationtech.jts.geom.Envelope: ...
    def isPoint(self) -> bool: ...
    def nearestLocations(self, facetSequence: 'FacetSequence') -> typing.MutableSequence['GeometryLocation']: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...

class FacetSequenceTreeBuilder:
    def __init__(self): ...
    @staticmethod
    def build(geometry: org.locationtech.jts.geom.Geometry) -> org.locationtech.jts.index.strtree.STRtree: ...

class GeometryLocation:
    INSIDE_AREA: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, int: int, coordinate: org.locationtech.jts.geom.Coordinate): ...
    @typing.overload
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry, coordinate: org.locationtech.jts.geom.Coordinate): ...
    def getCoordinate(self) -> org.locationtech.jts.geom.Coordinate: ...
    def getGeometryComponent(self) -> org.locationtech.jts.geom.Geometry: ...
    def getSegmentIndex(self) -> int: ...
    def isInsideArea(self) -> bool: ...
    def toString(self) -> str: ...

class IndexedFacetDistance:
    def __init__(self, geometry: org.locationtech.jts.geom.Geometry): ...
    @typing.overload
    def distance(self, geometry: org.locationtech.jts.geom.Geometry) -> float: ...
    @typing.overload
    @staticmethod
    def distance(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> float: ...
    @typing.overload
    def isWithinDistance(self, geometry: org.locationtech.jts.geom.Geometry, double: float) -> bool: ...
    @typing.overload
    @staticmethod
    def isWithinDistance(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry, double: float) -> bool: ...
    def nearestLocations(self, geometry: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence[GeometryLocation]: ...
    @typing.overload
    def nearestPoints(self, geometry: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...
    @typing.overload
    @staticmethod
    def nearestPoints(geometry: org.locationtech.jts.geom.Geometry, geometry2: org.locationtech.jts.geom.Geometry) -> typing.MutableSequence[org.locationtech.jts.geom.Coordinate]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.operation.distance")``.

    ConnectedElementLocationFilter: typing.Type[ConnectedElementLocationFilter]
    ConnectedElementPointFilter: typing.Type[ConnectedElementPointFilter]
    DistanceOp: typing.Type[DistanceOp]
    FacetSequence: typing.Type[FacetSequence]
    FacetSequenceTreeBuilder: typing.Type[FacetSequenceTreeBuilder]
    GeometryLocation: typing.Type[GeometryLocation]
    IndexedFacetDistance: typing.Type[IndexedFacetDistance]
