
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.util
import typing



class Bintree:
    def __init__(self): ...
    def depth(self) -> int: ...
    @staticmethod
    def ensureExtent(interval: 'Interval', double: float) -> 'Interval': ...
    def insert(self, interval: 'Interval', object: typing.Any) -> None: ...
    def iterator(self) -> java.util.Iterator: ...
    def nodeSize(self) -> int: ...
    @typing.overload
    def query(self, double: float) -> java.util.List: ...
    @typing.overload
    def query(self, interval: 'Interval') -> java.util.List: ...
    @typing.overload
    def query(self, interval: 'Interval', collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def remove(self, interval: 'Interval', object: typing.Any) -> bool: ...
    def size(self) -> int: ...

class Interval:
    min: float = ...
    max: float = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, interval: 'Interval'): ...
    @typing.overload
    def contains(self, double: float) -> bool: ...
    @typing.overload
    def contains(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def contains(self, interval: 'Interval') -> bool: ...
    def expandToInclude(self, interval: 'Interval') -> None: ...
    def getMax(self) -> float: ...
    def getMin(self) -> float: ...
    def getWidth(self) -> float: ...
    def init(self, double: float, double2: float) -> None: ...
    @typing.overload
    def overlaps(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def overlaps(self, interval: 'Interval') -> bool: ...
    def toString(self) -> str: ...

class Key:
    def __init__(self, interval: Interval): ...
    def computeKey(self, interval: Interval) -> None: ...
    @staticmethod
    def computeLevel(interval: Interval) -> int: ...
    def getInterval(self) -> Interval: ...
    def getLevel(self) -> int: ...
    def getPoint(self) -> float: ...

class NodeBase:
    def __init__(self): ...
    def add(self, object: typing.Any) -> None: ...
    def addAllItems(self, list: java.util.List) -> java.util.List: ...
    def addAllItemsFromOverlapping(self, interval: Interval, collection: typing.Union[java.util.Collection, typing.Sequence, typing.Set]) -> None: ...
    def getItems(self) -> java.util.List: ...
    @staticmethod
    def getSubnodeIndex(interval: Interval, double: float) -> int: ...
    def hasChildren(self) -> bool: ...
    def hasItems(self) -> bool: ...
    def isPrunable(self) -> bool: ...
    def remove(self, interval: Interval, object: typing.Any) -> bool: ...

class Node(NodeBase):
    def __init__(self, interval: Interval, int2: int): ...
    @staticmethod
    def createExpanded(node: 'Node', interval: Interval) -> 'Node': ...
    @staticmethod
    def createNode(interval: Interval) -> 'Node': ...
    def find(self, interval: Interval) -> NodeBase: ...
    def getInterval(self) -> Interval: ...
    def getNode(self, interval: Interval) -> 'Node': ...

class Root(NodeBase):
    def __init__(self): ...
    def insert(self, interval: Interval, object: typing.Any) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.index.bintree")``.

    Bintree: typing.Type[Bintree]
    Interval: typing.Type[Interval]
    Key: typing.Type[Key]
    Node: typing.Type[Node]
    NodeBase: typing.Type[NodeBase]
    Root: typing.Type[Root]
