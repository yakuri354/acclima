
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.util
import org.locationtech.jts.geom
import org.locationtech.jts.index
import typing



class AbstractSTRtree(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, arrayList: java.util.ArrayList): ...
    @typing.overload
    def __init__(self, int: int, abstractNode: 'AbstractNode'): ...
    def build(self) -> None: ...
    def getNodeCapacity(self) -> int: ...
    def getRoot(self) -> 'AbstractNode': ...
    def isEmpty(self) -> bool: ...
    def itemsTree(self) -> java.util.List: ...

class Boundable:
    def getBounds(self) -> typing.Any: ...

class BoundablePairDistanceComparator(java.util.Comparator['BoundablePair'], java.io.Serializable):
    def __init__(self, boolean: bool): ...
    def compare(self, boundablePair: 'BoundablePair', boundablePair2: 'BoundablePair') -> int: ...

class EnvelopeDistance:
    def __init__(self): ...
    @staticmethod
    def maximumDistance(envelope: org.locationtech.jts.geom.Envelope, envelope2: org.locationtech.jts.geom.Envelope) -> float: ...
    @staticmethod
    def minMaxDistance(envelope: org.locationtech.jts.geom.Envelope, envelope2: org.locationtech.jts.geom.Envelope) -> float: ...

class Interval:
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, interval: 'Interval'): ...
    def equals(self, object: typing.Any) -> bool: ...
    def expandToInclude(self, interval: 'Interval') -> 'Interval': ...
    def getCentre(self) -> float: ...
    def hashCode(self) -> int: ...
    def intersects(self, interval: 'Interval') -> bool: ...

class ItemDistance:
    def distance(self, itemBoundable: 'ItemBoundable', itemBoundable2: 'ItemBoundable') -> float: ...

class BoundablePair: ...

class AbstractNode(Boundable, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def addChildBoundable(self, boundable: Boundable) -> None: ...
    def getBounds(self) -> typing.Any: ...
    def getChildBoundables(self) -> java.util.List: ...
    def getLevel(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def size(self) -> int: ...

class GeometryItemDistance(ItemDistance):
    def __init__(self): ...
    def distance(self, itemBoundable: 'ItemBoundable', itemBoundable2: 'ItemBoundable') -> float: ...

class ItemBoundable(Boundable, java.io.Serializable):
    def __init__(self, object: typing.Any, object2: typing.Any): ...
    def getBounds(self) -> typing.Any: ...
    def getItem(self) -> typing.Any: ...

class SIRtree(AbstractSTRtree):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def insert(self, double: float, double2: float, object: typing.Any) -> None: ...
    @typing.overload
    def query(self, double: float) -> java.util.List: ...
    @typing.overload
    def query(self, double: float, double2: float) -> java.util.List: ...

class STRtree(AbstractSTRtree, org.locationtech.jts.index.SpatialIndex, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, arrayList: java.util.ArrayList): ...
    @typing.overload
    def __init__(self, int: int, sTRtreeNode: 'STRtree.STRtreeNode'): ...
    def depth(self) -> int: ...
    def insert(self, envelope: org.locationtech.jts.geom.Envelope, object: typing.Any) -> None: ...
    def isWithinDistance(self, sTRtree: 'STRtree', itemDistance: ItemDistance, double: float) -> bool: ...
    @typing.overload
    def nearestNeighbour(self, envelope: org.locationtech.jts.geom.Envelope, object: typing.Any, itemDistance: ItemDistance) -> typing.Any: ...
    @typing.overload
    def nearestNeighbour(self, envelope: org.locationtech.jts.geom.Envelope, object: typing.Any, itemDistance: ItemDistance, int: int) -> typing.MutableSequence[typing.Any]: ...
    @typing.overload
    def nearestNeighbour(self, itemDistance: ItemDistance) -> typing.MutableSequence[typing.Any]: ...
    @typing.overload
    def nearestNeighbour(self, sTRtree: 'STRtree', itemDistance: ItemDistance) -> typing.MutableSequence[typing.Any]: ...
    @typing.overload
    def query(self, envelope: org.locationtech.jts.geom.Envelope) -> java.util.List: ...
    @typing.overload
    def query(self, envelope: org.locationtech.jts.geom.Envelope, itemVisitor: org.locationtech.jts.index.ItemVisitor) -> None: ...
    def remove(self, envelope: org.locationtech.jts.geom.Envelope, object: typing.Any) -> bool: ...
    def size(self) -> int: ...
    class STRtreeNode: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.locationtech.jts.index.strtree")``.

    AbstractNode: typing.Type[AbstractNode]
    AbstractSTRtree: typing.Type[AbstractSTRtree]
    Boundable: typing.Type[Boundable]
    BoundablePair: typing.Type[BoundablePair]
    BoundablePairDistanceComparator: typing.Type[BoundablePairDistanceComparator]
    EnvelopeDistance: typing.Type[EnvelopeDistance]
    GeometryItemDistance: typing.Type[GeometryItemDistance]
    Interval: typing.Type[Interval]
    ItemBoundable: typing.Type[ItemBoundable]
    ItemDistance: typing.Type[ItemDistance]
    SIRtree: typing.Type[SIRtree]
    STRtree: typing.Type[STRtree]
